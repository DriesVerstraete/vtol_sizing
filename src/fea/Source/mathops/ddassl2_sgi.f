! ======================================================================
! NIST GUIDE TO AVAILABLE MATH SOFTWARE.
! FULLSOURCE FOR MODULE DDASSL FROM PACKAGE SLATEC.
! RETRIEVED FROM CAMSUN ON TUE FEB 25 21:59:34 1997.
! ======================================================================
C  *****************************************************************
C   NOTE!!! SUBROUTINES                            !!!  !!! 
C            I   D   A   M   A   X   (FUNCTION)    !!!  !!! 
C                                                  !!!  !!!
C        D   S   C   A   L                     !!!  !!!
C                 
C                                                  !!!  !!!
C   COMMANDED   (I MEAN CANCELLED WITH C) 
C   BECAUSE THEY ARE ALREADY PRESENT IN NETLIB1.F  JUNE 6, 99
C*******************************************************************
*DECK DDASSL
      SUBROUTINE DDASSL (RES, NEQ, T, Y, YPRIME, TOUT, INFO, RTOL, ATOL,
     *   IDID, RWORK, LRW, IWORK, LIW, RPAR, IPAR, JAC)
C***BEGIN PROLOGUE  DDASSL
C***PURPOSE  THIS CODE SOLVES A SYSTEM OF DIFFERENTIAL/ALGEBRAIC
C            EQUATIONS OF THE FORM G(T,Y,YPRIME) = 0.
C***LIBRARY   SLATEC (DASSL)
C***CATEGORY  I1A2
C***TYPE      DOUBLE PRECISION (SDASSL-S, DDASSL-D)
C***KEYWORDS  BACKWARD DIFFERENTIATION FORMULAS, DASSL,
C             DIFFERENTIAL/ALGEBRAIC, IMPLICIT DIFFERENTIAL SYSTEMS
C***AUTHOR  PETZOLD, LINDA R., (LLNL)
C             COMPUTING AND MATHEMATICS RESEARCH DIVISION
C             LAWRENCE LIVERMORE NATIONAL LABORATORY
C             L - 316, P.O. BOX 808,
C             LIVERMORE, CA.    94550
C***DESCRIPTION
C
C *USAGE:
C
C      EXTERNAL RES, JAC
C      INTEGER NEQ, INFO(N), IDID, LRW, LIW, IWORK(LIW), IPAR
C      DOUBLE PRECISION T, Y(NEQ), YPRIME(NEQ), TOUT, RTOL, ATOL,
C     *   RWORK(LRW), RPAR
C
C      CALL DDASSL (RES, NEQ, T, Y, YPRIME, TOUT, INFO, RTOL, ATOL,
C     *   IDID, RWORK, LRW, IWORK, LIW, RPAR, IPAR, JAC)
C
C
C *ARGUMENTS:
C  (IN THE FOLLOWING, ALL REAL ARRAYS SHOULD BE TYPE DOUBLE PRECISION.)
C
C  RES:EXT     THIS IS A SUBROUTINE WHICH YOU PROVIDE TO DEFINE THE
C              DIFFERENTIAL/ALGEBRAIC SYSTEM.
C
C  NEQ:IN      THIS IS THE NUMBER OF EQUATIONS TO BE SOLVED.
C
C  T:INOUT     THIS IS THE CURRENT VALUE OF THE INDEPENDENT VARIABLE.
C
C  Y(*):INOUT  THIS ARRAY CONTAINS THE SOLUTION COMPONENTS AT T.
C
C  YPRIME(*):INOUT  THIS ARRAY CONTAINS THE DERIVATIVES OF THE SOLUTION
C              COMPONENTS AT T.
C
C  TOUT:IN     THIS IS A POINT AT WHICH A SOLUTION IS DESIRED.
C
C  INFO(N):IN  THE BASIC TASK OF THE CODE IS TO SOLVE THE SYSTEM FROM T
C              TO TOUT AND RETURN AN ANSWER AT TOUT.  INFO IS AN INTEGER
C              ARRAY WHICH IS USED TO COMMUNICATE EXACTLY HOW YOU WANT
C              THIS TASK TO BE CARRIED OUT.  (SEE BELOW FOR DETAILS.)
C              N MUST BE GREATER THAN OR EQUAL TO 15.
C
C  RTOL,ATOL:INOUT  THESE QUANTITIES REPRESENT RELATIVE AND ABSOLUTE
C              ERROR TOLERANCES WHICH YOU PROVIDE TO INDICATE HOW
C              ACCURATELY YOU WISH THE SOLUTION TO BE COMPUTED.  YOU
C              MAY CHOOSE THEM TO BE BOTH SCALARS OR ELSE BOTH VECTORS.
C              CAUTION:  IN FORTRAN 77, A SCALAR IS NOT THE SAME AS AN
C                        ARRAY OF LENGTH 1.  SOME COMPILERS MAY OBJECT
C                        TO USING SCALARS FOR RTOL,ATOL.
C
C  IDID:OUT    THIS SCALAR QUANTITY IS AN INDICATOR REPORTING WHAT THE
C              CODE DID.  YOU MUST MONITOR THIS INTEGER VARIABLE TO
C              DECIDE  WHAT ACTION TO TAKE NEXT.
C
C  RWORK:WORK  A REAL WORK ARRAY OF LENGTH LRW WHICH PROVIDES THE
C              CODE WITH NEEDED STORAGE SPACE.
C
C  LRW:IN      THE LENGTH OF RWORK.  (SEE BELOW FOR REQUIRED LENGTH.)
C
C  IWORK:WORK  AN INTEGER WORK ARRAY OF LENGTH LIW WHICH PROVIDES THE
C              CODE WITH NEEDED STORAGE SPACE.
C
C  LIW:IN      THE LENGTH OF IWORK.  (SEE BELOW FOR REQUIRED LENGTH.)
C
C  RPAR,IPAR:IN  THESE ARE REAL AND INTEGER PARAMETER ARRAYS WHICH
C              YOU CAN USE FOR COMMUNICATION BETWEEN YOUR CALLING
C              PROGRAM AND THE RES SUBROUTINE (AND THE JAC SUBROUTINE)
C
C  JAC:EXT     THIS IS THE NAME OF A SUBROUTINE WHICH YOU MAY CHOOSE
C              TO PROVIDE FOR DEFINING A MATRIX OF PARTIAL DERIVATIVES
C              DESCRIBED BELOW.
C
C  QUANTITIES WHICH MAY BE ALTERED BY DDASSL ARE:
C     T, Y(*), YPRIME(*), INFO(1), RTOL, ATOL,
C     IDID, RWORK(*) AND IWORK(*)
C
C *DESCRIPTION
C
C  SUBROUTINE DDASSL USES THE BACKWARD DIFFERENTIATION FORMULAS OF
C  ORDERS ONE THROUGH FIVE TO SOLVE A SYSTEM OF THE ABOVE FORM FOR Y AND
C  YPRIME.  VALUES FOR Y AND YPRIME AT THE INITIAL TIME MUST BE GIVEN AS
C  INPUT.  THESE VALUES MUST BE CONSISTENT, (THAT IS, IF T,Y,YPRIME ARE
C  THE GIVEN INITIAL VALUES, THEY MUST SATISFY G(T,Y,YPRIME) = 0.).  THE
C  SUBROUTINE SOLVES THE SYSTEM FROM T TO TOUT.  IT IS EASY TO CONTINUE
C  THE SOLUTION TO GET RESULTS AT ADDITIONAL TOUT.  THIS IS THE INTERVAL
C  MODE OF OPERATION.  INTERMEDIATE RESULTS CAN ALSO BE OBTAINED EASILY
C  BY USING THE INTERMEDIATE-OUTPUT CAPABILITY.
C
C  THE FOLLOWING DETAILED DESCRIPTION IS DIVIDED INTO SUBSECTIONS:
C    1. INPUT REQUIRED FOR THE FIRST CALL TO DDASSL.
C    2. OUTPUT AFTER ANY RETURN FROM DDASSL.
C    3. WHAT TO DO TO CONTINUE THE INTEGRATION.
C    4. ERROR MESSAGES.
C
C
C  -------- INPUT -- WHAT TO DO ON THE FIRST CALL TO DDASSL ------------
C
C  THE FIRST CALL OF THE CODE IS DEFINED TO BE THE START OF EACH NEW
C  PROBLEM. READ THROUGH THE DESCRIPTIONS OF ALL THE FOLLOWING ITEMS,
C  PROVIDE SUFFICIENT STORAGE SPACE FOR DESIGNATED ARRAYS, SET
C  APPROPRIATE VARIABLES FOR THE INITIALIZATION OF THE PROBLEM, AND
C  GIVE INFORMATION ABOUT HOW YOU WANT THE PROBLEM TO BE SOLVED.
C
C
C  RES -- PROVIDE A SUBROUTINE OF THE FORM
C             SUBROUTINE RES(T,Y,YPRIME,DELTA,IRES,RPAR,IPAR)
C         TO DEFINE THE SYSTEM OF DIFFERENTIAL/ALGEBRAIC
C         EQUATIONS WHICH IS TO BE SOLVED. FOR THE GIVEN VALUES
C         OF T,Y AND YPRIME, THE SUBROUTINE SHOULD
C         RETURN THE RESIDUAL OF THE DIFFERENTIAL/ALGEBRAIC
C         SYSTEM
C             DELTA = G(T,Y,YPRIME)
C         (DELTA(*) IS A VECTOR OF LENGTH NEQ WHICH IS
C         OUTPUT FOR RES.)
C
C         SUBROUTINE RES MUST NOT ALTER T,Y OR YPRIME.
C         YOU MUST DECLARE THE NAME RES IN AN EXTERNAL
C         STATEMENT IN YOUR PROGRAM THAT CALLS DDASSL.
C         YOU MUST DIMENSION Y,YPRIME AND DELTA IN RES.
C
C         IRES IS AN INTEGER FLAG WHICH IS ALWAYS EQUAL TO
C         ZERO ON INPUT. SUBROUTINE RES SHOULD ALTER IRES
C         ONLY IF IT ENCOUNTERS AN ILLEGAL VALUE OF Y OR
C         A STOP CONDITION. SET IRES = -1 IF AN INPUT VALUE
C         IS ILLEGAL, AND DDASSL WILL TRY TO SOLVE THE PROBLEM
C         WITHOUT GETTING IRES = -1. IF IRES = -2, DDASSL
C         WILL RETURN CONTROL TO THE CALLING PROGRAM
C         WITH IDID = -11.
C
C         RPAR AND IPAR ARE REAL AND INTEGER PARAMETER ARRAYS WHICH
C         YOU CAN USE FOR COMMUNICATION BETWEEN YOUR CALLING PROGRAM
C         AND SUBROUTINE RES. THEY ARE NOT ALTERED BY DDASSL. IF YOU
C         DO NOT NEED RPAR OR IPAR, IGNORE THESE PARAMETERS BY TREAT-
C         ING THEM AS DUMMY ARGUMENTS. IF YOU DO CHOOSE TO USE THEM,
C         DIMENSION THEM IN YOUR CALLING PROGRAM AND IN RES AS ARRAYS
C         OF APPROPRIATE LENGTH.
C
C  NEQ -- SET IT TO THE NUMBER OF DIFFERENTIAL EQUATIONS.
C         (NEQ .GE. 1)
C
C  T -- SET IT TO THE INITIAL POINT OF THE INTEGRATION.
C         T MUST BE DEFINED AS A VARIABLE.
C
C  Y(*) -- SET THIS VECTOR TO THE INITIAL VALUES OF THE NEQ SOLUTION
C         COMPONENTS AT THE INITIAL POINT. YOU MUST DIMENSION Y OF
C         LENGTH AT LEAST NEQ IN YOUR CALLING PROGRAM.
C
C  YPRIME(*) -- SET THIS VECTOR TO THE INITIAL VALUES OF THE NEQ
C         FIRST DERIVATIVES OF THE SOLUTION COMPONENTS AT THE INITIAL
C         POINT.  YOU MUST DIMENSION YPRIME AT LEAST NEQ IN YOUR
C         CALLING PROGRAM. IF YOU DO NOT KNOW INITIAL VALUES OF SOME
C         OF THE SOLUTION COMPONENTS, SEE THE EXPLANATION OF INFO(11).
C
C  TOUT -- SET IT TO THE FIRST POINT AT WHICH A SOLUTION
C         IS DESIRED. YOU CAN NOT TAKE TOUT = T.
C         INTEGRATION EITHER FORWARD IN T (TOUT .GT. T) OR
C         BACKWARD IN T (TOUT .LT. T) IS PERMITTED.
C
C         THE CODE ADVANCES THE SOLUTION FROM T TO TOUT USING
C         STEP SIZES WHICH ARE AUTOMATICALLY SELECTED SO AS TO
C         ACHIEVE THE DESIRED ACCURACY. IF YOU WISH, THE CODE WILL
C         RETURN WITH THE SOLUTION AND ITS DERIVATIVE AT
C         INTERMEDIATE STEPS (INTERMEDIATE-OUTPUT MODE) SO THAT
C         YOU CAN MONITOR THEM, BUT YOU STILL MUST PROVIDE TOUT IN
C         ACCORD WITH THE BASIC AIM OF THE CODE.
C
C         THE FIRST STEP TAKEN BY THE CODE IS A CRITICAL ONE
C         BECAUSE IT MUST REFLECT HOW FAST THE SOLUTION CHANGES NEAR
C         THE INITIAL POINT. THE CODE AUTOMATICALLY SELECTS AN
C         INITIAL STEP SIZE WHICH IS PRACTICALLY ALWAYS SUITABLE FOR
C         THE PROBLEM. BY USING THE FACT THAT THE CODE WILL NOT STEP
C         PAST TOUT IN THE FIRST STEP, YOU COULD, IF NECESSARY,
C         RESTRICT THE LENGTH OF THE INITIAL STEP SIZE.
C
C         FOR SOME PROBLEMS IT MAY NOT BE PERMISSIBLE TO INTEGRATE
C         PAST A POINT TSTOP BECAUSE A DISCONTINUITY OCCURS THERE
C         OR THE SOLUTION OR ITS DERIVATIVE IS NOT DEFINED BEYOND
C         TSTOP. WHEN YOU HAVE DECLARED A TSTOP POINT (SEE INFO(4)
C         AND RWORK(1)), YOU HAVE TOLD THE CODE NOT TO INTEGRATE
C         PAST TSTOP. IN THIS CASE ANY TOUT BEYOND TSTOP IS INVALID
C         INPUT.
C
C  INFO(*) -- USE THE INFO ARRAY TO GIVE THE CODE MORE DETAILS ABOUT
C         HOW YOU WANT YOUR PROBLEM SOLVED.  THIS ARRAY SHOULD BE
C         DIMENSIONED OF LENGTH 15, THOUGH DDASSL USES ONLY THE FIRST
C         ELEVEN ENTRIES.  YOU MUST RESPOND TO ALL OF THE FOLLOWING
C         ITEMS, WHICH ARE ARRANGED AS QUESTIONS.  THE SIMPLEST USE
C         OF THE CODE CORRESPONDS TO ANSWERING ALL QUESTIONS AS YES,
C         I.E. SETTING ALL ENTRIES OF INFO TO 0.
C
C       INFO(1) - THIS PARAMETER ENABLES THE CODE TO INITIALIZE
C              ITSELF. YOU MUST SET IT TO INDICATE THE START OF EVERY
C              NEW PROBLEM.
C
C          **** IS THIS THE FIRST CALL FOR THIS PROBLEM ...
C                YES - SET INFO(1) = 0
C                 NO - NOT APPLICABLE HERE.
C                      SEE BELOW FOR CONTINUATION CALLS.  ****
C
C       INFO(2) - HOW MUCH ACCURACY YOU WANT OF YOUR SOLUTION
C              IS SPECIFIED BY THE ERROR TOLERANCES RTOL AND ATOL.
C              THE SIMPLEST USE IS TO TAKE THEM BOTH TO BE SCALARS.
C              TO OBTAIN MORE FLEXIBILITY, THEY CAN BOTH BE VECTORS.
C              THE CODE MUST BE TOLD YOUR CHOICE.
C
C          **** ARE BOTH ERROR TOLERANCES RTOL, ATOL SCALARS ...
C                YES - SET INFO(2) = 0
C                      AND INPUT SCALARS FOR BOTH RTOL AND ATOL
C                 NO - SET INFO(2) = 1
C                      AND INPUT ARRAYS FOR BOTH RTOL AND ATOL ****
C
C       INFO(3) - THE CODE INTEGRATES FROM T IN THE DIRECTION
C              OF TOUT BY STEPS. IF YOU WISH, IT WILL RETURN THE
C              COMPUTED SOLUTION AND DERIVATIVE AT THE NEXT
C              INTERMEDIATE STEP (THE INTERMEDIATE-OUTPUT MODE) OR
C              TOUT, WHICHEVER COMES FIRST. THIS IS A GOOD WAY TO
C              PROCEED IF YOU WANT TO SEE THE BEHAVIOR OF THE SOLUTION.
C              IF YOU MUST HAVE SOLUTIONS AT A GREAT MANY SPECIFIC
C              TOUT POINTS, THIS CODE WILL COMPUTE THEM EFFICIENTLY.
C
C          **** DO YOU WANT THE SOLUTION ONLY AT
C                TOUT (AND NOT AT THE NEXT INTERMEDIATE STEP) ...
C                 YES - SET INFO(3) = 0
C                  NO - SET INFO(3) = 1 ****
C
C       INFO(4) - TO HANDLE SOLUTIONS AT A GREAT MANY SPECIFIC
C              VALUES TOUT EFFICIENTLY, THIS CODE MAY INTEGRATE PAST
C              TOUT AND INTERPOLATE TO OBTAIN THE RESULT AT TOUT.
C              SOMETIMES IT IS NOT POSSIBLE TO INTEGRATE BEYOND SOME
C              POINT TSTOP BECAUSE THE EQUATION CHANGES THERE OR IT IS
C              NOT DEFINED PAST TSTOP. THEN YOU MUST TELL THE CODE
C              NOT TO GO PAST.
C
C           **** CAN THE INTEGRATION BE CARRIED OUT WITHOUT ANY
C                RESTRICTIONS ON THE INDEPENDENT VARIABLE T ...
C                 YES - SET INFO(4)=0
C                  NO - SET INFO(4)=1
C                       AND DEFINE THE STOPPING POINT TSTOP BY
C                       SETTING RWORK(1)=TSTOP ****
C
C       INFO(5) - TO SOLVE DIFFERENTIAL/ALGEBRAIC PROBLEMS IT IS
C              NECESSARY TO USE A MATRIX OF PARTIAL DERIVATIVES OF THE
C              SYSTEM OF DIFFERENTIAL EQUATIONS. IF YOU DO NOT
C              PROVIDE A SUBROUTINE TO EVALUATE IT ANALYTICALLY (SEE
C              DESCRIPTION OF THE ITEM JAC IN THE CALL LIST), IT WILL
C              BE APPROXIMATED BY NUMERICAL DIFFERENCING IN THIS CODE.
C              ALTHOUGH IT IS LESS TROUBLE FOR YOU TO HAVE THE CODE
C              COMPUTE PARTIAL DERIVATIVES BY NUMERICAL DIFFERENCING,
C              THE SOLUTION WILL BE MORE RELIABLE IF YOU PROVIDE THE
C              DERIVATIVES VIA JAC. SOMETIMES NUMERICAL DIFFERENCING
C              IS CHEAPER THAN EVALUATING DERIVATIVES IN JAC AND
C              SOMETIMES IT IS NOT - THIS DEPENDS ON YOUR PROBLEM.
C
C           **** DO YOU WANT THE CODE TO EVALUATE THE PARTIAL
C                DERIVATIVES AUTOMATICALLY BY NUMERICAL DIFFERENCES ...
C                   YES - SET INFO(5)=0
C                    NO - SET INFO(5)=1
C                  AND PROVIDE SUBROUTINE JAC FOR EVALUATING THE
C                  MATRIX OF PARTIAL DERIVATIVES ****
C
C       INFO(6) - DDASSL WILL PERFORM MUCH BETTER IF THE MATRIX OF
C              PARTIAL DERIVATIVES, DG/DY + CJ*DG/DYPRIME,
C              (HERE CJ IS A SCALAR DETERMINED BY DDASSL)
C              IS BANDED AND THE CODE IS TOLD THIS. IN THIS
C              CASE, THE STORAGE NEEDED WILL BE GREATLY REDUCED,
C              NUMERICAL DIFFERENCING WILL BE PERFORMED MUCH CHEAPER,
C              AND A NUMBER OF IMPORTANT ALGORITHMS WILL EXECUTE MUCH
C              FASTER. THE DIFFERENTIAL EQUATION IS SAID TO HAVE
C              HALF-BANDWIDTHS ML (LOWER) AND MU (UPPER) IF EQUATION I
C              INVOLVES ONLY UNKNOWNS Y(J) WITH
C                             I-ML .LE. J .LE. I+MU
C              FOR ALL I=1,2,...,NEQ. THUS, ML AND MU ARE THE WIDTHS
C              OF THE LOWER AND UPPER PARTS OF THE BAND, RESPECTIVELY,
C              WITH THE MAIN DIAGONAL BEING EXCLUDED. IF YOU DO NOT
C              INDICATE THAT THE EQUATION HAS A BANDED MATRIX OF PARTIAL
C              DERIVATIVES, THE CODE WORKS WITH A FULL MATRIX OF NEQ**2
C              ELEMENTS (STORED IN THE CONVENTIONAL WAY). COMPUTATIONS
C              WITH BANDED MATRICES COST LESS TIME AND STORAGE THAN WITH
C              FULL MATRICES IF 2*ML+MU .LT. NEQ. IF YOU TELL THE
C              CODE THAT THE MATRIX OF PARTIAL DERIVATIVES HAS A BANDED
C              STRUCTURE AND YOU WANT TO PROVIDE SUBROUTINE JAC TO
C              COMPUTE THE PARTIAL DERIVATIVES, THEN YOU MUST BE CAREFUL
C              TO STORE THE ELEMENTS OF THE MATRIX IN THE SPECIAL FORM
C              INDICATED IN THE DESCRIPTION OF JAC.
C
C          **** DO YOU WANT TO SOLVE THE PROBLEM USING A FULL
C               (DENSE) MATRIX (AND NOT A SPECIAL BANDED
C               STRUCTURE) ...
C                YES - SET INFO(6)=0
C                 NO - SET INFO(6)=1
C                       AND PROVIDE THE LOWER (ML) AND UPPER (MU)
C                       BANDWIDTHS BY SETTING
C                       IWORK(1)=ML
C                       IWORK(2)=MU ****
C
C
C        INFO(7) -- YOU CAN SPECIFY A MAXIMUM (ABSOLUTE VALUE OF)
C              STEPSIZE, SO THAT THE CODE
C              WILL AVOID PASSING OVER VERY
C              LARGE REGIONS.
C
C          ****  DO YOU WANT THE CODE TO DECIDE
C                ON ITS OWN MAXIMUM STEPSIZE?
C                YES - SET INFO(7)=0
C                 NO - SET INFO(7)=1
C                      AND DEFINE HMAX BY SETTING
C                      RWORK(2)=HMAX ****
C
C        INFO(8) -- DIFFERENTIAL/ALGEBRAIC PROBLEMS
C              MAY OCCASIONALLY SUFFER FROM
C              SEVERE SCALING DIFFICULTIES ON THE
C              FIRST STEP. IF YOU KNOW A GREAT DEAL
C              ABOUT THE SCALING OF YOUR PROBLEM, YOU CAN
C              HELP TO ALLEVIATE THIS PROBLEM BY
C              SPECIFYING AN INITIAL STEPSIZE HO.
C
C          ****  DO YOU WANT THE CODE TO DEFINE
C                ITS OWN INITIAL STEPSIZE?
C                YES - SET INFO(8)=0
C                 NO - SET INFO(8)=1
C                      AND DEFINE HO BY SETTING
C                      RWORK(3)=HO ****
C
C        INFO(9) -- IF STORAGE IS A SEVERE PROBLEM,
C              YOU CAN SAVE SOME LOCATIONS BY
C              RESTRICTING THE MAXIMUM ORDER MAXORD.
C              THE DEFAULT VALUE IS 5. FOR EACH
C              ORDER DECREASE BELOW 5, THE CODE
C              REQUIRES NEQ FEWER LOCATIONS, HOWEVER
C              IT IS LIKELY TO BE SLOWER. IN ANY
C              CASE, YOU MUST HAVE 1 .LE. MAXORD .LE. 5
C          ****  DO YOU WANT THE MAXIMUM ORDER TO
C                DEFAULT TO 5?
C                YES - SET INFO(9)=0
C                 NO - SET INFO(9)=1
C                      AND DEFINE MAXORD BY SETTING
C                      IWORK(3)=MAXORD ****
C
C        INFO(10) --IF YOU KNOW THAT THE SOLUTIONS TO YOUR EQUATIONS
C               WILL ALWAYS BE NONNEGATIVE, IT MAY HELP TO SET THIS
C               PARAMETER. HOWEVER, IT IS PROBABLY BEST TO
C               TRY THE CODE WITHOUT USING THIS OPTION FIRST,
C               AND ONLY TO USE THIS OPTION IF THAT DOESN'T
C               WORK VERY WELL.
C           ****  DO YOU WANT THE CODE TO SOLVE THE PROBLEM WITHOUT
C                 INVOKING ANY SPECIAL NONNEGATIVITY CONSTRAINTS?
C                  YES - SET INFO(10)=0
C                   NO - SET INFO(10)=1
C
C        INFO(11) --DDASSL NORMALLY REQUIRES THE INITIAL T,
C               Y, AND YPRIME TO BE CONSISTENT. THAT IS,
C               YOU MUST HAVE G(T,Y,YPRIME) = 0 AT THE INITIAL
C               TIME. IF YOU DO NOT KNOW THE INITIAL
C               DERIVATIVE PRECISELY, YOU CAN LET DDASSL TRY
C               TO COMPUTE IT.
C          ****   ARE THE INITIAL T, Y, YPRIME CONSISTENT?
C                 YES - SET INFO(11) = 0
C                  NO - SET INFO(11) = 1,
C                       AND SET YPRIME TO AN INITIAL APPROXIMATION
C                       TO YPRIME.  (IF YOU HAVE NO IDEA WHAT
C                       YPRIME SHOULD BE, SET IT TO ZERO. NOTE
C                       THAT THE INITIAL Y SHOULD BE SUCH
C                       THAT THERE MUST EXIST A YPRIME SO THAT
C                       G(T,Y,YPRIME) = 0.)
C
C  RTOL, ATOL -- YOU MUST ASSIGN RELATIVE (RTOL) AND ABSOLUTE (ATOL
C         ERROR TOLERANCES TO TELL THE CODE HOW ACCURATELY YOU
C         WANT THE SOLUTION TO BE COMPUTED.  THEY MUST BE DEFINED
C         AS VARIABLES BECAUSE THE CODE MAY CHANGE THEM.  YOU
C         HAVE TWO CHOICES --
C               BOTH RTOL AND ATOL ARE SCALARS. (INFO(2)=0)
C               BOTH RTOL AND ATOL ARE VECTORS. (INFO(2)=1)
C         IN EITHER CASE ALL COMPONENTS MUST BE NON-NEGATIVE.
C
C         THE TOLERANCES ARE USED BY THE CODE IN A LOCAL ERROR
C         TEST AT EACH STEP WHICH REQUIRES ROUGHLY THAT
C               ABS(LOCAL ERROR) .LE. RTOL*ABS(Y)+ATOL
C         FOR EACH VECTOR COMPONENT.
C         (MORE SPECIFICALLY, A ROOT-MEAN-SQUARE NORM IS USED TO
C         MEASURE THE SIZE OF VECTORS, AND THE ERROR TEST USES THE
C         MAGNITUDE OF THE SOLUTION AT THE BEGINNING OF THE STEP.)
C
C         THE TRUE (GLOBAL) ERROR IS THE DIFFERENCE BETWEEN THE
C         TRUE SOLUTION OF THE INITIAL VALUE PROBLEM AND THE
C         COMPUTED APPROXIMATION.  PRACTICALLY ALL PRESENT DAY
C         CODES, INCLUDING THIS ONE, CONTROL THE LOCAL ERROR AT
C         EACH STEP AND DO NOT EVEN ATTEMPT TO CONTROL THE GLOBAL
C         ERROR DIRECTLY.
C         USUALLY, BUT NOT ALWAYS, THE TRUE ACCURACY OF THE
C         COMPUTED Y IS COMPARABLE TO THE ERROR TOLERANCES. THIS
C         CODE WILL USUALLY, BUT NOT ALWAYS, DELIVER A MORE
C         ACCURATE SOLUTION IF YOU REDUCE THE TOLERANCES AND
C         INTEGRATE AGAIN.  BY COMPARING TWO SUCH SOLUTIONS YOU
C         CAN GET A FAIRLY RELIABLE IDEA OF THE TRUE ERROR IN THE
C         SOLUTION AT THE BIGGER TOLERANCES.
C
C         SETTING ATOL=0. RESULTS IN A PURE RELATIVE ERROR TEST ON
C         THAT COMPONENT.  SETTING RTOL=0. RESULTS IN A PURE
C         ABSOLUTE ERROR TEST ON THAT COMPONENT.  A MIXED TEST
C         WITH NON-ZERO RTOL AND ATOL CORRESPONDS ROUGHLY TO A
C         RELATIVE ERROR TEST WHEN THE SOLUTION COMPONENT IS MUCH
C         BIGGER THAN ATOL AND TO AN ABSOLUTE ERROR TEST WHEN THE
C         SOLUTION COMPONENT IS SMALLER THAN THE THRESHHOLD ATOL.
C
C         THE CODE WILL NOT ATTEMPT TO COMPUTE A SOLUTION AT AN
C         ACCURACY UNREASONABLE FOR THE MACHINE BEING USED.  IT WILL
C         ADVISE YOU IF YOU ASK FOR TOO MUCH ACCURACY AND INFORM
C         YOU AS TO THE MAXIMUM ACCURACY IT BELIEVES POSSIBLE.
C
C  RWORK(*) --  DIMENSION THIS REAL WORK ARRAY OF LENGTH LRW IN YOUR
C         CALLING PROGRAM.
C
C  LRW -- SET IT TO THE DECLARED LENGTH OF THE RWORK ARRAY.
C               YOU MUST HAVE
C                    LRW .GE. 40+(MAXORD+4)*NEQ+NEQ**2
C               FOR THE FULL (DENSE) JACOBIAN CASE (WHEN INFO(6)=0), OR
C                    LRW .GE. 40+(MAXORD+4)*NEQ+(2*ML+MU+1)*NEQ
C               FOR THE BANDED USER-DEFINED JACOBIAN CASE
C               (WHEN INFO(5)=1 AND INFO(6)=1), OR
C                     LRW .GE. 40+(MAXORD+4)*NEQ+(2*ML+MU+1)*NEQ
C                           +2*(NEQ/(ML+MU+1)+1)
C               FOR THE BANDED FINITE-DIFFERENCE-GENERATED JACOBIAN CASE
C               (WHEN INFO(5)=0 AND INFO(6)=1)
C
C  IWORK(*) --  DIMENSION THIS INTEGER WORK ARRAY OF LENGTH LIW IN
C         YOUR CALLING PROGRAM.
C
C  LIW -- SET IT TO THE DECLARED LENGTH OF THE IWORK ARRAY.
C               YOU MUST HAVE LIW .GE. 20+NEQ
C
C  RPAR, IPAR -- THESE ARE PARAMETER ARRAYS, OF REAL AND INTEGER
C         TYPE, RESPECTIVELY.  YOU CAN USE THEM FOR COMMUNICATION
C         BETWEEN YOUR PROGRAM THAT CALLS DDASSL AND THE
C         RES SUBROUTINE (AND THE JAC SUBROUTINE).  THEY ARE NOT
C         ALTERED BY DDASSL.  IF YOU DO NOT NEED RPAR OR IPAR,
C         IGNORE THESE PARAMETERS BY TREATING THEM AS DUMMY
C         ARGUMENTS.  IF YOU DO CHOOSE TO USE THEM, DIMENSION
C         THEM IN YOUR CALLING PROGRAM AND IN RES (AND IN JAC)
C         AS ARRAYS OF APPROPRIATE LENGTH.
C
C  JAC -- IF YOU HAVE SET INFO(5)=0, YOU CAN IGNORE THIS PARAMETER
C         BY TREATING IT AS A DUMMY ARGUMENT.  OTHERWISE, YOU MUST
C         PROVIDE A SUBROUTINE OF THE FORM
C             SUBROUTINE JAC(T,Y,YPRIME,PD,CJ,RPAR,IPAR)
C         TO DEFINE THE MATRIX OF PARTIAL DERIVATIVES
C             PD=DG/DY+CJ*DG/DYPRIME
C         CJ IS A SCALAR WHICH IS INPUT TO JAC.
C         FOR THE GIVEN VALUES OF T,Y,YPRIME, THE
C         SUBROUTINE MUST EVALUATE THE NON-ZERO PARTIAL
C         DERIVATIVES FOR EACH EQUATION AND EACH SOLUTION
C         COMPONENT, AND STORE THESE VALUES IN THE
C         MATRIX PD.  THE ELEMENTS OF PD ARE SET TO ZERO
C         BEFORE EACH CALL TO JAC SO ONLY NON-ZERO ELEMENTS
C         NEED TO BE DEFINED.
C
C         SUBROUTINE JAC MUST NOT ALTER T,Y,(*),YPRIME(*), OR CJ.
C         YOU MUST DECLARE THE NAME JAC IN AN EXTERNAL STATEMENT IN
C         YOUR PROGRAM THAT CALLS DDASSL.  YOU MUST DIMENSION Y,
C         YPRIME AND PD IN JAC.
C
C         THE WAY YOU MUST STORE THE ELEMENTS INTO THE PD MATRIX
C         DEPENDS ON THE STRUCTURE OF THE MATRIX WHICH YOU
C         INDICATED BY INFO(6).
C               *** INFO(6)=0 -- FULL (DENSE) MATRIX ***
C                   GIVE PD A FIRST DIMENSION OF NEQ.
C                   WHEN YOU EVALUATE THE (NON-ZERO) PARTIAL DERIVATIVE
C                   OF EQUATION I WITH RESPECT TO VARIABLE J, YOU MUST
C                   STORE IT IN PD ACCORDING TO
C                   PD(I,J) = "DG(I)/DY(J)+CJ*DG(I)/DYPRIME(J)"
C               *** INFO(6)=1 -- BANDED JACOBIAN WITH ML LOWER AND MU
C                   UPPER DIAGONAL BANDS (REFER TO INFO(6) DESCRIPTION
C                   OF ML AND MU) ***
C                   GIVE PD A FIRST DIMENSION OF 2*ML+MU+1.
C                   WHEN YOU EVALUATE THE (NON-ZERO) PARTIAL DERIVATIVE
C                   OF EQUATION I WITH RESPECT TO VARIABLE J, YOU MUST
C                   STORE IT IN PD ACCORDING TO
C                   IROW = I - J + ML + MU + 1
C                   PD(IROW,J) = "DG(I)/DY(J)+CJ*DG(I)/DYPRIME(J)"
C
C         RPAR AND IPAR ARE REAL AND INTEGER PARAMETER ARRAYS
C         WHICH YOU CAN USE FOR COMMUNICATION BETWEEN YOUR CALLING
C         PROGRAM AND YOUR JACOBIAN SUBROUTINE JAC. THEY ARE NOT
C         ALTERED BY DDASSL. IF YOU DO NOT NEED RPAR OR IPAR,
C         IGNORE THESE PARAMETERS BY TREATING THEM AS DUMMY
C         ARGUMENTS. IF YOU DO CHOOSE TO USE THEM, DIMENSION
C         THEM IN YOUR CALLING PROGRAM AND IN JAC AS ARRAYS OF
C         APPROPRIATE LENGTH.
C
C
C  OPTIONALLY REPLACEABLE NORM ROUTINE:
C
C     DDASSL USES A WEIGHTED NORM DDANRM TO MEASURE THE SIZE
C     OF VECTORS SUCH AS THE ESTIMATED ERROR IN EACH STEP.
C     A FUNCTION SUBPROGRAM
C       DOUBLE PRECISION FUNCTION DDANRM(NEQ,V,WT,RPAR,IPAR)
C       DIMENSION V(NEQ),WT(NEQ)
C     IS USED TO DEFINE THIS NORM. HERE, V IS THE VECTOR
C     WHOSE NORM IS TO BE COMPUTED, AND WT IS A VECTOR OF
C     WEIGHTS.  A DDANRM ROUTINE HAS BEEN INCLUDED WITH DDASSL
C     WHICH COMPUTES THE WEIGHTED ROOT-MEAN-SQUARE NORM
C     GIVEN BY
C       DDANRM=SQRT((1/NEQ)*SUM(V(I)/WT(I))**2)
C     THIS NORM IS SUITABLE FOR MOST PROBLEMS. IN SOME
C     SPECIAL CASES, IT MAY BE MORE CONVENIENT AND/OR
C     EFFICIENT TO DEFINE YOUR OWN NORM BY WRITING A FUNCTION
C     SUBPROGRAM TO BE CALLED INSTEAD OF DDANRM. THIS SHOULD,
C     HOWEVER, BE ATTEMPTED ONLY AFTER CAREFUL THOUGHT AND
C     CONSIDERATION.
C
C
C  -------- OUTPUT -- AFTER ANY RETURN FROM DDASSL ---------------------
C
C  THE PRINCIPAL AIM OF THE CODE IS TO RETURN A COMPUTED SOLUTION AT
C  TOUT, ALTHOUGH IT IS ALSO POSSIBLE TO OBTAIN INTERMEDIATE RESULTS
C  ALONG THE WAY. TO FIND OUT WHETHER THE CODE ACHIEVED ITS GOAL
C  OR IF THE INTEGRATION PROCESS WAS INTERRUPTED BEFORE THE TASK WAS
C  COMPLETED, YOU MUST CHECK THE IDID PARAMETER.
C
C
C  T -- THE SOLUTION WAS SUCCESSFULLY ADVANCED TO THE
C               OUTPUT VALUE OF T.
C
C  Y(*) -- CONTAINS THE COMPUTED SOLUTION APPROXIMATION AT T.
C
C  YPRIME(*) -- CONTAINS THE COMPUTED DERIVATIVE
C               APPROXIMATION AT T.
C
C  IDID -- REPORTS WHAT THE CODE DID.
C
C                     *** TASK COMPLETED ***
C                REPORTED BY POSITIVE VALUES OF IDID
C
C           IDID = 1 -- A STEP WAS SUCCESSFULLY TAKEN IN THE
C                   INTERMEDIATE-OUTPUT MODE. THE CODE HAS NOT
C                   YET REACHED TOUT.
C
C           IDID = 2 -- THE INTEGRATION TO TSTOP WAS SUCCESSFULLY
C                   COMPLETED (T=TSTOP) BY STEPPING EXACTLY TO TSTOP.
C
C           IDID = 3 -- THE INTEGRATION TO TOUT WAS SUCCESSFULLY
C                   COMPLETED (T=TOUT) BY STEPPING PAST TOUT.
C                   Y(*) IS OBTAINED BY INTERPOLATION.
C                   YPRIME(*) IS OBTAINED BY INTERPOLATION.
C
C                    *** TASK INTERRUPTED ***
C                REPORTED BY NEGATIVE VALUES OF IDID
C
C           IDID = -1 -- A LARGE AMOUNT OF WORK HAS BEEN EXPENDED.
C                   (ABOUT 500 STEPS)
C
C           IDID = -2 -- THE ERROR TOLERANCES ARE TOO STRINGENT.
C
C           IDID = -3 -- THE LOCAL ERROR TEST CANNOT BE SATISFIED
C                   BECAUSE YOU SPECIFIED A ZERO COMPONENT IN ATOL
C                   AND THE CORRESPONDING COMPUTED SOLUTION
C                   COMPONENT IS ZERO. THUS, A PURE RELATIVE ERROR
C                   TEST IS IMPOSSIBLE FOR THIS COMPONENT.
C
C           IDID = -6 -- DDASSL HAD REPEATED ERROR TEST
C                   FAILURES ON THE LAST ATTEMPTED STEP.
C
C           IDID = -7 -- THE CORRECTOR COULD NOT CONVERGE.
C
C           IDID = -8 -- THE MATRIX OF PARTIAL DERIVATIVES
C                   IS SINGULAR.
C
C           IDID = -9 -- THE CORRECTOR COULD NOT CONVERGE.
C                   THERE WERE REPEATED ERROR TEST FAILURES
C                   IN THIS STEP.
C
C           IDID =-10 -- THE CORRECTOR COULD NOT CONVERGE
C                   BECAUSE IRES WAS EQUAL TO MINUS ONE.
C
C           IDID =-11 -- IRES EQUAL TO -2 WAS ENCOUNTERED
C                   AND CONTROL IS BEING RETURNED TO THE
C                   CALLING PROGRAM.
C
C           IDID =-12 -- DDASSL FAILED TO COMPUTE THE INITIAL
C                   YPRIME.
C
C
C
C           IDID = -13,..,-32 -- NOT APPLICABLE FOR THIS CODE
C
C                    *** TASK TERMINATED ***
C                REPORTED BY THE VALUE OF IDID=-33
C
C           IDID = -33 -- THE CODE HAS ENCOUNTERED TROUBLE FROM WHICH
C                   IT CANNOT RECOVER. A MESSAGE IS PRINTED
C                   EXPLAINING THE TROUBLE AND CONTROL IS RETURNED
C                   TO THE CALLING PROGRAM. FOR EXAMPLE, THIS OCCURS
C                   WHEN INVALID INPUT IS DETECTED.
C
C  RTOL, ATOL -- THESE QUANTITIES REMAIN UNCHANGED EXCEPT WHEN
C               IDID = -2. IN THIS CASE, THE ERROR TOLERANCES HAVE BEEN
C               INCREASED BY THE CODE TO VALUES WHICH ARE ESTIMATED TO
C               BE APPROPRIATE FOR CONTINUING THE INTEGRATION. HOWEVER,
C               THE REPORTED SOLUTION AT T WAS OBTAINED USING THE INPUT
C               VALUES OF RTOL AND ATOL.
C
C  RWORK, IWORK -- CONTAIN INFORMATION WHICH IS USUALLY OF NO
C               INTEREST TO THE USER BUT NECESSARY FOR SUBSEQUENT CALLS.
C               HOWEVER, YOU MAY FIND USE FOR
C
C               RWORK(3)--WHICH CONTAINS THE STEP SIZE H TO BE
C                       ATTEMPTED ON THE NEXT STEP.
C
C               RWORK(4)--WHICH CONTAINS THE CURRENT VALUE OF THE
C                       INDEPENDENT VARIABLE, I.E., THE FARTHEST POINT
C                       INTEGRATION HAS REACHED. THIS WILL BE DIFFERENT
C                       FROM T ONLY WHEN INTERPOLATION HAS BEEN
C                       PERFORMED (IDID=3).
C
C               RWORK(7)--WHICH CONTAINS THE STEPSIZE USED
C                       ON THE LAST SUCCESSFUL STEP.
C
C               IWORK(7)--WHICH CONTAINS THE ORDER OF THE METHOD TO
C                       BE ATTEMPTED ON THE NEXT STEP.
C
C               IWORK(8)--WHICH CONTAINS THE ORDER OF THE METHOD USED
C                       ON THE LAST STEP.
C
C               IWORK(11)--WHICH CONTAINS THE NUMBER OF STEPS TAKEN SO
C                        FAR.
C
C               IWORK(12)--WHICH CONTAINS THE NUMBER OF CALLS TO RES
C                        SO FAR.
C
C               IWORK(13)--WHICH CONTAINS THE NUMBER OF EVALUATIONS OF
C                        THE MATRIX OF PARTIAL DERIVATIVES NEEDED SO
C                        FAR.
C
C               IWORK(14)--WHICH CONTAINS THE TOTAL NUMBER
C                        OF ERROR TEST FAILURES SO FAR.
C
C               IWORK(15)--WHICH CONTAINS THE TOTAL NUMBER
C                        OF CONVERGENCE TEST FAILURES SO FAR.
C                        (INCLUDES SINGULAR ITERATION MATRIX
C                        FAILURES.)
C
C
C  -------- INPUT -- WHAT TO DO TO CONTINUE THE INTEGRATION ------------
C                    (CALLS AFTER THE FIRST)
C
C  THIS CODE IS ORGANIZED SO THAT SUBSEQUENT CALLS TO CONTINUE THE
C  INTEGRATION INVOLVE LITTLE (IF ANY) ADDITIONAL EFFORT ON YOUR
C  PART. YOU MUST MONITOR THE IDID PARAMETER IN ORDER TO DETERMINE
C  WHAT TO DO NEXT.
C
C  RECALLING THAT THE PRINCIPAL TASK OF THE CODE IS TO INTEGRATE
C  FROM T TO TOUT (THE INTERVAL MODE), USUALLY ALL YOU WILL NEED
C  TO DO IS SPECIFY A NEW TOUT UPON REACHING THE CURRENT TOUT.
C
C  DO NOT ALTER ANY QUANTITY NOT SPECIFICALLY PERMITTED BELOW,
C  IN PARTICULAR DO NOT ALTER NEQ,T,Y(*),YPRIME(*),RWORK(*),IWORK(*)
C  OR THE DIFFERENTIAL EQUATION IN SUBROUTINE RES. ANY SUCH
C  ALTERATION CONSTITUTES A NEW PROBLEM AND MUST BE TREATED AS SUCH,
C  I.E., YOU MUST START AFRESH.
C
C  YOU CANNOT CHANGE FROM VECTOR TO SCALAR ERROR CONTROL OR VICE
C  VERSA (INFO(2)), BUT YOU CAN CHANGE THE SIZE OF THE ENTRIES OF
C  RTOL, ATOL. INCREASING A TOLERANCE MAKES THE EQUATION EASIER
C  TO INTEGRATE. DECREASING A TOLERANCE WILL MAKE THE EQUATION
C  HARDER TO INTEGRATE AND SHOULD GENERALLY BE AVOIDED.
C
C  YOU CAN SWITCH FROM THE INTERMEDIATE-OUTPUT MODE TO THE
C  INTERVAL MODE (INFO(3)) OR VICE VERSA AT ANY TIME.
C
C  IF IT HAS BEEN NECESSARY TO PREVENT THE INTEGRATION FROM GOING
C  PAST A POINT TSTOP (INFO(4), RWORK(1)), KEEP IN MIND THAT THE
C  CODE WILL NOT INTEGRATE TO ANY TOUT BEYOND THE CURRENTLY
C  SPECIFIED TSTOP. ONCE TSTOP HAS BEEN REACHED YOU MUST CHANGE
C  THE VALUE OF TSTOP OR SET INFO(4)=0. YOU MAY CHANGE INFO(4)
C  OR TSTOP AT ANY TIME BUT YOU MUST SUPPLY THE VALUE OF TSTOP IN
C  RWORK(1) WHENEVER YOU SET INFO(4)=1.
C
C  DO NOT CHANGE INFO(5), INFO(6), IWORK(1), OR IWORK(2)
C  UNLESS YOU ARE GOING TO RESTART THE CODE.
C
C                 *** FOLLOWING A COMPLETED TASK ***
C  IF
C     IDID = 1, CALL THE CODE AGAIN TO CONTINUE THE INTEGRATION
C                  ANOTHER STEP IN THE DIRECTION OF TOUT.
C
C     IDID = 2 OR 3, DEFINE A NEW TOUT AND CALL THE CODE AGAIN.
C                  TOUT MUST BE DIFFERENT FROM T. YOU CANNOT CHANGE
C                  THE DIRECTION OF INTEGRATION WITHOUT RESTARTING.
C
C                 *** FOLLOWING AN INTERRUPTED TASK ***
C               TO SHOW THE CODE THAT YOU REALIZE THE TASK WAS
C               INTERRUPTED AND THAT YOU WANT TO CONTINUE, YOU
C               MUST TAKE APPROPRIATE ACTION AND SET INFO(1) = 1
C  IF
C    IDID = -1, THE CODE HAS TAKEN ABOUT 500 STEPS.
C                  IF YOU WANT TO CONTINUE, SET INFO(1) = 1 AND
C                  CALL THE CODE AGAIN. AN ADDITIONAL 500 STEPS
C                  WILL BE ALLOWED.
C
C    IDID = -2, THE ERROR TOLERANCES RTOL, ATOL HAVE BEEN
C                  INCREASED TO VALUES THE CODE ESTIMATES APPROPRIATE
C                  FOR CONTINUING. YOU MAY WANT TO CHANGE THEM
C                  YOURSELF. IF YOU ARE SURE YOU WANT TO CONTINUE
C                  WITH RELAXED ERROR TOLERANCES, SET INFO(1)=1 AND
C                  CALL THE CODE AGAIN.
C
C    IDID = -3, A SOLUTION COMPONENT IS ZERO AND YOU SET THE
C                  CORRESPONDING COMPONENT OF ATOL TO ZERO. IF YOU
C                  ARE SURE YOU WANT TO CONTINUE, YOU MUST FIRST
C                  ALTER THE ERROR CRITERION TO USE POSITIVE VALUES
C                  FOR THOSE COMPONENTS OF ATOL CORRESPONDING TO ZERO
C                  SOLUTION COMPONENTS, THEN SET INFO(1)=1 AND CALL
C                  THE CODE AGAIN.
C
C    IDID = -4,-5  --- CANNOT OCCUR WITH THIS CODE.
C
C    IDID = -6, REPEATED ERROR TEST FAILURES OCCURRED ON THE
C                  LAST ATTEMPTED STEP IN DDASSL. A SINGULARITY IN THE
C                  SOLUTION MAY BE PRESENT. IF YOU ARE ABSOLUTELY
C                  CERTAIN YOU WANT TO CONTINUE, YOU SHOULD RESTART
C                  THE INTEGRATION. (PROVIDE INITIAL VALUES OF Y AND
C                  YPRIME WHICH ARE CONSISTENT)
C
C    IDID = -7, REPEATED CONVERGENCE TEST FAILURES OCCURRED
C                  ON THE LAST ATTEMPTED STEP IN DDASSL. AN INACCURATE
C                  OR ILL-CONDITIONED JACOBIAN MAY BE THE PROBLEM. IF
C                  YOU ARE ABSOLUTELY CERTAIN YOU WANT TO CONTINUE, YOU
C                  SHOULD RESTART THE INTEGRATION.
C
C    IDID = -8, THE MATRIX OF PARTIAL DERIVATIVES IS SINGULAR.
C                  SOME OF YOUR EQUATIONS MAY BE REDUNDANT.
C                  DDASSL CANNOT SOLVE THE PROBLEM AS STATED.
C                  IT IS POSSIBLE THAT THE REDUNDANT EQUATIONS
C                  COULD BE REMOVED, AND THEN DDASSL COULD
C                  SOLVE THE PROBLEM. IT IS ALSO POSSIBLE
C                  THAT A SOLUTION TO YOUR PROBLEM EITHER
C                  DOES NOT EXIST OR IS NOT UNIQUE.
C
C    IDID = -9, DDASSL HAD MULTIPLE CONVERGENCE TEST
C                  FAILURES, PRECEDED BY MULTIPLE ERROR
C                  TEST FAILURES, ON THE LAST ATTEMPTED STEP.
C                  IT IS POSSIBLE THAT YOUR PROBLEM
C                  IS ILL-POSED, AND CANNOT BE SOLVED
C                  USING THIS CODE. OR, THERE MAY BE A
C                  DISCONTINUITY OR A SINGULARITY IN THE
C                  SOLUTION. IF YOU ARE ABSOLUTELY CERTAIN
C                  YOU WANT TO CONTINUE, YOU SHOULD RESTART
C                  THE INTEGRATION.
C
C    IDID =-10, DDASSL HAD MULTIPLE CONVERGENCE TEST FAILURES
C                  BECAUSE IRES WAS EQUAL TO MINUS ONE.
C                  IF YOU ARE ABSOLUTELY CERTAIN YOU WANT
C                  TO CONTINUE, YOU SHOULD RESTART THE
C                  INTEGRATION.
C
C    IDID =-11, IRES=-2 WAS ENCOUNTERED, AND CONTROL IS BEING
C                  RETURNED TO THE CALLING PROGRAM.
C
C    IDID =-12, DDASSL FAILED TO COMPUTE THE INITIAL YPRIME.
C                  THIS COULD HAPPEN BECAUSE THE INITIAL
C                  APPROXIMATION TO YPRIME WAS NOT VERY GOOD, OR
C                  IF A YPRIME CONSISTENT WITH THE INITIAL Y
C                  DOES NOT EXIST. THE PROBLEM COULD ALSO BE CAUSED
C                  BY AN INACCURATE OR SINGULAR ITERATION MATRIX.
C
C    IDID = -13,..,-32  --- CANNOT OCCUR WITH THIS CODE.
C
C
C                 *** FOLLOWING A TERMINATED TASK ***
C
C  IF IDID= -33, YOU CANNOT CONTINUE THE SOLUTION OF THIS PROBLEM.
C                  AN ATTEMPT TO DO SO WILL RESULT IN YOUR
C                  RUN BEING TERMINATED.
C
C
C  -------- ERROR MESSAGES ---------------------------------------------
C
C      THE SLATEC ERROR PRINT ROUTINE XERMSG IS CALLED IN THE EVENT OF
C   UNSUCCESSFUL COMPLETION OF A TASK.  MOST OF THESE ARE TREATED AS
C   "RECOVERABLE ERRORS", WHICH MEANS THAT (UNLESS THE USER HAS DIRECTED
C   OTHERWISE) CONTROL WILL BE RETURNED TO THE CALLING PROGRAM FOR
C   POSSIBLE ACTION AFTER THE MESSAGE HAS BEEN PRINTED.
C
C   IN THE EVENT OF A NEGATIVE VALUE OF IDID OTHER THAN -33, AN APPRO-
C   PRIATE MESSAGE IS PRINTED AND THE "ERROR NUMBER" PRINTED BY XERMSG
C   IS THE VALUE OF IDID.  THERE ARE QUITE A NUMBER OF ILLEGAL INPUT
C   ERRORS THAT CAN LEAD TO A RETURNED VALUE IDID=-33.  THE CONDITIONS
C   AND THEIR PRINTED "ERROR NUMBERS" ARE AS FOLLOWS:
C
C   ERROR NUMBER       CONDITION
C
C        1       SOME ELEMENT OF INFO VECTOR IS NOT ZERO OR ONE.
C        2       NEQ .LE. 0
C        3       MAXORD NOT IN RANGE.
C        4       LRW IS LESS THAN THE REQUIRED LENGTH FOR RWORK.
C        5       LIW IS LESS THAN THE REQUIRED LENGTH FOR IWORK.
C        6       SOME ELEMENT OF RTOL IS .LT. 0
C        7       SOME ELEMENT OF ATOL IS .LT. 0
C        8       ALL ELEMENTS OF RTOL AND ATOL ARE ZERO.
C        9       INFO(4)=1 AND TSTOP IS BEHIND TOUT.
C       10       HMAX .LT. 0.0
C       11       TOUT IS BEHIND T.
C       12       INFO(8)=1 AND H0=0.0
C       13       SOME ELEMENT OF WT IS .LE. 0.0
C       14       TOUT IS TOO CLOSE TO T TO START INTEGRATION.
C       15       INFO(4)=1 AND TSTOP IS BEHIND T.
C       16       --( NOT USED IN THIS VERSION )--
C       17       ML ILLEGAL.  EITHER .LT. 0 OR .GT. NEQ
C       18       MU ILLEGAL.  EITHER .LT. 0 OR .GT. NEQ
C       19       TOUT = T.
C
C   IF DDASSL IS CALLED AGAIN WITHOUT ANY ACTION TAKEN TO REMOVE THE
C   CAUSE OF AN UNSUCCESSFUL RETURN, XERMSG WILL BE CALLED WITH A FATAL
C   ERROR FLAG, WHICH WILL CAUSE UNCONDITIONAL TERMINATION OF THE
C   PROGRAM.  THERE ARE TWO SUCH FATAL ERRORS:
C
C   ERROR NUMBER -998:  THE LAST STEP WAS TERMINATED WITH A NEGATIVE
C       VALUE OF IDID OTHER THAN -33, AND NO APPROPRIATE ACTION WAS
C       TAKEN.
C
C   ERROR NUMBER -999:  THE PREVIOUS CALL WAS TERMINATED BECAUSE OF
C       ILLEGAL INPUT (IDID=-33) AND THERE IS ILLEGAL INPUT IN THE
C       PRESENT CALL, AS WELL.  (SUSPECT INFINITE LOOP.)
C
C  ---------------------------------------------------------------------
C
C***REFERENCES  A DESCRIPTION OF DASSL: A DIFFERENTIAL/ALGEBRAIC
C                 SYSTEM SOLVER, L. R. PETZOLD, SAND82-8637,
C                 SANDIA NATIONAL LABORATORIES, SEPTEMBER 1982.
C***ROUTINES CALLED  D1MACH, DDAINI, DDANRM, DDASTP, DDATRP, DDAWTS,
C                    XERMSG
C***REVISION HISTORY  (YYMMDD)
C   830315  DATE WRITTEN
C   880387  CODE CHANGES MADE.  ALL COMMON STATEMENTS HAVE BEEN
C           REPLACED BY A DATA STATEMENT, WHICH DEFINES POINTERS INTO
C           RWORK, AND PARAMETER STATEMENTS WHICH DEFINE POINTERS
C           INTO IWORK.  AS WELL THE DOCUMENTATION HAS GONE THROUGH
C           GRAMMATICAL CHANGES.
C   881005  THE PROLOGUE HAS BEEN CHANGED TO MIXED CASE.
C           THE SUBORDINATE ROUTINES HAD REVISION DATES CHANGED TO
C           THIS DATE, ALTHOUGH THE DOCUMENTATION FOR THESE ROUTINES
C           IS ALL UPPER CASE.  NO CODE CHANGES.
C   890511  CODE CHANGES MADE.  THE DATA STATEMENT IN THE DECLARATION
C           SECTION OF DDASSL WAS REPLACED WITH A PARAMETER
C           STATEMENT.  ALSO THE STATEMENT S = 100.D0 WAS REMOVED
C           FROM THE TOP OF THE NEWTON ITERATION IN DDASTP.
C           THE SUBORDINATE ROUTINES HAD REVISION DATES CHANGED TO
C           THIS DATE.
C   890517  THE REVISION DATE SYNTAX WAS REPLACED WITH THE REVISION
C           HISTORY SYNTAX.  ALSO THE "DECK" COMMENT WAS ADDED TO
C           THE TOP OF ALL SUBROUTINES.  THESE CHANGES ARE CONSISTENT
C           WITH NEW SLATEC GUIDELINES.
C           THE SUBORDINATE ROUTINES HAD REVISION DATES CHANGED TO
C           THIS DATE.  NO CODE CHANGES.
C   891013  CODE CHANGES MADE.
C           REMOVED ALL OCCURRENCES OF FLOAT OR DBLE.  ALL OPERATIONS
C           ARE NOW PERFORMED WITH "MIXED-MODE" ARITHMETIC.
C           ALSO, SPECIFIC FUNCTION NAMES WERE REPLACED WITH GENERIC
C           FUNCTION NAMES TO BE CONSISTENT WITH NEW SLATEC GUIDELINES.
C           IN PARTICULAR:
C              REPLACED DSQRT WITH SQRT EVERYWHERE.
C              REPLACED DABS WITH ABS EVERYWHERE.
C              REPLACED DMIN1 WITH MIN EVERYWHERE.
C              REPLACED MIN0 WITH MIN EVERYWHERE.
C              REPLACED DMAX1 WITH MAX EVERYWHERE.
C              REPLACED MAX0 WITH MAX EVERYWHERE.
C              REPLACED DSIGN WITH SIGN EVERYWHERE.
C           ALSO REPLACED REVISION DATE WITH REVISION HISTORY IN ALL
C           SUBORDINATE ROUTINES.
C   901004  MISCELLANEOUS CHANGES TO PROLOGUE TO COMPLETE CONVERSION
C           TO SLATEC 4.0 FORMAT.  NO CODE CHANGES.  (F.N.FRITSCH)
C   901009  CORRECTED GAMS CLASSIFICATION CODE AND CONVERTED SUBSIDIARY
C           ROUTINES TO 4.0 FORMAT.  NO CODE CHANGES.  (F.N.FRITSCH)
C   901010  CONVERTED XERRWV CALLS TO XERMSG CALLS.  (R.CLEMENS, AFWL)
C   901019  CODE CHANGES MADE.
C           MERGED SLATEC 4.0 CHANGES WITH PREVIOUS CHANGES MADE
C           BY C. ULRICH.  BELOW IS A HISTORY OF THE CHANGES MADE BY
C           C. ULRICH. (CHANGES IN SUBSIDIARY ROUTINES ARE IMPLIED
C           BY THIS HISTORY)
C           891228  BUG WAS FOUND AND REPAIRED INSIDE THE DDASSL
C                   AND DDAINI ROUTINES.  DDAINI WAS INCORRECTLY
C                   RETURNING THE INITIAL T WITH Y AND YPRIME
C                   COMPUTED AT T+H.  THE ROUTINE NOW RETURNS T+H
C                   RATHER THAN THE INITIAL T.
C                   COSMETIC CHANGES MADE TO DDASTP.
C           900904  THREE MODIFICATIONS WERE MADE TO FIX A BUG (INSIDE
C                   DDASSL) RE INTERPOLATION FOR CONTINUATION CALLS AND
C                   CASES WHERE TN IS VERY CLOSE TO TSTOP:
C
C                   1) IN TESTING FOR WHETHER H IS TOO LARGE, JUST
C                      COMPARE H TO (TSTOP - TN), RATHER THAN
C                      (TSTOP - TN) * (1-4*UROUND), AND SET H TO
C                      TSTOP - TN.  THIS WILL FORCE DDASTP TO STEP
C                      EXACTLY TO TSTOP UNDER CERTAIN SITUATIONS
C                      (I.E. WHEN H RETURNED FROM DDASTP WOULD OTHERWISE
C                      TAKE TN BEYOND TSTOP).
C
C                   2) INSIDE THE DDASTP LOOP, INTERPOLATE EXACTLY TO
C                      TSTOP IF TN IS VERY CLOSE TO TSTOP (RATHER THAN
C                      INTERPOLATING TO WITHIN ROUNDOFF OF TSTOP).
C
C                   3) MODIFIED IDID DESCRIPTION FOR IDID = 2 TO SAY
C                      THAT THE SOLUTION IS RETURNED BY STEPPING EXACTLY
C                      TO TSTOP, RATHER THAN TOUT.  (IN SOME CASES THE
C                      SOLUTION IS ACTUALLY OBTAINED BY EXTRAPOLATING
C                      OVER A DISTANCE NEAR UNIT ROUNDOFF TO TSTOP,
C                      BUT THIS SMALL DISTANCE IS DEEMED ACCEPTABLE IN
C                      THESE CIRCUMSTANCES.)
C   901026  ADDED EXPLICIT DECLARATIONS FOR ALL VARIABLES AND MINOR
C           COSMETIC CHANGES TO PROLOGUE, REMOVED UNREFERENCED LABELS,
C           AND IMPROVED XERMSG CALLS.  (FNF)
C   901030  ADDED ERROR MESSAGES SECTION AND REWORKED OTHER SECTIONS TO
C           BE OF MORE UNIFORM FORMAT.  (FNF)
C   910624  FIXED MINOR BUG RELATED TO HMAX (SIX LINES AFTER LABEL
C           525).  (LRP)
C***END PROLOGUE  DDASSL
C
C**END
C
C     DECLARE ARGUMENTS.
C
      INTEGER  NEQ, INFO(15), IDID, LRW, IWORK(*), LIW, IPAR(*)
      DOUBLE PRECISION
     *   T, Y(*), YPRIME(*), TOUT, RTOL(*), ATOL(*), RWORK(*),
     *   RPAR(*)
      EXTERNAL  RES, JAC
C
C     DECLARE EXTERNALS.
C
      EXTERNAL  D1MACH, DDAINI, DDANRM, DDASTP, DDATRP, DDAWTS, XERMSG
      DOUBLE PRECISION  D1MACH, DDANRM
C
C     DECLARE LOCAL VARIABLES.
C
      INTEGER  I, ITEMP, LALPHA, LBETA, LCJ, LCJOLD, LCTF, LDELTA,
     *   LENIW, LENPD, LENRW, LE, LETF, LGAMMA, LH, LHMAX, LHOLD, LIPVT,
     *   LJCALC, LK, LKOLD, LIWM, LML, LMTYPE, LMU, LMXORD, LNJE, LNPD,
     *   LNRE, LNS, LNST, LNSTL, LPD, LPHASE, LPHI, LPSI, LROUND, LS,
     *   LSIGMA, LTN, LTSTOP, LWM, LWT, MBAND, MSAVE, MXORD, NPD, NTEMP,
     *   NZFLG
      DOUBLE PRECISION
     *   ATOLI, H, HMAX, HMIN, HO, R, RH, RTOLI, TDIST, TN, TNEXT,
     *   TSTOP, UROUND, YPNORM
      LOGICAL  DONE
C       AUXILIARY VARIABLES FOR CONVERSION OF VALUES TO BE INCLUDED IN
C       ERROR MESSAGES.
      CHARACTER*8  XERN1, XERN2
      CHARACTER*16 XERN3, XERN4
C
C     SET POINTERS INTO IWORK
      PARAMETER (LML=1, LMU=2, LMXORD=3, LMTYPE=4, LNST=11,
     *  LNRE=12, LNJE=13, LETF=14, LCTF=15, LNPD=16,
     *  LIPVT=21, LJCALC=5, LPHASE=6, LK=7, LKOLD=8,
     *  LNS=9, LNSTL=10, LIWM=1)
C
C     SET RELATIVE OFFSET INTO RWORK
      PARAMETER (NPD=1)
C
C     SET POINTERS INTO RWORK
      PARAMETER (LTSTOP=1, LHMAX=2, LH=3, LTN=4,
     *  LCJ=5, LCJOLD=6, LHOLD=7, LS=8, LROUND=9,
     *  LALPHA=11, LBETA=17, LGAMMA=23,
     *  LPSI=29, LSIGMA=35, LDELTA=41)
C
C***FIRST EXECUTABLE STATEMENT  DDASSL
      IF(INFO(1).NE.0)GO TO 100
C
C-----------------------------------------------------------------------
C     THIS BLOCK IS EXECUTED FOR THE INITIAL CALL ONLY.
C     IT CONTAINS CHECKING OF INPUTS AND INITIALIZATIONS.
C-----------------------------------------------------------------------
C
C     FIRST CHECK INFO ARRAY TO MAKE SURE ALL ELEMENTS OF INFO
C     ARE EITHER ZERO OR ONE.
      DO 10 I=2,11
         IF(INFO(I).NE.0.AND.INFO(I).NE.1)GO TO 701
10       CONTINUE
C
      IF(NEQ.LE.0)GO TO 702
C
C     CHECK AND COMPUTE MAXIMUM ORDER
      MXORD=5
      IF(INFO(9).EQ.0)GO TO 20
         MXORD=IWORK(LMXORD)
         IF(MXORD.LT.1.OR.MXORD.GT.5)GO TO 703
20       IWORK(LMXORD)=MXORD
C
C     COMPUTE MTYPE,LENPD,LENRW.CHECK ML AND MU.
      IF(INFO(6).NE.0)GO TO 40
         LENPD=NEQ**2
         LENRW=40+(IWORK(LMXORD)+4)*NEQ+LENPD
         IF(INFO(5).NE.0)GO TO 30
            IWORK(LMTYPE)=2
            GO TO 60
30          IWORK(LMTYPE)=1
            GO TO 60
40    IF(IWORK(LML).LT.0.OR.IWORK(LML).GE.NEQ)GO TO 717
      IF(IWORK(LMU).LT.0.OR.IWORK(LMU).GE.NEQ)GO TO 718
      LENPD=(2*IWORK(LML)+IWORK(LMU)+1)*NEQ
      IF(INFO(5).NE.0)GO TO 50
         IWORK(LMTYPE)=5
         MBAND=IWORK(LML)+IWORK(LMU)+1
         MSAVE=(NEQ/MBAND)+1
         LENRW=40+(IWORK(LMXORD)+4)*NEQ+LENPD+2*MSAVE
         GO TO 60
50       IWORK(LMTYPE)=4
         LENRW=40+(IWORK(LMXORD)+4)*NEQ+LENPD
C
C     CHECK LENGTHS OF RWORK AND IWORK
60    LENIW=20+NEQ
      IWORK(LNPD)=LENPD
      IF(LRW.LT.LENRW)GO TO 704
      IF(LIW.LT.LENIW)GO TO 705
C
C     CHECK TO SEE THAT TOUT IS DIFFERENT FROM T
      IF(TOUT .EQ. T)GO TO 719
C
C     CHECK HMAX
      IF(INFO(7).EQ.0)GO TO 70
         HMAX=RWORK(LHMAX)
         IF(HMAX.LE.0.0D0)GO TO 710
70    CONTINUE
C
C     INITIALIZE COUNTERS
      IWORK(LNST)=0
      IWORK(LNRE)=0
      IWORK(LNJE)=0
C
      IWORK(LNSTL)=0
      IDID=1
      GO TO 200
C
C-----------------------------------------------------------------------
C     THIS BLOCK IS FOR CONTINUATION CALLS
C     ONLY. HERE WE CHECK INFO(1), AND IF THE
C     LAST STEP WAS INTERRUPTED WE CHECK WHETHER
C     APPROPRIATE ACTION WAS TAKEN.
C-----------------------------------------------------------------------
C
100   CONTINUE
      IF(INFO(1).EQ.1)GO TO 110
      IF(INFO(1).NE.-1)GO TO 701
C
C     IF WE ARE HERE, THE LAST STEP WAS INTERRUPTED
C     BY AN ERROR CONDITION FROM DDASTP, AND
C     APPROPRIATE ACTION WAS NOT TAKEN. THIS
C     IS A FATAL ERROR.
      WRITE(XERN1, '(I8)') IDID
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'THE LAST STEP TERMINATED WITH A NEGATIVE VALUE OF IDID = ' //
     *   XERN1 // ' AND NO APPROPRIATE ACTION WAS TAKEN.  ' //
     *   'RUN TERMINATED', -998, 2)
      RETURN
110   CONTINUE
      IWORK(LNSTL)=IWORK(LNST)
C
C-----------------------------------------------------------------------
C     THIS BLOCK IS EXECUTED ON ALL CALLS.
C     THE ERROR TOLERANCE PARAMETERS ARE
C     CHECKED, AND THE WORK ARRAY POINTERS
C     ARE SET.
C-----------------------------------------------------------------------
C
200   CONTINUE
C     CHECK RTOL,ATOL
      NZFLG=0
      RTOLI=RTOL(1)
      ATOLI=ATOL(1)
      DO 210 I=1,NEQ
         IF(INFO(2).EQ.1)RTOLI=RTOL(I)
         IF(INFO(2).EQ.1)ATOLI=ATOL(I)
         IF(RTOLI.GT.0.0D0.OR.ATOLI.GT.0.0D0)NZFLG=1
         IF(RTOLI.LT.0.0D0)GO TO 706
         IF(ATOLI.LT.0.0D0)GO TO 707
210      CONTINUE
      IF(NZFLG.EQ.0)GO TO 708
C
C     SET UP RWORK STORAGE.IWORK STORAGE IS FIXED
C     IN DATA STATEMENT.
      LE=LDELTA+NEQ
      LWT=LE+NEQ
      LPHI=LWT+NEQ
      LPD=LPHI+(IWORK(LMXORD)+1)*NEQ
      LWM=LPD
      NTEMP=NPD+IWORK(LNPD)
      IF(INFO(1).EQ.1)GO TO 400
C
C-----------------------------------------------------------------------
C     THIS BLOCK IS EXECUTED ON THE INITIAL CALL
C     ONLY. SET THE INITIAL STEP SIZE, AND
C     THE ERROR WEIGHT VECTOR, AND PHI.
C     COMPUTE INITIAL YPRIME, IF NECESSARY.
C-----------------------------------------------------------------------
C
      TN=T
      IDID=1
C
C     SET ERROR WEIGHT VECTOR WT
      CALL DDAWTS(NEQ,INFO(2),RTOL,ATOL,Y,RWORK(LWT),RPAR,IPAR)
      DO 305 I = 1,NEQ
         IF(RWORK(LWT+I-1).LE.0.0D0) GO TO 713
305      CONTINUE
C
C======== TO OUTPUT THE VALUE TO SCREEN, RENDY ======
C_RPC       WRITE(6,*) '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$'
C_RPC       WRITE(6,*) 'D1MACH(1)= ',D1MACH(1)
C_RPC       WRITE(6,*) 'D1MACH(2)= ',D1MACH(2)
C_RPC       WRITE(6,*) 'D1MACH(3)= ',D1MACH(3)
C_RPC       WRITE(6,*) 'D1MACH(4)= ',D1MACH(4)
C_RPC       WRITE(6,*) 'D1MACH(5)= ',D1MACH(5)
C_RPC       WRITE(6,*) '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$'
C=====================================================
C     COMPUTE UNIT ROUNDOFF AND HMIN
      UROUND = D1MACH(4)
      RWORK(LROUND) = UROUND
      HMIN = 4.0D0*UROUND*MAX(ABS(T),ABS(TOUT))
C
C     CHECK INITIAL INTERVAL TO SEE THAT IT IS LONG ENOUGH
      TDIST = ABS(TOUT - T)
      IF(TDIST .LT. HMIN) GO TO 714
C
C     CHECK HO, IF THIS WAS INPUT
      IF(INFO(8) .EQ. 0) GO TO 310
         HO = RWORK(LH)
         IF((TOUT - T)*HO .LT. 0.0D0) GO TO 711
         IF(HO .EQ. 0.0D0) GO TO 712
         GO TO 320
310    CONTINUE
C
C     COMPUTE INITIAL STEPSIZE, TO BE USED BY EITHER
C     DDASTP OR DDAINI, DEPENDING ON INFO(11)
      HO = 0.001D0*TDIST
      YPNORM = DDANRM(NEQ,YPRIME,RWORK(LWT),RPAR,IPAR)
      IF(YPNORM .GT. 0.5D0/HO) HO = 0.5D0/YPNORM
      HO = SIGN(HO,TOUT-T)
C     ADJUST HO IF NECESSARY TO MEET HMAX BOUND
320   IF(INFO(7) .EQ. 0) GO TO 330
         RH = ABS(HO)/RWORK(LHMAX)
         IF(RH .GT. 1.0D0) HO = HO/RH
C     COMPUTE TSTOP, IF APPLICABLE
330   IF(INFO(4) .EQ. 0) GO TO 340
         TSTOP = RWORK(LTSTOP)
         IF((TSTOP - T)*HO .LT. 0.0D0) GO TO 715
         IF((T + HO - TSTOP)*HO .GT. 0.0D0) HO = TSTOP - T
         IF((TSTOP - TOUT)*HO .LT. 0.0D0) GO TO 709
C
C     COMPUTE INITIAL DERIVATIVE, UPDATING TN AND Y, IF APPLICABLE
340   IF(INFO(11) .EQ. 0) GO TO 350
      CALL DDAINI(TN,Y,YPRIME,NEQ,
     *  RES,JAC,HO,RWORK(LWT),IDID,RPAR,IPAR,
     *  RWORK(LPHI),RWORK(LDELTA),RWORK(LE),
     *  RWORK(LWM),IWORK(LIWM),HMIN,RWORK(LROUND),
     *  INFO(10),NTEMP)
      IF(IDID .LT. 0) GO TO 390
C
C     LOAD H WITH HO.  STORE H IN RWORK(LH)
350   H = HO
      RWORK(LH) = H
C
C     LOAD Y AND H*YPRIME INTO PHI(*,1) AND PHI(*,2)
      ITEMP = LPHI + NEQ
      DO 370 I = 1,NEQ
         RWORK(LPHI + I - 1) = Y(I)
370      RWORK(ITEMP + I - 1) = H*YPRIME(I)
C
390   GO TO 500
C
C-------------------------------------------------------
C     THIS BLOCK IS FOR CONTINUATION CALLS ONLY. ITS
C     PURPOSE IS TO CHECK STOP CONDITIONS BEFORE
C     TAKING A STEP.
C     ADJUST H IF NECESSARY TO MEET HMAX BOUND
C-------------------------------------------------------
C
400   CONTINUE
      UROUND=RWORK(LROUND)
      DONE = .FALSE.
      TN=RWORK(LTN)
      H=RWORK(LH)
      IF(INFO(7) .EQ. 0) GO TO 410
         RH = ABS(H)/RWORK(LHMAX)
         IF(RH .GT. 1.0D0) H = H/RH
410   CONTINUE
      IF(T .EQ. TOUT) GO TO 719
      IF((T - TOUT)*H .GT. 0.0D0) GO TO 711
      IF(INFO(4) .EQ. 1) GO TO 430
      IF(INFO(3) .EQ. 1) GO TO 420
      IF((TN-TOUT)*H.LT.0.0D0)GO TO 490
      CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,IWORK(LKOLD),
     *  RWORK(LPHI),RWORK(LPSI))
      T=TOUT
      IDID = 3
      DONE = .TRUE.
      GO TO 490
420   IF((TN-T)*H .LE. 0.0D0) GO TO 490
      IF((TN - TOUT)*H .GT. 0.0D0) GO TO 425
      CALL DDATRP(TN,TN,Y,YPRIME,NEQ,IWORK(LKOLD),
     *  RWORK(LPHI),RWORK(LPSI))
      T = TN
      IDID = 1
      DONE = .TRUE.
      GO TO 490
425   CONTINUE
      CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,IWORK(LKOLD),
     *  RWORK(LPHI),RWORK(LPSI))
      T = TOUT
      IDID = 3
      DONE = .TRUE.
      GO TO 490
430   IF(INFO(3) .EQ. 1) GO TO 440
      TSTOP=RWORK(LTSTOP)
      IF((TN-TSTOP)*H.GT.0.0D0) GO TO 715
      IF((TSTOP-TOUT)*H.LT.0.0D0)GO TO 709
      IF((TN-TOUT)*H.LT.0.0D0)GO TO 450
      CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,IWORK(LKOLD),
     *   RWORK(LPHI),RWORK(LPSI))
      T=TOUT
      IDID = 3
      DONE = .TRUE.
      GO TO 490
440   TSTOP = RWORK(LTSTOP)
      IF((TN-TSTOP)*H .GT. 0.0D0) GO TO 715
      IF((TSTOP-TOUT)*H .LT. 0.0D0) GO TO 709
      IF((TN-T)*H .LE. 0.0D0) GO TO 450
      IF((TN - TOUT)*H .GT. 0.0D0) GO TO 445
      CALL DDATRP(TN,TN,Y,YPRIME,NEQ,IWORK(LKOLD),
     *  RWORK(LPHI),RWORK(LPSI))
      T = TN
      IDID = 1
      DONE = .TRUE.
      GO TO 490
445   CONTINUE
      CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,IWORK(LKOLD),
     *  RWORK(LPHI),RWORK(LPSI))
      T = TOUT
      IDID = 3
      DONE = .TRUE.
      GO TO 490
450   CONTINUE
C     CHECK WHETHER WE ARE WITHIN ROUNDOFF OF TSTOP
      IF(ABS(TN-TSTOP).GT.100.0D0*UROUND*
     *   (ABS(TN)+ABS(H)))GO TO 460
      CALL DDATRP(TN,TSTOP,Y,YPRIME,NEQ,IWORK(LKOLD),
     *  RWORK(LPHI),RWORK(LPSI))
      IDID=2
      T=TSTOP
      DONE = .TRUE.
      GO TO 490
460   TNEXT=TN+H
      IF((TNEXT-TSTOP)*H.LE.0.0D0)GO TO 490
      H=TSTOP-TN
      RWORK(LH)=H
C
490   IF(DONE) GO TO 580
C
C-------------------------------------------------------
C     THE NEXT BLOCK CONTAINS THE CALL TO THE
C     ONE-STEP INTEGRATOR DDASTP.
C     THIS IS A LOOPING POINT FOR THE INTEGRATION STEPS.
C     CHECK FOR TOO MANY STEPS.
C     UPDATE WT.
C     CHECK FOR TOO MUCH ACCURACY REQUESTED.
C     COMPUTE MINIMUM STEPSIZE.
C-------------------------------------------------------
C
500   CONTINUE
C     CHECK FOR FAILURE TO COMPUTE INITIAL YPRIME
      IF(IDID .EQ. -12) GO TO 527
C
C     CHECK FOR TOO MANY STEPS
      IF((IWORK(LNST)-IWORK(LNSTL)).LT.2000)    !was 500; AS changed 
     *   GO TO 510
           IDID=-1
           GO TO 527
C
C     UPDATE WT
510   CALL DDAWTS(NEQ,INFO(2),RTOL,ATOL,RWORK(LPHI),
     *  RWORK(LWT),RPAR,IPAR)
      DO 520 I=1,NEQ
         IF(RWORK(I+LWT-1).GT.0.0D0)GO TO 520
           IDID=-3
           GO TO 527
520   CONTINUE
C
C     TEST FOR TOO MUCH ACCURACY REQUESTED.
      R=DDANRM(NEQ,RWORK(LPHI),RWORK(LWT),RPAR,IPAR)*
     *   100.0D0*UROUND
      IF(R.LE.1.0D0)GO TO 525
C     MULTIPLY RTOL AND ATOL BY R AND RETURN
      IF(INFO(2).EQ.1)GO TO 523
           RTOL(1)=R*RTOL(1)
           ATOL(1)=R*ATOL(1)
           IDID=-2
           GO TO 527
523   DO 524 I=1,NEQ
           RTOL(I)=R*RTOL(I)
524        ATOL(I)=R*ATOL(I)
      IDID=-2
      GO TO 527
525   CONTINUE
C
C     COMPUTE MINIMUM STEPSIZE
      HMIN=4.0D0*UROUND*MAX(ABS(TN),ABS(TOUT))
C
C     TEST H VS. HMAX
      IF(INFO(7) .NE. 0) THEN
         RH = ABS(H)/RWORK(LHMAX)
         IF(RH .GT. 1.0D0) H = H/RH
      ENDIF
C
      CALL DDASTP(TN,Y,YPRIME,NEQ,
     *   RES,JAC,H,RWORK(LWT),INFO(1),IDID,RPAR,IPAR,
     *   RWORK(LPHI),RWORK(LDELTA),RWORK(LE),
     *   RWORK(LWM),IWORK(LIWM),
     *   RWORK(LALPHA),RWORK(LBETA),RWORK(LGAMMA),
     *   RWORK(LPSI),RWORK(LSIGMA),
     *   RWORK(LCJ),RWORK(LCJOLD),RWORK(LHOLD),
     *   RWORK(LS),HMIN,RWORK(LROUND),
     *   IWORK(LPHASE),IWORK(LJCALC),IWORK(LK),
     *   IWORK(LKOLD),IWORK(LNS),INFO(10),NTEMP)
527   IF(IDID.LT.0)GO TO 600
C
C--------------------------------------------------------
C     THIS BLOCK HANDLES THE CASE OF A SUCCESSFUL RETURN
C     FROM DDASTP (IDID=1).  TEST FOR STOP CONDITIONS.
C--------------------------------------------------------
C
      IF(INFO(4).NE.0)GO TO 540
           IF(INFO(3).NE.0)GO TO 530
             IF((TN-TOUT)*H.LT.0.0D0)GO TO 500
             CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,
     *         IWORK(LKOLD),RWORK(LPHI),RWORK(LPSI))
             IDID=3
             T=TOUT
             GO TO 580
530          IF((TN-TOUT)*H.GE.0.0D0)GO TO 535
             T=TN
             IDID=1
             GO TO 580
535          CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,
     *         IWORK(LKOLD),RWORK(LPHI),RWORK(LPSI))
             IDID=3
             T=TOUT
             GO TO 580
540   IF(INFO(3).NE.0)GO TO 550
      IF((TN-TOUT)*H.LT.0.0D0)GO TO 542
         CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,
     *     IWORK(LKOLD),RWORK(LPHI),RWORK(LPSI))
         T=TOUT
         IDID=3
         GO TO 580
542   IF(ABS(TN-TSTOP).LE.100.0D0*UROUND*
     *   (ABS(TN)+ABS(H)))GO TO 545
      TNEXT=TN+H
      IF((TNEXT-TSTOP)*H.LE.0.0D0)GO TO 500
      H=TSTOP-TN
      GO TO 500
545   CALL DDATRP(TN,TSTOP,Y,YPRIME,NEQ,
     *  IWORK(LKOLD),RWORK(LPHI),RWORK(LPSI))
      IDID=2
      T=TSTOP
      GO TO 580
550   IF((TN-TOUT)*H.GE.0.0D0)GO TO 555
      IF(ABS(TN-TSTOP).LE.100.0D0*UROUND*(ABS(TN)+ABS(H)))GO TO 552
      T=TN
      IDID=1
      GO TO 580
552   CALL DDATRP(TN,TSTOP,Y,YPRIME,NEQ,
     *  IWORK(LKOLD),RWORK(LPHI),RWORK(LPSI))
      IDID=2
      T=TSTOP
      GO TO 580
555   CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,
     *   IWORK(LKOLD),RWORK(LPHI),RWORK(LPSI))
      T=TOUT
      IDID=3
      GO TO 580
C
C--------------------------------------------------------
C     ALL SUCCESSFUL RETURNS FROM DDASSL ARE MADE FROM
C     THIS BLOCK.
C--------------------------------------------------------
C
580   CONTINUE
      RWORK(LTN)=TN
      RWORK(LH)=H
      RETURN
C
C-----------------------------------------------------------------------
C     THIS BLOCK HANDLES ALL UNSUCCESSFUL
C     RETURNS OTHER THAN FOR ILLEGAL INPUT.
C-----------------------------------------------------------------------
C
600   CONTINUE
      ITEMP=-IDID
      GO TO (610,620,630,690,690,640,650,660,670,675,
     *  680,685), ITEMP
C
C     THE MAXIMUM NUMBER OF STEPS WAS TAKEN BEFORE
C     REACHING TOUT
610   WRITE(XERN3, '(1P,D15.6)') TN
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'AT CURRENT T = ' // XERN3 // ' 500 STEPS TAKEN ON THIS ' //
     *   'CALL BEFORE REACHING TOUT', IDID, 1)
      GO TO 690
C
C     TOO MUCH ACCURACY FOR MACHINE PRECISION
620   WRITE(XERN3, '(1P,D15.6)') TN
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'AT T = ' // XERN3 // ' TOO MUCH ACCURACY REQUESTED FOR ' //
     *   'PRECISION OF MACHINE. RTOL AND ATOL WERE INCREASED TO ' //
     *   'APPROPRIATE VALUES', IDID, 1)
      GO TO 690
C
C     WT(I) .LE. 0.0 FOR SOME I (NOT AT START OF PROBLEM)
630   WRITE(XERN3, '(1P,D15.6)') TN
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'AT T = ' // XERN3 // ' SOME ELEMENT OF WT HAS BECOME .LE. ' //
     *   '0.0', IDID, 1)
      GO TO 690
C
C     ERROR TEST FAILED REPEATEDLY OR WITH H=HMIN
640   WRITE(XERN3, '(1P,D15.6)') TN
      WRITE(XERN4, '(1P,D15.6)') H
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'AT T = ' // XERN3 // ' AND STEPSIZE H = ' // XERN4 //
     *   ' THE ERROR TEST FAILED REPEATEDLY OR WITH ABS(H)=HMIN',
     *   IDID, 1)
      GO TO 690
C
C     CORRECTOR CONVERGENCE FAILED REPEATEDLY OR WITH H=HMIN
650   WRITE(XERN3, '(1P,D15.6)') TN
      WRITE(XERN4, '(1P,D15.6)') H
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'AT T = ' // XERN3 // ' AND STEPSIZE H = ' // XERN4 //
     *   ' THE CORRECTOR FAILED TO CONVERGE REPEATEDLY OR WITH ' //
     *   'ABS(H)=HMIN', IDID, 1)
      GO TO 690
C
C     THE ITERATION MATRIX IS SINGULAR
660   WRITE(XERN3, '(1P,D15.6)') TN
      WRITE(XERN4, '(1P,D15.6)') H
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'AT T = ' // XERN3 // ' AND STEPSIZE H = ' // XERN4 //
     *   ' THE ITERATION MATRIX IS SINGULAR', IDID, 1)
      GO TO 690
C
C     CORRECTOR FAILURE PRECEDED BY ERROR TEST FAILURES.
670   WRITE(XERN3, '(1P,D15.6)') TN
      WRITE(XERN4, '(1P,D15.6)') H
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'AT T = ' // XERN3 // ' AND STEPSIZE H = ' // XERN4 //
     *   ' THE CORRECTOR COULD NOT CONVERGE.  ALSO, THE ERROR TEST ' //
     *   'FAILED REPEATEDLY.', IDID, 1)
      GO TO 690
C
C     CORRECTOR FAILURE BECAUSE IRES = -1
675   WRITE(XERN3, '(1P,D15.6)') TN
      WRITE(XERN4, '(1P,D15.6)') H
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'AT T = ' // XERN3 // ' AND STEPSIZE H = ' // XERN4 //
     *   ' THE CORRECTOR COULD NOT CONVERGE BECAUSE IRES WAS EQUAL ' //
     *   'TO MINUS ONE', IDID, 1)
      GO TO 690
C
C     FAILURE BECAUSE IRES = -2
680   WRITE(XERN3, '(1P,D15.6)') TN
      WRITE(XERN4, '(1P,D15.6)') H
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'AT T = ' // XERN3 // ' AND STEPSIZE H = ' // XERN4 //
     *   ' IRES WAS EQUAL TO MINUS TWO', IDID, 1)
      GO TO 690
C
C     FAILED TO COMPUTE INITIAL YPRIME
685   WRITE(XERN3, '(1P,D15.6)') TN
      WRITE(XERN4, '(1P,D15.6)') HO
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'AT T = ' // XERN3 // ' AND STEPSIZE H = ' // XERN4 //
     *   ' THE INITIAL YPRIME COULD NOT BE COMPUTED', IDID, 1)
      GO TO 690
C
690   CONTINUE
      INFO(1)=-1
      T=TN
      RWORK(LTN)=TN
      RWORK(LH)=H
      RETURN
C
C-----------------------------------------------------------------------
C     THIS BLOCK HANDLES ALL ERROR RETURNS DUE
C     TO ILLEGAL INPUT, AS DETECTED BEFORE CALLING
C     DDASTP. FIRST THE ERROR MESSAGE ROUTINE IS
C     CALLED. IF THIS HAPPENS TWICE IN
C     SUCCESSION, EXECUTION IS TERMINATED
C
C-----------------------------------------------------------------------
701   CALL XERMSG ('SLATEC', 'DDASSL',
     *   'SOME ELEMENT OF INFO VECTOR IS NOT ZERO OR ONE', 1, 1)
      GO TO 750
C
702   WRITE(XERN1, '(I8)') NEQ
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'NEQ = ' // XERN1 // ' .LE. 0', 2, 1)
      GO TO 750
C
703   WRITE(XERN1, '(I8)') MXORD
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'MAXORD = ' // XERN1 // ' NOT IN RANGE', 3, 1)
      GO TO 750
C
704   WRITE(XERN1, '(I8)') LENRW
      WRITE(XERN2, '(I8)') LRW
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'RWORK LENGTH NEEDED, LENRW = ' // XERN1 //
     *   ', EXCEEDS LRW = ' // XERN2, 4, 1)
      GO TO 750
C
705   WRITE(XERN1, '(I8)') LENIW
      WRITE(XERN2, '(I8)') LIW
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'IWORK LENGTH NEEDED, LENIW = ' // XERN1 //
     *   ', EXCEEDS LIW = ' // XERN2, 5, 1)
      GO TO 750
C
706   CALL XERMSG ('SLATEC', 'DDASSL',
     *   'SOME ELEMENT OF RTOL IS .LT. 0', 6, 1)
      GO TO 750
C
707   CALL XERMSG ('SLATEC', 'DDASSL',
     *   'SOME ELEMENT OF ATOL IS .LT. 0', 7, 1)
      GO TO 750
C
708   CALL XERMSG ('SLATEC', 'DDASSL',
     *   'ALL ELEMENTS OF RTOL AND ATOL ARE ZERO', 8, 1)
      GO TO 750
C
709   WRITE(XERN3, '(1P,D15.6)') TSTOP
      WRITE(XERN4, '(1P,D15.6)') TOUT
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'INFO(4) = 1 AND TSTOP = ' // XERN3 // ' BEHIND TOUT = ' //
     *   XERN4, 9, 1)
      GO TO 750
C
710   WRITE(XERN3, '(1P,D15.6)') HMAX
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'HMAX = ' // XERN3 // ' .LT. 0.0', 10, 1)
      GO TO 750
C
711   WRITE(XERN3, '(1P,D15.6)') TOUT
      WRITE(XERN4, '(1P,D15.6)') T
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'TOUT = ' // XERN3 // ' BEHIND T = ' // XERN4, 11, 1)
      GO TO 750
C
712   CALL XERMSG ('SLATEC', 'DDASSL',
     *   'INFO(8)=1 AND H0=0.0', 12, 1)
      GO TO 750
C
713   CALL XERMSG ('SLATEC', 'DDASSL',
     *   'SOME ELEMENT OF WT IS .LE. 0.0', 13, 1)
      GO TO 750
C
714   WRITE(XERN3, '(1P,D15.6)') TOUT
      WRITE(XERN4, '(1P,D15.6)') T
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'TOUT = ' // XERN3 // ' TOO CLOSE TO T = ' // XERN4 //
     *   ' TO START INTEGRATION', 14, 1)
      GO TO 750
C
715   WRITE(XERN3, '(1P,D15.6)') TSTOP
      WRITE(XERN4, '(1P,D15.6)') T
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'INFO(4)=1 AND TSTOP = ' // XERN3 // ' BEHIND T = ' // XERN4,
     *   15, 1)
      GO TO 750
C
717   WRITE(XERN1, '(I8)') IWORK(LML)
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'ML = ' // XERN1 // ' ILLEGAL.  EITHER .LT. 0 OR .GT. NEQ',
     *   17, 1)
      GO TO 750
C
718   WRITE(XERN1, '(I8)') IWORK(LMU)
      CALL XERMSG ('SLATEC', 'DDASSL',
     *   'MU = ' // XERN1 // ' ILLEGAL.  EITHER .LT. 0 OR .GT. NEQ',
     *   18, 1)
      GO TO 750
C
719   WRITE(XERN3, '(1P,D15.6)') TOUT
      CALL XERMSG ('SLATEC', 'DDASSL',
     *  'TOUT = T = ' // XERN3, 19, 1)
      GO TO 750
C
750   IDID=-33
      IF(INFO(1).EQ.-1) THEN
         CALL XERMSG ('SLATEC', 'DDASSL',
     *      'REPEATED OCCURRENCES OF ILLEGAL INPUT$$' //
     *      'RUN TERMINATED. APPARENT INFINITE LOOP', -999, 2)
      ENDIF
C
      INFO(1)=-1
      RETURN
C-----------END OF SUBROUTINE DDASSL------------------------------------
      END
C
C#######################################################################
C
C                       D   D   A   S   T   P
C
C#######################################################################
C
*DECK DDASTP
      SUBROUTINE DDASTP (X, Y, YPRIME, NEQ, RES, JAC, H, WT, JSTART,
     *   IDID, RPAR, IPAR, PHI, DELTA, E, WM, IWM, ALPHA, BETA, GAMMA,
     *   PSI, SIGMA, CJ, CJOLD, HOLD, S, HMIN, UROUND, IPHASE, JCALC, K,
     *   KOLD, NS, NONNEG, NTEMP)
C***BEGIN PROLOGUE  DDASTP
C***SUBSIDIARY
C***PURPOSE  PERFORM ONE STEP OF THE DDASSL INTEGRATION.
C***LIBRARY   SLATEC (DASSL)
C***TYPE      DOUBLE PRECISION (SDASTP-S, DDASTP-D)
C***AUTHOR  PETZOLD, LINDA R., (LLNL)
C***DESCRIPTION
C-----------------------------------------------------------------------
C     DDASTP SOLVES A SYSTEM OF DIFFERENTIAL/
C     ALGEBRAIC EQUATIONS OF THE FORM
C     G(X,Y,YPRIME) = 0,  FOR ONE STEP (NORMALLY
C     FROM X TO X+H).
C
C     THE METHODS USED ARE MODIFIED DIVIDED
C     DIFFERENCE,FIXED LEADING COEFFICIENT
C     FORMS OF BACKWARD DIFFERENTIATION
C     FORMULAS. THE CODE ADJUSTS THE STEPSIZE
C     AND ORDER TO CONTROL THE LOCAL ERROR PER
C     STEP.
C
C
C     THE PARAMETERS REPRESENT
C     X  --        INDEPENDENT VARIABLE
C     Y  --        SOLUTION VECTOR AT X
C     YPRIME --    DERIVATIVE OF SOLUTION VECTOR
C                  AFTER SUCCESSFUL STEP
C     NEQ --       NUMBER OF EQUATIONS TO BE INTEGRATED
C     RES --       EXTERNAL USER-SUPPLIED SUBROUTINE
C                  TO EVALUATE THE RESIDUAL.  THE CALL IS
C                  CALL RES(X,Y,YPRIME,DELTA,IRES,RPAR,IPAR)
C                  X,Y,YPRIME ARE INPUT.  DELTA IS OUTPUT.
C                  ON INPUT, IRES=0.  RES SHOULD ALTER IRES ONLY
C                  IF IT ENCOUNTERS AN ILLEGAL VALUE OF Y OR A
C                  STOP CONDITION.  SET IRES=-1 IF AN INPUT VALUE
C                  OF Y IS ILLEGAL, AND DDASTP WILL TRY TO SOLVE
C                  THE PROBLEM WITHOUT GETTING IRES = -1.  IF
C                  IRES=-2, DDASTP RETURNS CONTROL TO THE CALLING
C                  PROGRAM WITH IDID = -11.
C     JAC --       EXTERNAL USER-SUPPLIED ROUTINE TO EVALUATE
C                  THE ITERATION MATRIX (THIS IS OPTIONAL)
C                  THE CALL IS OF THE FORM
C                  CALL JAC(X,Y,YPRIME,PD,CJ,RPAR,IPAR)
C                  PD IS THE MATRIX OF PARTIAL DERIVATIVES,
C                  PD=DG/DY+CJ*DG/DYPRIME
C     H --         APPROPRIATE STEP SIZE FOR NEXT STEP.
C                  NORMALLY DETERMINED BY THE CODE
C     WT --        VECTOR OF WEIGHTS FOR ERROR CRITERION.
C     JSTART --    INTEGER VARIABLE SET 0 FOR
C                  FIRST STEP, 1 OTHERWISE.
C     IDID --      COMPLETION CODE WITH THE FOLLOWING MEANINGS:
C                  IDID= 1 -- THE STEP WAS COMPLETED SUCCESSFULLY
C                  IDID=-6 -- THE ERROR TEST FAILED REPEATEDLY
C                  IDID=-7 -- THE CORRECTOR COULD NOT CONVERGE
C                  IDID=-8 -- THE ITERATION MATRIX IS SINGULAR
C                  IDID=-9 -- THE CORRECTOR COULD NOT CONVERGE.
C                             THERE WERE REPEATED ERROR TEST
C                             FAILURES ON THIS STEP.
C                  IDID=-10-- THE CORRECTOR COULD NOT CONVERGE
C                             BECAUSE IRES WAS EQUAL TO MINUS ONE
C                  IDID=-11-- IRES EQUAL TO -2 WAS ENCOUNTERED,
C                             AND CONTROL IS BEING RETURNED TO
C                             THE CALLING PROGRAM
C     RPAR,IPAR -- REAL AND INTEGER PARAMETER ARRAYS THAT
C                  ARE USED FOR COMMUNICATION BETWEEN THE
C                  CALLING PROGRAM AND EXTERNAL USER ROUTINES
C                  THEY ARE NOT ALTERED BY DDASTP
C     PHI --       ARRAY OF DIVIDED DIFFERENCES USED BY
C                  DDASTP. THE LENGTH IS NEQ*(K+1),WHERE
C                  K IS THE MAXIMUM ORDER
C     DELTA,E --   WORK VECTORS FOR DDASTP OF LENGTH NEQ
C     WM,IWM --    REAL AND INTEGER ARRAYS STORING
C                  MATRIX INFORMATION SUCH AS THE MATRIX
C                  OF PARTIAL DERIVATIVES,PERMUTATION
C                  VECTOR, AND VARIOUS OTHER INFORMATION.
C
C     THE OTHER PARAMETERS ARE INFORMATION
C     WHICH IS NEEDED INTERNALLY BY DDASTP TO
C     CONTINUE FROM STEP TO STEP.
C
C-----------------------------------------------------------------------
C***ROUTINES CALLED  DDAJAC, DDANRM, DDASLV, DDATRP
C***REVISION HISTORY  (YYMMDD)
C   830315  DATE WRITTEN
C   901009  FINISHED CONVERSION TO SLATEC 4.0 FORMAT (F.N.FRITSCH)
C   901019  MERGED CHANGES MADE BY C. ULRICH WITH SLATEC 4.0 FORMAT.
C   901026  ADDED EXPLICIT DECLARATIONS FOR ALL VARIABLES AND MINOR
C           COSMETIC CHANGES TO PROLOGUE.  (FNF)
C***END PROLOGUE  DDASTP
C
      INTEGER  NEQ, JSTART, IDID, IPAR(*), IWM(*), IPHASE, JCALC, K,
     *   KOLD, NS, NONNEG, NTEMP
      DOUBLE PRECISION
     *   X, Y(*), YPRIME(*), H, WT(*), RPAR(*), PHI(NEQ,*), DELTA(*),
     *   E(*), WM(*), ALPHA(*), BETA(*), GAMMA(*), PSI(*), SIGMA(*), CJ,
     *   CJOLD, HOLD, S, HMIN, UROUND
      EXTERNAL  RES, JAC
C
      EXTERNAL  DDAJAC, DDANRM, DDASLV, DDATRP
      DOUBLE PRECISION  DDANRM
C
      INTEGER  I, IER, IRES, J, J1, KDIFF, KM1, KNEW, KP1, KP2, LCTF,
     *   LETF, LMXORD, LNJE, LNRE, LNST, M, MAXIT, NCF, NEF, NSF, NSP1
      DOUBLE PRECISION
     *   ALPHA0, ALPHAS, CJLAST, CK, DELNRM, ENORM, ERK, ERKM1,
     *   ERKM2, ERKP1, ERR, EST, HNEW, OLDNRM, PNORM, R, RATE, TEMP1,
     *   TEMP2, TERK, TERKM1, TERKM2, TERKP1, XOLD, XRATE
      LOGICAL  CONVGD
C
      PARAMETER (LMXORD=3)
      PARAMETER (LNST=11)
      PARAMETER (LNRE=12)
      PARAMETER (LNJE=13)
      PARAMETER (LETF=14)
      PARAMETER (LCTF=15)
C
      DATA MAXIT/4/
      DATA XRATE/0.25D0/
C
C
C
C
C
C-----------------------------------------------------------------------
C     BLOCK 1.
C     INITIALIZE. ON THE FIRST CALL,SET
C     THE ORDER TO 1 AND INITIALIZE
C     OTHER VARIABLES.
C-----------------------------------------------------------------------
C
C     INITIALIZATIONS FOR ALL CALLS
C***FIRST EXECUTABLE STATEMENT  DDASTP
      IDID=1
      XOLD=X
      NCF=0
      NSF=0
      NEF=0
      IF(JSTART .NE. 0) GO TO 120
C
C     IF THIS IS THE FIRST STEP,PERFORM
C     OTHER INITIALIZATIONS
      IWM(LETF) = 0
      IWM(LCTF) = 0
      K=1
      KOLD=0
      HOLD=0.0D0
      JSTART=1
      PSI(1)=H
      CJOLD = 1.0D0/H
      CJ = CJOLD
      S = 100.D0
      JCALC = -1
      DELNRM=1.0D0
      IPHASE = 0
      NS=0
120   CONTINUE
C
C
C
C
C
C-----------------------------------------------------------------------
C     BLOCK 2
C     COMPUTE COEFFICIENTS OF FORMULAS FOR
C     THIS STEP.
C-----------------------------------------------------------------------
200   CONTINUE
      KP1=K+1
      KP2=K+2
      KM1=K-1
      XOLD=X
      IF(H.NE.HOLD.OR.K .NE. KOLD) NS = 0
      NS=MIN(NS+1,KOLD+2)
      NSP1=NS+1
      IF(KP1 .LT. NS)GO TO 230
C
      BETA(1)=1.0D0
      ALPHA(1)=1.0D0
      TEMP1=H
      GAMMA(1)=0.0D0
      SIGMA(1)=1.0D0
      DO 210 I=2,KP1
         TEMP2=PSI(I-1)
         PSI(I-1)=TEMP1
         BETA(I)=BETA(I-1)*PSI(I-1)/TEMP2
         TEMP1=TEMP2+H
         ALPHA(I)=H/TEMP1
         SIGMA(I)=(I-1)*SIGMA(I-1)*ALPHA(I)
         GAMMA(I)=GAMMA(I-1)+ALPHA(I-1)/H
210      CONTINUE
      PSI(KP1)=TEMP1
230   CONTINUE
C
C     COMPUTE ALPHAS, ALPHA0
      ALPHAS = 0.0D0
      ALPHA0 = 0.0D0
      DO 240 I = 1,K
        ALPHAS = ALPHAS - 1.0D0/I
        ALPHA0 = ALPHA0 - ALPHA(I)
240     CONTINUE
C
C     COMPUTE LEADING COEFFICIENT CJ
      CJLAST = CJ
      CJ = -ALPHAS/H
C
C     COMPUTE VARIABLE STEPSIZE ERROR COEFFICIENT CK
      CK = ABS(ALPHA(KP1) + ALPHAS - ALPHA0)
      CK = MAX(CK,ALPHA(KP1))
C
C     DECIDE WHETHER NEW JACOBIAN IS NEEDED
      TEMP1 = (1.0D0 - XRATE)/(1.0D0 + XRATE)
      TEMP2 = 1.0D0/TEMP1
      IF(CJ/CJOLD .LT. TEMP1 .OR. CJ/CJOLD .GT. TEMP2) JCALC = -1
      IF(CJ .NE. CJLAST) S = 100.D0
C
C     CHANGE PHI TO PHI STAR
      IF(KP1 .LT. NSP1) GO TO 280
      DO 270 J=NSP1,KP1
         DO 260 I=1,NEQ
260         PHI(I,J)=BETA(J)*PHI(I,J)
270      CONTINUE
280   CONTINUE
C
C     UPDATE TIME
      X=X+H
C
C
C
C
C
C-----------------------------------------------------------------------
C     BLOCK 3
C     PREDICT THE SOLUTION AND DERIVATIVE,
C     AND SOLVE THE CORRECTOR EQUATION
C-----------------------------------------------------------------------
C
C     FIRST,PREDICT THE SOLUTION AND DERIVATIVE
300   CONTINUE
      DO 310 I=1,NEQ
         Y(I)=PHI(I,1)
310      YPRIME(I)=0.0D0
      DO 330 J=2,KP1
         DO 320 I=1,NEQ
            Y(I)=Y(I)+PHI(I,J)
320         YPRIME(I)=YPRIME(I)+GAMMA(J)*PHI(I,J)
330   CONTINUE
      PNORM = DDANRM (NEQ,Y,WT,RPAR,IPAR)
C
C
C
C     SOLVE THE CORRECTOR EQUATION USING A
C     MODIFIED NEWTON SCHEME.
      CONVGD= .TRUE.
      M=0
      IWM(LNRE)=IWM(LNRE)+1
      IRES = 0
      CALL RES(X,Y,YPRIME,DELTA,IRES,RPAR,IPAR)
      IF(IRES .LT. 0) GO TO 380
C
C
C     IF INDICATED,REEVALUATE THE
C     ITERATION MATRIX PD = DG/DY + CJ*DG/DYPRIME
C     (WHERE G(X,Y,YPRIME)=0). SET
C     JCALC TO 0 AS AN INDICATOR THAT
C     THIS HAS BEEN DONE.
      IF(JCALC .NE. -1)GO TO 340
      IWM(LNJE)=IWM(LNJE)+1
      JCALC=0
      CALL DDAJAC(NEQ,X,Y,YPRIME,DELTA,CJ,H,
     * IER,WT,E,WM,IWM,RES,IRES,UROUND,JAC,RPAR,
     * IPAR,NTEMP)
      CJOLD=CJ
      S = 100.D0
      IF(IRES .LT. 0) GO TO 380
      IF(IER .NE. 0)GO TO 380
      NSF=0
C
C
C     INITIALIZE THE ERROR ACCUMULATION VECTOR E.
340   CONTINUE
      DO 345 I=1,NEQ
345      E(I)=0.0D0
C
C
C     CORRECTOR LOOP.
350   CONTINUE
C
C     MULTIPLY RESIDUAL BY TEMP1 TO ACCELERATE CONVERGENCE
      TEMP1 = 2.0D0/(1.0D0 + CJ/CJOLD)
      DO 355 I = 1,NEQ
355     DELTA(I) = DELTA(I) * TEMP1
C
C     COMPUTE A NEW ITERATE (BACK-SUBSTITUTION).
C     STORE THE CORRECTION IN DELTA.
      CALL DDASLV(NEQ,DELTA,WM,IWM)
C
C     UPDATE Y, E, AND YPRIME
      DO 360 I=1,NEQ
         Y(I)=Y(I)-DELTA(I)
         E(I)=E(I)-DELTA(I)
360      YPRIME(I)=YPRIME(I)-CJ*DELTA(I)
C
C     TEST FOR CONVERGENCE OF THE ITERATION
      DELNRM=DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      IF(DELNRM .LE. 100.D0*UROUND*PNORM) GO TO 375
      IF(M .GT. 0) GO TO 365
         OLDNRM = DELNRM
         GO TO 367
365   RATE = (DELNRM/OLDNRM)**(1.0D0/M)
      IF(RATE .GT. 0.90D0) GO TO 370
      S = RATE/(1.0D0 - RATE)
367   IF(S*DELNRM .LE. 0.33D0) GO TO 375
C
C     THE CORRECTOR HAS NOT YET CONVERGED.
C     UPDATE M AND TEST WHETHER THE
C     MAXIMUM NUMBER OF ITERATIONS HAVE
C     BEEN TRIED.
      M=M+1
      IF(M.GE.MAXIT)GO TO 370
C
C     EVALUATE THE RESIDUAL
C     AND GO BACK TO DO ANOTHER ITERATION
      IWM(LNRE)=IWM(LNRE)+1
      IRES = 0
      CALL RES(X,Y,YPRIME,DELTA,IRES,
     *  RPAR,IPAR)
      IF(IRES .LT. 0) GO TO 380
      GO TO 350
C
C
C     THE CORRECTOR FAILED TO CONVERGE IN MAXIT
C     ITERATIONS. IF THE ITERATION MATRIX
C     IS NOT CURRENT,RE-DO THE STEP WITH
C     A NEW ITERATION MATRIX.
370   CONTINUE
      IF(JCALC.EQ.0)GO TO 380
      JCALC=-1
      GO TO 300
C
C
C     THE ITERATION HAS CONVERGED.  IF NONNEGATIVITY OF SOLUTION IS
C     REQUIRED, SET THE SOLUTION NONNEGATIVE, IF THE PERTURBATION
C     TO DO IT IS SMALL ENOUGH.  IF THE CHANGE IS TOO LARGE, THEN
C     CONSIDER THE CORRECTOR ITERATION TO HAVE FAILED.
375   IF(NONNEG .EQ. 0) GO TO 390
      DO 377 I = 1,NEQ
377      DELTA(I) = MIN(Y(I),0.0D0)
      DELNRM = DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      IF(DELNRM .GT. 0.33D0) GO TO 380
      DO 378 I = 1,NEQ
378      E(I) = E(I) - DELTA(I)
      GO TO 390
C
C
C     EXITS FROM BLOCK 3
C     NO CONVERGENCE WITH CURRENT ITERATION
C     MATRIX,OR SINGULAR ITERATION MATRIX
380   CONVGD= .FALSE.
390   JCALC = 1
      IF(.NOT.CONVGD)GO TO 600
C
C
C
C
C
C-----------------------------------------------------------------------
C     BLOCK 4
C     ESTIMATE THE ERRORS AT ORDERS K,K-1,K-2
C     AS IF CONSTANT STEPSIZE WAS USED. ESTIMATE
C     THE LOCAL ERROR AT ORDER K AND TEST
C     WHETHER THE CURRENT STEP IS SUCCESSFUL.
C-----------------------------------------------------------------------
C
C     ESTIMATE ERRORS AT ORDERS K,K-1,K-2
      ENORM = DDANRM(NEQ,E,WT,RPAR,IPAR)
      ERK = SIGMA(K+1)*ENORM
      TERK = (K+1)*ERK
      EST = ERK
      KNEW=K
      IF(K .EQ. 1)GO TO 430
      DO 405 I = 1,NEQ
405     DELTA(I) = PHI(I,KP1) + E(I)
      ERKM1=SIGMA(K)*DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      TERKM1 = K*ERKM1
      IF(K .GT. 2)GO TO 410
      IF(TERKM1 .LE. 0.5D0*TERK)GO TO 420
      GO TO 430
410   CONTINUE
      DO 415 I = 1,NEQ
415     DELTA(I) = PHI(I,K) + DELTA(I)
      ERKM2=SIGMA(K-1)*DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      TERKM2 = (K-1)*ERKM2
      IF(MAX(TERKM1,TERKM2).GT.TERK)GO TO 430
C     LOWER THE ORDER
420   CONTINUE
      KNEW=K-1
      EST = ERKM1
C
C
C     CALCULATE THE LOCAL ERROR FOR THE CURRENT STEP
C     TO SEE IF THE STEP WAS SUCCESSFUL
430   CONTINUE
      ERR = CK * ENORM
      IF(ERR .GT. 1.0D0)GO TO 600
C
C
C
C
C
C-----------------------------------------------------------------------
C     BLOCK 5
C     THE STEP IS SUCCESSFUL. DETERMINE
C     THE BEST ORDER AND STEPSIZE FOR
C     THE NEXT STEP. UPDATE THE DIFFERENCES
C     FOR THE NEXT STEP.
C-----------------------------------------------------------------------
      IDID=1
      IWM(LNST)=IWM(LNST)+1
      KDIFF=K-KOLD
      KOLD=K
      HOLD=H
C
C
C     ESTIMATE THE ERROR AT ORDER K+1 UNLESS:
C        ALREADY DECIDED TO LOWER ORDER, OR
C        ALREADY USING MAXIMUM ORDER, OR
C        STEPSIZE NOT CONSTANT, OR
C        ORDER RAISED IN PREVIOUS STEP
      IF(KNEW.EQ.KM1.OR.K.EQ.IWM(LMXORD))IPHASE=1
      IF(IPHASE .EQ. 0)GO TO 545
      IF(KNEW.EQ.KM1)GO TO 540
      IF(K.EQ.IWM(LMXORD)) GO TO 550
      IF(KP1.GE.NS.OR.KDIFF.EQ.1)GO TO 550
      DO 510 I=1,NEQ
510      DELTA(I)=E(I)-PHI(I,KP2)
      ERKP1 = (1.0D0/(K+2))*DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      TERKP1 = (K+2)*ERKP1
      IF(K.GT.1)GO TO 520
      IF(TERKP1.GE.0.5D0*TERK)GO TO 550
      GO TO 530
520   IF(TERKM1.LE.MIN(TERK,TERKP1))GO TO 540
      IF(TERKP1.GE.TERK.OR.K.EQ.IWM(LMXORD))GO TO 550
C
C     RAISE ORDER
530   K=KP1
      EST = ERKP1
      GO TO 550
C
C     LOWER ORDER
540   K=KM1
      EST = ERKM1
      GO TO 550
C
C     IF IPHASE = 0, INCREASE ORDER BY ONE AND MULTIPLY STEPSIZE BY
C     FACTOR TWO
545   K = KP1
      HNEW = H*2.0D0
      H = HNEW
      GO TO 575
C
C
C     DETERMINE THE APPROPRIATE STEPSIZE FOR
C     THE NEXT STEP.
550   HNEW=H
      TEMP2=K+1
      R=(2.0D0*EST+0.0001D0)**(-1.0D0/TEMP2)
      IF(R .LT. 2.0D0) GO TO 555
      HNEW = 2.0D0*H
      GO TO 560
555   IF(R .GT. 1.0D0) GO TO 560
      R = MAX(0.5D0,MIN(0.9D0,R))
      HNEW = H*R
560   H=HNEW
C
C
C     UPDATE DIFFERENCES FOR NEXT STEP
575   CONTINUE
      IF(KOLD.EQ.IWM(LMXORD))GO TO 585
      DO 580 I=1,NEQ
580      PHI(I,KP2)=E(I)
585   CONTINUE
      DO 590 I=1,NEQ
590      PHI(I,KP1)=PHI(I,KP1)+E(I)
      DO 595 J1=2,KP1
         J=KP1-J1+1
         DO 595 I=1,NEQ
595      PHI(I,J)=PHI(I,J)+PHI(I,J+1)
      RETURN
C
C
C
C
C
C-----------------------------------------------------------------------
C     BLOCK 6
C     THE STEP IS UNSUCCESSFUL. RESTORE X,PSI,PHI
C     DETERMINE APPROPRIATE STEPSIZE FOR
C     CONTINUING THE INTEGRATION, OR EXIT WITH
C     AN ERROR FLAG IF THERE HAVE BEEN MANY
C     FAILURES.
C-----------------------------------------------------------------------
600   IPHASE = 1
C
C     RESTORE X,PHI,PSI
      X=XOLD
      IF(KP1.LT.NSP1)GO TO 630
      DO 620 J=NSP1,KP1
         TEMP1=1.0D0/BETA(J)
         DO 610 I=1,NEQ
610         PHI(I,J)=TEMP1*PHI(I,J)
620      CONTINUE
630   CONTINUE
      DO 640 I=2,KP1
640      PSI(I-1)=PSI(I)-H
C
C
C     TEST WHETHER FAILURE IS DUE TO CORRECTOR ITERATION
C     OR ERROR TEST
      IF(CONVGD)GO TO 660
      IWM(LCTF)=IWM(LCTF)+1
C
C
C     THE NEWTON ITERATION FAILED TO CONVERGE WITH
C     A CURRENT ITERATION MATRIX.  DETERMINE THE CAUSE
C     OF THE FAILURE AND TAKE APPROPRIATE ACTION.
      IF(IER.EQ.0)GO TO 650
C
C     THE ITERATION MATRIX IS SINGULAR. REDUCE
C     THE STEPSIZE BY A FACTOR OF 4. IF
C     THIS HAPPENS THREE TIMES IN A ROW ON
C     THE SAME STEP, RETURN WITH AN ERROR FLAG
      NSF=NSF+1
      R = 0.25D0
      H=H*R
      IF(NSF .LT. 3 .AND. ABS(H) .GE. HMIN) GO TO 690
      IDID=-8
      GO TO 675
C
C
C     THE NEWTON ITERATION FAILED TO CONVERGE FOR A REASON
C     OTHER THAN A SINGULAR ITERATION MATRIX.  IF IRES = -2, THEN
C     RETURN.  OTHERWISE, REDUCE THE STEPSIZE AND TRY AGAIN, UNLESS
C     TOO MANY FAILURES HAVE OCCURRED.
650   CONTINUE
      IF(IRES .GT. -2) GO TO 655
      IDID = -11
      GO TO 675
655   NCF = NCF + 1
      R = 0.25D0
      H = H*R
      IF(NCF .LT. 10 .AND. ABS(H) .GE. HMIN) GO TO 690
      IDID = -7
      IF(IRES .LT. 0) IDID = -10
      IF(NEF .GE. 3) IDID = -9
      GO TO 675
C
C
C     THE NEWTON SCHEME CONVERGED, AND THE CAUSE
C     OF THE FAILURE WAS THE ERROR ESTIMATE
C     EXCEEDING THE TOLERANCE.
660   NEF=NEF+1
      IWM(LETF)=IWM(LETF)+1
      IF(NEF .GT. 1) GO TO 665
C
C     ON FIRST ERROR TEST FAILURE, KEEP CURRENT ORDER OR LOWER
C     ORDER BY ONE.  COMPUTE NEW STEPSIZE BASED ON DIFFERENCES
C     OF THE SOLUTION.
      K = KNEW
      TEMP2 = K + 1
      R = 0.90D0*(2.0D0*EST+0.0001D0)**(-1.0D0/TEMP2)
      R = MAX(0.25D0,MIN(0.9D0,R))
      H = H*R
      IF(ABS(H) .GE. HMIN) GO TO 690
      IDID = -6
      GO TO 675
C
C     ON SECOND ERROR TEST FAILURE, USE THE CURRENT ORDER OR
C     DECREASE ORDER BY ONE.  REDUCE THE STEPSIZE BY A FACTOR OF
C     FOUR.
665   IF(NEF .GT. 2) GO TO 670
      K = KNEW
      H = 0.25D0*H
      IF(ABS(H) .GE. HMIN) GO TO 690
      IDID = -6
      GO TO 675
C
C     ON THIRD AND SUBSEQUENT ERROR TEST FAILURES, SET THE ORDER TO
C     ONE AND REDUCE THE STEPSIZE BY A FACTOR OF FOUR.
670   K = 1
      H = 0.25D0*H
      IF(ABS(H) .GE. HMIN) GO TO 690
      IDID = -6
      GO TO 675
C
C
C
C
C     FOR ALL CRASHES, RESTORE Y TO ITS LAST VALUE,
C     INTERPOLATE TO FIND YPRIME AT LAST X, AND RETURN
675   CONTINUE
      CALL DDATRP(X,X,Y,YPRIME,NEQ,K,PHI,PSI)
      RETURN
C
C
C     GO BACK AND TRY THIS STEP AGAIN
690   GO TO 200
C
C------END OF SUBROUTINE DDASTP------
      END
C
C#######################################################################
C
C                       D   D   A   T   R   P
C
C#######################################################################
C
*DECK DDATRP
      SUBROUTINE DDATRP (X, XOUT, YOUT, YPOUT, NEQ, KOLD, PHI, PSI)
C***BEGIN PROLOGUE  DDATRP
C***SUBSIDIARY
C***PURPOSE  INTERPOLATION ROUTINE FOR DDASSL.
C***LIBRARY   SLATEC (DASSL)
C***TYPE      DOUBLE PRECISION (SDATRP-S, DDATRP-D)
C***AUTHOR  PETZOLD, LINDA R., (LLNL)
C***DESCRIPTION
C-----------------------------------------------------------------------
C     THE METHODS IN SUBROUTINE DDASTP USE POLYNOMIALS
C     TO APPROXIMATE THE SOLUTION. DDATRP APPROXIMATES THE
C     SOLUTION AND ITS DERIVATIVE AT TIME XOUT BY EVALUATING
C     ONE OF THESE POLYNOMIALS, AND ITS DERIVATIVE,THERE.
C     INFORMATION DEFINING THIS POLYNOMIAL IS PASSED FROM
C     DDASTP, SO DDATRP CANNOT BE USED ALONE.
C
C     THE PARAMETERS ARE:
C     X     THE CURRENT TIME IN THE INTEGRATION.
C     XOUT  THE TIME AT WHICH THE SOLUTION IS DESIRED
C     YOUT  THE INTERPOLATED APPROXIMATION TO Y AT XOUT
C           (THIS IS OUTPUT)
C     YPOUT THE INTERPOLATED APPROXIMATION TO YPRIME AT XOUT
C           (THIS IS OUTPUT)
C     NEQ   NUMBER OF EQUATIONS
C     KOLD  ORDER USED ON LAST SUCCESSFUL STEP
C     PHI   ARRAY OF SCALED DIVIDED DIFFERENCES OF Y
C     PSI   ARRAY OF PAST STEPSIZE HISTORY
C-----------------------------------------------------------------------
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   830315  DATE WRITTEN
C   901009  FINISHED CONVERSION TO SLATEC 4.0 FORMAT (F.N.FRITSCH)
C   901019  MERGED CHANGES MADE BY C. ULRICH WITH SLATEC 4.0 FORMAT.
C   901026  ADDED EXPLICIT DECLARATIONS FOR ALL VARIABLES AND MINOR
C           COSMETIC CHANGES TO PROLOGUE.  (FNF)
C***END PROLOGUE  DDATRP
C
      INTEGER  NEQ, KOLD
      DOUBLE PRECISION  X, XOUT, YOUT(*), YPOUT(*), PHI(NEQ,*), PSI(*)
C
      INTEGER  I, J, KOLDP1
      DOUBLE PRECISION  C, D, GAMMA, TEMP1
C
C***FIRST EXECUTABLE STATEMENT  DDATRP
      KOLDP1=KOLD+1
      TEMP1=XOUT-X
      DO 10 I=1,NEQ
         YOUT(I)=PHI(I,1)
10       YPOUT(I)=0.0D0
      C=1.0D0
      D=0.0D0
      GAMMA=TEMP1/PSI(1)
      DO 30 J=2,KOLDP1
         D=D*GAMMA+C/PSI(J-1)
         C=C*GAMMA
         GAMMA=(TEMP1+PSI(J-1))/PSI(J)
         DO 20 I=1,NEQ
            YOUT(I)=YOUT(I)+C*PHI(I,J)
20          YPOUT(I)=YPOUT(I)+D*PHI(I,J)
30       CONTINUE
      RETURN
C
C------END OF SUBROUTINE DDATRP------
      END
C
C#######################################################################
C
C                       D   D   A   W   T   S
C
C#######################################################################
C
*DECK DDAWTS
      SUBROUTINE DDAWTS (NEQ, IWT, RTOL, ATOL, Y, WT, RPAR, IPAR)
C***BEGIN PROLOGUE  DDAWTS
C***SUBSIDIARY
C***PURPOSE  SET ERROR WEIGHT VECTOR FOR DDASSL.
C***LIBRARY   SLATEC (DASSL)
C***TYPE      DOUBLE PRECISION (SDAWTS-S, DDAWTS-D)
C***AUTHOR  PETZOLD, LINDA R., (LLNL)
C***DESCRIPTION
C-----------------------------------------------------------------------
C     THIS SUBROUTINE SETS THE ERROR WEIGHT VECTOR
C     WT ACCORDING TO WT(I)=RTOL(I)*ABS(Y(I))+ATOL(I),
C     I=1,-,N.
C     RTOL AND ATOL ARE SCALARS IF IWT = 0,
C     AND VECTORS IF IWT = 1.
C-----------------------------------------------------------------------
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   830315  DATE WRITTEN
C   901009  FINISHED CONVERSION TO SLATEC 4.0 FORMAT (F.N.FRITSCH)
C   901019  MERGED CHANGES MADE BY C. ULRICH WITH SLATEC 4.0 FORMAT.
C   901026  ADDED EXPLICIT DECLARATIONS FOR ALL VARIABLES AND MINOR
C           COSMETIC CHANGES TO PROLOGUE.  (FNF)
C***END PROLOGUE  DDAWTS
C
      INTEGER  NEQ, IWT, IPAR(*)
      DOUBLE PRECISION  RTOL(*), ATOL(*), Y(*), WT(*), RPAR(*)
C
      INTEGER  I
      DOUBLE PRECISION  ATOLI, RTOLI
C
C***FIRST EXECUTABLE STATEMENT  DDAWTS
      RTOLI=RTOL(1)
      ATOLI=ATOL(1)
      DO 20 I=1,NEQ
         IF(IWT .EQ.0) GO TO 10
           RTOLI=RTOL(I)
           ATOLI=ATOL(I)
10         WT(I)=RTOLI*ABS(Y(I))+ATOLI
20         CONTINUE
      RETURN
C-----------END OF SUBROUTINE DDAWTS------------------------------------
      END
C
C#######################################################################
C
C                       X   E   R   M   S   G
C
C#######################################################################
C
*DECK XERMSG
      SUBROUTINE XERMSG (LIBRAR, SUBROU, MESSG, NERR, LEVEL)
C***BEGIN PROLOGUE  XERMSG
C***PURPOSE  PROCESS ERROR MESSAGES FOR SLATEC AND OTHER LIBRARIES.
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3C
C***TYPE      ALL (XERMSG-A)
C***KEYWORDS  ERROR MESSAGE, XERROR
C***AUTHOR  FONG, KIRBY, (NMFECC AT LLNL)
C***DESCRIPTION
C
C   XERMSG PROCESSES A DIAGNOSTIC MESSAGE IN A MANNER DETERMINED BY THE
C   VALUE OF LEVEL AND THE CURRENT VALUE OF THE LIBRARY ERROR CONTROL
C   FLAG, KONTRL.  SEE SUBROUTINE XSETF FOR DETAILS.
C
C    LIBRAR   A CHARACTER CONSTANT (OR CHARACTER VARIABLE) WITH THE NAME
C             OF THE LIBRARY.  THIS WILL BE 'SLATEC' FOR THE SLATEC
C             COMMON MATH LIBRARY.  THE ERROR HANDLING PACKAGE IS
C             GENERAL ENOUGH TO BE USED BY MANY LIBRARIES
C             SIMULTANEOUSLY, SO IT IS DESIRABLE FOR THE ROUTINE THAT
C             DETECTS AND REPORTS AN ERROR TO IDENTIFY THE LIBRARY NAME
C             AS WELL AS THE ROUTINE NAME.
C
C    SUBROU   A CHARACTER CONSTANT (OR CHARACTER VARIABLE) WITH THE NAME
C             OF THE ROUTINE THAT DETECTED THE ERROR.  USUALLY IT IS THE
C             NAME OF THE ROUTINE THAT IS CALLING XERMSG.  THERE ARE
C             SOME INSTANCES WHERE A USER CALLABLE LIBRARY ROUTINE CALLS
C             LOWER LEVEL SUBSIDIARY ROUTINES WHERE THE ERROR IS
C             DETECTED.  IN SUCH CASES IT MAY BE MORE INFORMATIVE TO
C             SUPPLY THE NAME OF THE ROUTINE THE USER CALLED RATHER THAN
C             THE NAME OF THE SUBSIDIARY ROUTINE THAT DETECTED THE
C             ERROR.
C
C    MESSG    A CHARACTER CONSTANT (OR CHARACTER VARIABLE) WITH THE TEXT
C             OF THE ERROR OR WARNING MESSAGE.  IN THE EXAMPLE BELOW,
C             THE MESSAGE IS A CHARACTER CONSTANT THAT CONTAINS A
C             GENERIC MESSAGE.
C
C                   CALL XERMSG ('SLATEC', 'MMPY',
C                  *'THE ORDER OF THE MATRIX EXCEEDS THE ROW DIMENSION',
C                  *3, 1)
C
C             IT IS POSSIBLE (AND IS SOMETIMES DESIRABLE) TO GENERATE A
C             SPECIFIC MESSAGE--E.G., ONE THAT CONTAINS ACTUAL NUMERIC
C             VALUES.  SPECIFIC NUMERIC VALUES CAN BE CONVERTED INTO
C             CHARACTER STRINGS USING FORMATTED WRITE STATEMENTS INTO
C             CHARACTER VARIABLES.  THIS IS CALLED STANDARD FORTRAN
C             INTERNAL FILE I/O AND IS EXEMPLIFIED IN THE FIRST THREE
C             LINES OF THE FOLLOWING EXAMPLE.  YOU CAN ALSO CATENATE
C             SUBSTRINGS OF CHARACTERS TO CONSTRUCT THE ERROR MESSAGE.
C             HERE IS AN EXAMPLE SHOWING THE USE OF BOTH WRITING TO
C             AN INTERNAL FILE AND CATENATING CHARACTER STRINGS.
C
C                   CHARACTER*5 CHARN, CHARL
C                   WRITE(CHARN,10) N
C                   WRITE(CHARL,10) LDA
C                10 FORMAT(I5)
C                   CALL XERMSG ('SLATEC', 'MMPY', 'THE ORDER'//CHARN//
C                  *   ' OF THE MATRIX EXCEEDS ITS ROW DIMENSION OF'//
C                  *   CHARL, 3, 1)
C
C             THERE ARE TWO SUBTLETIES WORTH MENTIONING.  ONE IS THAT
C             THE // FOR CHARACTER CATENATION IS USED TO CONSTRUCT THE
C             ERROR MESSAGE SO THAT NO SINGLE CHARACTER CONSTANT IS
C             CONTINUED TO THE NEXT LINE.  THIS AVOIDS CONFUSION AS TO
C             WHETHER THERE ARE TRAILING BLANKS AT THE END OF THE LINE.
C             THE SECOND IS THAT BY CATENATING THE PARTS OF THE MESSAGE
C             AS AN ACTUAL ARGUMENT RATHER THAN ENCODING THE ENTIRE
C             MESSAGE INTO ONE LARGE CHARACTER VARIABLE, WE AVOID
C             HAVING TO KNOW HOW LONG THE MESSAGE WILL BE IN ORDER TO
C             DECLARE AN ADEQUATE LENGTH FOR THAT LARGE CHARACTER
C             VARIABLE.  XERMSG CALLS XERPRN TO PRINT THE MESSAGE USING
C             MULTIPLE LINES IF NECESSARY.  IF THE MESSAGE IS VERY LONG,
C             XERPRN WILL BREAK IT INTO PIECES OF 72 CHARACTERS (AS
C             REQUESTED BY XERMSG) FOR PRINTING ON MULTIPLE LINES.
C             ALSO, XERMSG ASKS XERPRN TO PREFIX EACH LINE WITH ' *  '
C             SO THAT THE TOTAL LINE LENGTH COULD BE 76 CHARACTERS.
C             NOTE ALSO THAT XERPRN SCANS THE ERROR MESSAGE BACKWARDS
C             TO IGNORE TRAILING BLANKS.  ANOTHER FEATURE IS THAT
C             THE SUBSTRING '$$' IS TREATED AS A NEW LINE SENTINEL
C             BY XERPRN.  IF YOU WANT TO CONSTRUCT A MULTILINE
C             MESSAGE WITHOUT HAVING TO COUNT OUT MULTIPLES OF 72
C             CHARACTERS, JUST USE '$$' AS A SEPARATOR.  '$$'
C             OBVIOUSLY MUST OCCUR WITHIN 72 CHARACTERS OF THE
C             START OF EACH LINE TO HAVE ITS INTENDED EFFECT SINCE
C             XERPRN IS ASKED TO WRAP AROUND AT 72 CHARACTERS IN
C             ADDITION TO LOOKING FOR '$$'.
C
C    NERR     AN INTEGER VALUE THAT IS CHOSEN BY THE LIBRARY ROUTINE'S
C             AUTHOR.  IT MUST BE IN THE RANGE -99 TO 999 (THREE
C             PRINTABLE DIGITS).  EACH DISTINCT ERROR SHOULD HAVE ITS
C             OWN ERROR NUMBER.  THESE ERROR NUMBERS SHOULD BE DESCRIBED
C             IN THE MACHINE READABLE DOCUMENTATION FOR THE ROUTINE.
C             THE ERROR NUMBERS NEED BE UNIQUE ONLY WITHIN EACH ROUTINE,
C             SO IT IS REASONABLE FOR EACH ROUTINE TO START ENUMERATING
C             ERRORS FROM 1 AND PROCEEDING TO THE NEXT INTEGER.
C
C    LEVEL    AN INTEGER VALUE IN THE RANGE 0 TO 2 THAT INDICATES THE
C             LEVEL (SEVERITY) OF THE ERROR.  THEIR MEANINGS ARE
C
C            -1  A WARNING MESSAGE.  THIS IS USED IF IT IS NOT CLEAR
C                THAT THERE REALLY IS AN ERROR, BUT THE USER'S ATTENTION
C                MAY BE NEEDED.  AN ATTEMPT IS MADE TO ONLY PRINT THIS
C                MESSAGE ONCE.
C
C             0  A WARNING MESSAGE.  THIS IS USED IF IT IS NOT CLEAR
C                THAT THERE REALLY IS AN ERROR, BUT THE USER'S ATTENTION
C                MAY BE NEEDED.
C
C             1  A RECOVERABLE ERROR.  THIS IS USED EVEN IF THE ERROR IS
C                SO SERIOUS THAT THE ROUTINE CANNOT RETURN ANY USEFUL
C                ANSWER.  IF THE USER HAS TOLD THE ERROR PACKAGE TO
C                RETURN AFTER RECOVERABLE ERRORS, THEN XERMSG WILL
C                RETURN TO THE LIBRARY ROUTINE WHICH CAN THEN RETURN TO
C                THE USER'S ROUTINE.  THE USER MAY ALSO PERMIT THE ERROR
C                PACKAGE TO TERMINATE THE PROGRAM UPON ENCOUNTERING A
C                RECOVERABLE ERROR.
C
C             2  A FATAL ERROR.  XERMSG WILL NOT RETURN TO ITS CALLER
C                AFTER IT RECEIVES A FATAL ERROR.  THIS LEVEL SHOULD
C                HARDLY EVER BE USED; IT IS MUCH BETTER TO ALLOW THE
C                USER A CHANCE TO RECOVER.  AN EXAMPLE OF ONE OF THE FEW
C                CASES IN WHICH IT IS PERMISSIBLE TO DECLARE A LEVEL 2
C                ERROR IS A REVERSE COMMUNICATION LIBRARY ROUTINE THAT
C                IS LIKELY TO BE CALLED REPEATEDLY UNTIL IT INTEGRATES
C                ACROSS SOME INTERVAL.  IF THERE IS A SERIOUS ERROR IN
C                THE INPUT SUCH THAT ANOTHER STEP CANNOT BE TAKEN AND
C                THE LIBRARY ROUTINE IS CALLED AGAIN WITHOUT THE INPUT
C                ERROR HAVING BEEN CORRECTED BY THE CALLER, THE LIBRARY
C                ROUTINE WILL PROBABLY BE CALLED FOREVER WITH IMPROPER
C                INPUT.  IN THIS CASE, IT IS REASONABLE TO DECLARE THE
C                ERROR TO BE FATAL.
C
C    EACH OF THE ARGUMENTS TO XERMSG IS INPUT; NONE WILL BE MODIFIED BY
C    XERMSG.  A ROUTINE MAY MAKE MULTIPLE CALLS TO XERMSG WITH WARNING
C    LEVEL MESSAGES; HOWEVER, AFTER A CALL TO XERMSG WITH A RECOVERABLE
C    ERROR, THE ROUTINE SHOULD RETURN TO THE USER.  DO NOT TRY TO CALL
C    XERMSG WITH A SECOND RECOVERABLE ERROR AFTER THE FIRST RECOVERABLE
C    ERROR BECAUSE THE ERROR PACKAGE SAVES THE ERROR NUMBER.  THE USER
C    CAN RETRIEVE THIS ERROR NUMBER BY CALLING ANOTHER ENTRY POINT IN
C    THE ERROR HANDLING PACKAGE AND THEN CLEAR THE ERROR NUMBER WHEN
C    RECOVERING FROM THE ERROR.  CALLING XERMSG IN SUCCESSION CAUSES THE
C    OLD ERROR NUMBER TO BE OVERWRITTEN BY THE LATEST ERROR NUMBER.
C    THIS IS CONSIDERED HARMLESS FOR ERROR NUMBERS ASSOCIATED WITH
C    WARNING MESSAGES BUT MUST NOT BE DONE FOR ERROR NUMBERS OF SERIOUS
C    ERRORS.  AFTER A CALL TO XERMSG WITH A RECOVERABLE ERROR, THE USER
C    MUST BE GIVEN A CHANCE TO CALL NUMXER OR XERCLR TO RETRIEVE OR
C    CLEAR THE ERROR NUMBER.
C***REFERENCES  R. E. JONES AND D. K. KAHANER, XERROR, THE SLATEC
C                 ERROR-HANDLING PACKAGE, SAND82-0800, SANDIA
C                 LABORATORIES, 1982.
C***ROUTINES CALLED  FDUMP, J4SAVE, XERCNT, XERHLT, XERPRN, XERSVE
C***REVISION HISTORY  (YYMMDD)
C   880101  DATE WRITTEN
C   880621  REVISED AS DIRECTED AT SLATEC CML MEETING OF FEBRUARY 1988.
C           THERE ARE TWO BASIC CHANGES.
C           1.  A NEW ROUTINE, XERPRN, IS USED INSTEAD OF XERPRT TO
C               PRINT MESSAGES.  THIS ROUTINE WILL BREAK LONG MESSAGES
C               INTO PIECES FOR PRINTING ON MULTIPLE LINES.  '$$' IS
C               ACCEPTED AS A NEW LINE SENTINEL.  A PREFIX CAN BE
C               ADDED TO EACH LINE TO BE PRINTED.  XERMSG USES EITHER
C               ' ***' OR ' *  ' AND LONG MESSAGES ARE BROKEN EVERY
C               72 CHARACTERS (AT MOST) SO THAT THE MAXIMUM LINE
C               LENGTH OUTPUT CAN NOW BE AS GREAT AS 76.
C           2.  THE TEXT OF ALL MESSAGES IS NOW IN UPPER CASE SINCE THE
C               FORTRAN STANDARD DOCUMENT DOES NOT ADMIT THE EXISTENCE
C               OF LOWER CASE.
C   880708  REVISED AFTER THE SLATEC CML MEETING OF JUNE 29 AND 30.
C           THE PRINCIPAL CHANGES ARE
C           1.  CLARIFY COMMENTS IN THE PROLOGUES
C           2.  RENAME XRPRNT TO XERPRN
C           3.  REWORK HANDLING OF '$$' IN XERPRN TO HANDLE BLANK LINES
C               SIMILAR TO THE WAY FORMAT STATEMENTS HANDLE THE /
C               CHARACTER FOR NEW RECORDS.
C   890706  REVISED WITH THE HELP OF FRED FRITSCH AND REG CLEMENS TO
C           CLEAN UP THE CODING.
C   890721  REVISED TO USE NEW FEATURE IN XERPRN TO COUNT CHARACTERS IN
C           PREFIX.
C   891013  REVISED TO CORRECT COMMENTS.
C   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (WRB)
C   900510  CHANGED TEST ON NERR TO BE -9999999 < NERR < 99999999, BUT
C           NERR .NE. 0, AND ON LEVEL TO BE -2 < LEVEL < 3.  ADDED
C           LEVEL=-1 LOGIC, CHANGED CALLS TO XERSAV TO XERSVE, AND
C           XERCTL TO XERCNT.  (RWC)
C   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
C***END PROLOGUE  XERMSG
      CHARACTER*(*) LIBRAR, SUBROU, MESSG
      CHARACTER*8 XLIBR, XSUBR
      CHARACTER*72  TEMP
      CHARACTER*20  LFIRST
C***FIRST EXECUTABLE STATEMENT  XERMSG
      LKNTRL = J4SAVE (2, 0, .FALSE.)
      MAXMES = J4SAVE (4, 0, .FALSE.)
C
C       LKNTRL IS A LOCAL COPY OF THE CONTROL FLAG KONTRL.
C       MAXMES IS THE MAXIMUM NUMBER OF TIMES ANY PARTICULAR MESSAGE
C          SHOULD BE PRINTED.
C
C       WE PRINT A FATAL ERROR MESSAGE AND TERMINATE FOR AN ERROR IN
C          CALLING XERMSG.  THE ERROR NUMBER SHOULD BE POSITIVE,
C          AND THE LEVEL SHOULD BE BETWEEN 0 AND 2.
C
      IF(NERR.LT.-9999999 .OR. NERR.GT.99999999 .OR. NERR.EQ.0 .OR.
     *   LEVEL.LT.-1 .OR. LEVEL.GT.2) THEN
         CALL XERPRN (' ***', -1, 'FATAL ERROR IN...$$ ' //
     *      'XERMSG -- INVALID ERROR NUMBER OR LEVEL$$ '//
     *      'JOB ABORT DUE TO FATAL ERROR.', 72)
         CALL XERSVE (' ', ' ', ' ', 0, 0, 0, KDUMMY)
         CALL XERHLT (' ***XERMSG -- INVALID INPUT')
         RETURN
      ENDIF
C
C       RECORD THE MESSAGE.
C
      I = J4SAVE (1, NERR, .TRUE.)
      CALL XERSVE (LIBRAR, SUBROU, MESSG, 1, NERR, LEVEL, KOUNT)
C
C       HANDLE PRINT-ONCE WARNING MESSAGES.
C
      IF(LEVEL.EQ.-1 .AND. KOUNT.GT.1) RETURN
C
C       ALLOW TEMPORARY USER OVERRIDE OF THE CONTROL FLAG.
C
      XLIBR  = LIBRAR
      XSUBR  = SUBROU
      LFIRST = MESSG
      LERR   = NERR
      LLEVEL = LEVEL
      CALL XERCNT (XLIBR, XSUBR, LFIRST, LERR, LLEVEL, LKNTRL)
C
      LKNTRL = MAX(-2, MIN(2,LKNTRL))
      MKNTRL = ABS(LKNTRL)
C
C       SKIP PRINTING IF THE CONTROL FLAG VALUE AS RESET IN XERCNT IS
C       ZERO AND THE ERROR IS NOT FATAL.
C
      IF(LEVEL.LT.2 .AND. LKNTRL.EQ.0) GO TO 30
      IF(LEVEL.EQ.0 .AND. KOUNT.GT.MAXMES) GO TO 30
      IF(LEVEL.EQ.1 .AND. KOUNT.GT.MAXMES .AND. MKNTRL.EQ.1) GO TO 30
      IF(LEVEL.EQ.2 .AND. KOUNT.GT.MAX(1,MAXMES)) GO TO 30
C
C       ANNOUNCE THE NAMES OF THE LIBRARY AND SUBROUTINE BY BUILDING A
C       MESSAGE IN CHARACTER VARIABLE TEMP (NOT EXCEEDING 66 CHARACTERS)
C       AND SENDING IT OUT VIA XERPRN.  PRINT ONLY IF CONTROL FLAG
C       IS NOT ZERO.
C
      IF(LKNTRL .NE. 0) THEN
         TEMP(1:21) = 'MESSAGE FROM ROUTINE '
         I = MIN(LEN(SUBROU), 16)
         TEMP(22:21+I) = SUBROU(1:I)
         TEMP(22+I:33+I) = ' IN LIBRARY '
         LTEMP = 33 + I
         I = MIN(LEN(LIBRAR), 16)
         TEMP(LTEMP+1:LTEMP+I) = LIBRAR (1:I)
         TEMP(LTEMP+I+1:LTEMP+I+1) = '.'
         LTEMP = LTEMP + I + 1
         CALL XERPRN (' ***', -1, TEMP(1:LTEMP), 72)
      ENDIF
C
C       IF LKNTRL IS POSITIVE, PRINT AN INTRODUCTORY LINE BEFORE
C       PRINTING THE MESSAGE.  THE INTRODUCTORY LINE TELLS THE CHOICE
C       FROM EACH OF THE FOLLOWING THREE OPTIONS.
C       1.  LEVEL OF THE MESSAGE
C              'INFORMATIVE MESSAGE'
C              'POTENTIALLY RECOVERABLE ERROR'
C              'FATAL ERROR'
C       2.  WHETHER CONTROL FLAG WILL ALLOW PROGRAM TO CONTINUE
C              'PROG CONTINUES'
C              'PROG ABORTED'
C       3.  WHETHER OR NOT A TRACEBACK WAS REQUESTED.  (THE TRACEBACK
C           MAY NOT BE IMPLEMENTED AT SOME SITES, SO THIS ONLY TELLS
C           WHAT WAS REQUESTED, NOT WHAT WAS DELIVERED.)
C              'TRACEBACK REQUESTED'
C              'TRACEBACK NOT REQUESTED'
C       NOTICE THAT THE LINE INCLUDING FOUR PREFIX CHARACTERS WILL NOT
C       EXCEED 74 CHARACTERS.
C       WE SKIP THE NEXT BLOCK IF THE INTRODUCTORY LINE IS NOT NEEDED.
C
      IF(LKNTRL .GT. 0) THEN
C
C       THE FIRST PART OF THE MESSAGE TELLS ABOUT THE LEVEL.
C
         IF(LEVEL .LE. 0) THEN
            TEMP(1:20) = 'INFORMATIVE MESSAGE,'
            LTEMP = 20
         ELSEIF(LEVEL .EQ. 1) THEN
            TEMP(1:30) = 'POTENTIALLY RECOVERABLE ERROR,'
            LTEMP = 30
         ELSE
            TEMP(1:12) = 'FATAL ERROR,'
            LTEMP = 12
         ENDIF
C
C       THEN WHETHER THE PROGRAM WILL CONTINUE.
C
         IF((MKNTRL.EQ.2 .AND. LEVEL.GE.1) .OR.
     *       (MKNTRL.EQ.1 .AND. LEVEL.EQ.2)) THEN
            TEMP(LTEMP+1:LTEMP+14) = ' PROG ABORTED,'
            LTEMP = LTEMP + 14
         ELSE
            TEMP(LTEMP+1:LTEMP+16) = ' PROG CONTINUES,'
            LTEMP = LTEMP + 16
         ENDIF
C
C       FINALLY TELL WHETHER THERE SHOULD BE A TRACEBACK.
C
         IF(LKNTRL .GT. 0) THEN
            TEMP(LTEMP+1:LTEMP+20) = ' TRACEBACK REQUESTED'
            LTEMP = LTEMP + 20
         ELSE
            TEMP(LTEMP+1:LTEMP+24) = ' TRACEBACK NOT REQUESTED'
            LTEMP = LTEMP + 24
         ENDIF
         CALL XERPRN (' ***', -1, TEMP(1:LTEMP), 72)
      ENDIF
C
C       NOW SEND OUT THE MESSAGE.
C
      CALL XERPRN (' *  ', -1, MESSG, 72)
C
C       IF LKNTRL IS POSITIVE, WRITE THE ERROR NUMBER AND REQUEST A
C          TRACEBACK.
C
      IF(LKNTRL .GT. 0) THEN
         WRITE(TEMP, '(''ERROR NUMBER = '', I8)') NERR
         DO 10 I=16,22
            IF(TEMP(I:I) .NE. ' ') GO TO 20
   10    CONTINUE
C
   20    CALL XERPRN (' *  ', -1, TEMP(1:15) // TEMP(I:23), 72)
         CALL FDUMP
      ENDIF
C
C       IF LKNTRL IS NOT ZERO, PRINT A BLANK LINE AND AN END OF MESSAGE.
C
      IF(LKNTRL .NE. 0) THEN
         CALL XERPRN (' *  ', -1, ' ', 72)
         CALL XERPRN (' ***', -1, 'END OF MESSAGE', 72)
         CALL XERPRN ('    ',  0, ' ', 72)
      ENDIF
C
C       IF THE ERROR IS NOT FATAL OR THE ERROR IS RECOVERABLE AND THE
C       CONTROL FLAG IS SET FOR RECOVERY, THEN RETURN.
C
   30 IF(LEVEL.LE.0 .OR. (LEVEL.EQ.1 .AND. MKNTRL.LE.1)) RETURN
C
C       THE PROGRAM WILL BE STOPPED DUE TO AN UNRECOVERED ERROR OR A
C       FATAL ERROR.  PRINT THE REASON FOR THE ABORT AND THE ERROR
C       SUMMARY IF THE CONTROL FLAG AND THE MAXIMUM ERROR COUNT PERMIT.
C
      IF(LKNTRL.GT.0 .AND. KOUNT.LT.MAX(1,MAXMES)) THEN
         IF(LEVEL .EQ. 1) THEN
            CALL XERPRN
     *         (' ***', -1, 'JOB ABORT DUE TO UNRECOVERED ERROR.', 72)
         ELSE
            CALL XERPRN(' ***', -1, 'JOB ABORT DUE TO FATAL ERROR.', 72)
         ENDIF
         CALL XERSVE (' ', ' ', ' ', -1, 0, 0, KDUMMY)
         write(*,*) 'calling halt of ddassl line 2736'
         CALL XERHLT (' ')
         
      ELSE
         CALL XERHLT (MESSG)
      ENDIF
      RETURN
      END
C
C#######################################################################
C
C                       X   E   R   P   R   N
C
C#######################################################################
C
*DECK XERPRN
      SUBROUTINE XERPRN (PREFIX, NPREF, MESSG, NWRAP)
C***BEGIN PROLOGUE  XERPRN
C***SUBSIDIARY
C***PURPOSE  PRINT ERROR MESSAGES PROCESSED BY XERMSG.
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3C
C***TYPE      ALL (XERPRN-A)
C***KEYWORDS  ERROR MESSAGES, PRINTING, XERROR
C***AUTHOR  FONG, KIRBY, (NMFECC AT LLNL)
C***DESCRIPTION
C
C THIS ROUTINE SENDS ONE OR MORE LINES TO EACH OF THE (UP TO FIVE)
C LOGICAL UNITS TO WHICH ERROR MESSAGES ARE TO BE SENT.  THIS ROUTINE
C IS CALLED SEVERAL TIMES BY XERMSG, SOMETIMES WITH A SINGLE LINE TO
C PRINT AND SOMETIMES WITH A (POTENTIALLY VERY LONG) MESSAGE THAT MAY
C WRAP AROUND INTO MULTIPLE LINES.
C
C PREFIX  INPUT ARGUMENT OF TYPE CHARACTER.  THIS ARGUMENT CONTAINS
C         CHARACTERS TO BE PUT AT THE BEGINNING OF EACH LINE BEFORE
C         THE BODY OF THE MESSAGE.  NO MORE THAN 16 CHARACTERS OF
C         PREFIX WILL BE USED.
C
C NPREF   INPUT ARGUMENT OF TYPE INTEGER.  THIS ARGUMENT IS THE NUMBER
C         OF CHARACTERS TO USE FROM PREFIX.  IF IT IS NEGATIVE, THE
C         INTRINSIC FUNCTION LEN IS USED TO DETERMINE ITS LENGTH.  IF
C         IT IS ZERO, PREFIX IS NOT USED.  IF IT EXCEEDS 16 OR IF
C         LEN(PREFIX) EXCEEDS 16, ONLY THE FIRST 16 CHARACTERS WILL BE
C         USED.  IF NPREF IS POSITIVE AND THE LENGTH OF PREFIX IS LESS
C         THAN NPREF, A COPY OF PREFIX EXTENDED WITH BLANKS TO LENGTH
C         NPREF WILL BE USED.
C
C MESSG   INPUT ARGUMENT OF TYPE CHARACTER.  THIS IS THE TEXT OF A
C         MESSAGE TO BE PRINTED.  IF IT IS A LONG MESSAGE, IT WILL BE
C         BROKEN INTO PIECES FOR PRINTING ON MULTIPLE LINES.  EACH LINE
C         WILL START WITH THE APPROPRIATE PREFIX AND BE FOLLOWED BY A
C         PIECE OF THE MESSAGE.  NWRAP IS THE NUMBER OF CHARACTERS PER
C         PIECE; THAT IS, AFTER EACH NWRAP CHARACTERS, WE BREAK AND
C         START A NEW LINE.  IN ADDITION THE CHARACTERS '$$' EMBEDDED
C         IN MESSG ARE A SENTINEL FOR A NEW LINE.  THE COUNTING OF
C         CHARACTERS UP TO NWRAP STARTS OVER FOR EACH NEW LINE.  THE
C         VALUE OF NWRAP TYPICALLY USED BY XERMSG IS 72 SINCE MANY
C         OLDER ERROR MESSAGES IN THE SLATEC LIBRARY ARE LAID OUT TO
C         RELY ON WRAP-AROUND EVERY 72 CHARACTERS.
C
C NWRAP   INPUT ARGUMENT OF TYPE INTEGER.  THIS GIVES THE MAXIMUM SIZE
C         PIECE INTO WHICH TO BREAK MESSG FOR PRINTING ON MULTIPLE
C         LINES.  AN EMBEDDED '$$' ENDS A LINE, AND THE COUNT RESTARTS
C         AT THE FOLLOWING CHARACTER.  IF A LINE BREAK DOES NOT OCCUR
C         ON A BLANK (IT WOULD SPLIT A WORD) THAT WORD IS MOVED TO THE
C         NEXT LINE.  VALUES OF NWRAP LESS THAN 16 WILL BE TREATED AS
C         16.  VALUES OF NWRAP GREATER THAN 132 WILL BE TREATED AS 132.
C         THE ACTUAL LINE LENGTH WILL BE NPREF + NWRAP AFTER NPREF HAS
C         BEEN ADJUSTED TO FALL BETWEEN 0 AND 16 AND NWRAP HAS BEEN
C         ADJUSTED TO FALL BETWEEN 16 AND 132.
C
C***REFERENCES  R. E. JONES AND D. K. KAHANER, XERROR, THE SLATEC
C                 ERROR-HANDLING PACKAGE, SAND82-0800, SANDIA
C                 LABORATORIES, 1982.
C***ROUTINES CALLED  I1MACH, XGETUA
C***REVISION HISTORY  (YYMMDD)
C   880621  DATE WRITTEN
C   880708  REVISED AFTER THE SLATEC CML SUBCOMMITTEE MEETING OF
C           JUNE 29 AND 30 TO CHANGE THE NAME TO XERPRN AND TO REWORK
C           THE HANDLING OF THE NEW LINE SENTINEL TO BEHAVE LIKE THE
C           SLASH CHARACTER IN FORMAT STATEMENTS.
C   890706  REVISED WITH THE HELP OF FRED FRITSCH AND REG CLEMENS TO
C           STREAMLINE THE CODING AND FIX A BUG THAT CAUSED EXTRA BLANK
C           LINES TO BE PRINTED.
C   890721  REVISED TO ADD A NEW FEATURE.  A NEGATIVE VALUE OF NPREF
C           CAUSES LEN(PREFIX) TO BE USED AS THE LENGTH.
C   891013  REVISED TO CORRECT ERROR IN CALCULATING PREFIX LENGTH.
C   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (WRB)
C   900510  ADDED CODE TO BREAK MESSAGES BETWEEN WORDS.  (RWC)
C   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
C***END PROLOGUE  XERPRN
      CHARACTER*(*) PREFIX, MESSG
      INTEGER NPREF, NWRAP
      CHARACTER*148 CBUFF
      INTEGER IU(5), NUNIT
      CHARACTER*2 NEWLIN
      PARAMETER (NEWLIN = '$$')
C***FIRST EXECUTABLE STATEMENT  XERPRN
      CALL XGETUA(IU,NUNIT)
C
C       A ZERO VALUE FOR A LOGICAL UNIT NUMBER MEANS TO USE THE STANDARD
C       ERROR MESSAGE UNIT INSTEAD.  I1MACH(4) RETRIEVES THE STANDARD
C       ERROR MESSAGE UNIT.
C
      N = I1MACH(4)
      DO 10 I=1,NUNIT
         IF(IU(I) .EQ. 0) IU(I) = N
   10 CONTINUE
C
C       LPREF IS THE LENGTH OF THE PREFIX.  THE PREFIX IS PLACED AT THE
C       BEGINNING OF CBUFF, THE CHARACTER BUFFER, AND KEPT THERE DURING
C       THE REST OF THIS ROUTINE.
C
      IF( NPREF .LT. 0 ) THEN
         LPREF = LEN(PREFIX)
      ELSE
         LPREF = NPREF
      ENDIF
      LPREF = MIN(16, LPREF)
      IF(LPREF .NE. 0) CBUFF(1:LPREF) = PREFIX
C
C       LWRAP IS THE MAXIMUM NUMBER OF CHARACTERS WE WANT TO TAKE AT ONE
C       TIME FROM MESSG TO PRINT ON ONE LINE.
C
      LWRAP = MAX(16, MIN(132, NWRAP))
C
C       SET LENMSG TO THE LENGTH OF MESSG, IGNORE ANY TRAILING BLANKS.
C
      LENMSG = LEN(MESSG)
      N = LENMSG
      DO 20 I=1,N
         IF(MESSG(LENMSG:LENMSG) .NE. ' ') GO TO 30
         LENMSG = LENMSG - 1
   20 CONTINUE
   30 CONTINUE
C
C       IF THE MESSAGE IS ALL BLANKS, THEN PRINT ONE BLANK LINE.
C
      IF(LENMSG .EQ. 0) THEN
         CBUFF(LPREF+1:LPREF+1) = ' '
         DO 40 I=1,NUNIT
            WRITE(IU(I), '(A)') CBUFF(1:LPREF+1)
   40    CONTINUE
         RETURN
      ENDIF
C
C       SET NEXTC TO THE POSITION IN MESSG WHERE THE NEXT SUBSTRING
C       STARTS.  FROM THIS POSITION WE SCAN FOR THE NEW LINE SENTINEL.
C       WHEN NEXTC EXCEEDS LENMSG, THERE IS NO MORE TO PRINT.
C       WE LOOP BACK TO LABEL 50 UNTIL ALL PIECES HAVE BEEN PRINTED.
C
C       WE LOOK FOR THE NEXT OCCURRENCE OF THE NEW LINE SENTINEL.  THE
C       INDEX INTRINSIC FUNCTION RETURNS ZERO IF THERE IS NO OCCURRENCE
C       OR IF THE LENGTH OF THE FIRST ARGUMENT IS LESS THAN THE LENGTH
C       OF THE SECOND ARGUMENT.
C
C       THERE ARE SEVERAL CASES WHICH SHOULD BE CHECKED FOR IN THE
C       FOLLOWING ORDER.  WE ARE ATTEMPTING TO SET LPIECE TO THE NUMBER
C       OF CHARACTERS THAT SHOULD BE TAKEN FROM MESSG STARTING AT
C       POSITION NEXTC.
C
C       LPIECE .EQ. 0   THE NEW LINE SENTINEL DOES NOT OCCUR IN THE
C                       REMAINDER OF THE CHARACTER STRING.  LPIECE
C                       SHOULD BE SET TO LWRAP OR LENMSG+1-NEXTC,
C                       WHICHEVER IS LESS.
C
C       LPIECE .EQ. 1   THE NEW LINE SENTINEL STARTS AT MESSG(NEXTC:
C                       NEXTC).  LPIECE IS EFFECTIVELY ZERO, AND WE
C                       PRINT NOTHING TO AVOID PRODUCING UNNECESSARY
C                       BLANK LINES.  THIS TAKES CARE OF THE SITUATION
C                       WHERE THE LIBRARY ROUTINE HAS A MESSAGE OF
C                       EXACTLY 72 CHARACTERS FOLLOWED BY A NEW LINE
C                       SENTINEL FOLLOWED BY MORE CHARACTERS.  NEXTC
C                       SHOULD BE INCREMENTED BY 2.
C
C       LPIECE .GT. LWRAP+1  REDUCE LPIECE TO LWRAP.
C
C       ELSE            THIS LAST CASE MEANS 2 .LE. LPIECE .LE. LWRAP+1
C                       RESET LPIECE = LPIECE-1.  NOTE THAT THIS
C                       PROPERLY HANDLES THE END CASE WHERE LPIECE .EQ.
C                       LWRAP+1.  THAT IS, THE SENTINEL FALLS EXACTLY
C                       AT THE END OF A LINE.
C
      NEXTC = 1
   50 LPIECE = INDEX(MESSG(NEXTC:LENMSG), NEWLIN)
      IF(LPIECE .EQ. 0) THEN
C
C       THERE WAS NO NEW LINE SENTINEL FOUND.
C
         IDELTA = 0
         LPIECE = MIN(LWRAP, LENMSG+1-NEXTC)
         IF(LPIECE .LT. LENMSG+1-NEXTC) THEN
            DO 52 I=LPIECE+1,2,-1
               IF(MESSG(NEXTC+I-1:NEXTC+I-1) .EQ. ' ') THEN
                  LPIECE = I-1
                  IDELTA = 1
                  GOTO 54
               ENDIF
   52       CONTINUE
         ENDIF
   54    CBUFF(LPREF+1:LPREF+LPIECE) = MESSG(NEXTC:NEXTC+LPIECE-1)
         NEXTC = NEXTC + LPIECE + IDELTA
      ELSEIF(LPIECE .EQ. 1) THEN
C
C       WE HAVE A NEW LINE SENTINEL AT MESSG(NEXTC:NEXTC+1).
C       DON'T PRINT A BLANK LINE.
C
         NEXTC = NEXTC + 2
         GO TO 50
      ELSEIF(LPIECE .GT. LWRAP+1) THEN
C
C       LPIECE SHOULD BE SET DOWN TO LWRAP.
C
         IDELTA = 0
         LPIECE = LWRAP
         DO 56 I=LPIECE+1,2,-1
            IF(MESSG(NEXTC+I-1:NEXTC+I-1) .EQ. ' ') THEN
               LPIECE = I-1
               IDELTA = 1
               GOTO 58
            ENDIF
   56    CONTINUE
   58    CBUFF(LPREF+1:LPREF+LPIECE) = MESSG(NEXTC:NEXTC+LPIECE-1)
         NEXTC = NEXTC + LPIECE + IDELTA
      ELSE
C
C       IF WE ARRIVE HERE, IT MEANS 2 .LE. LPIECE .LE. LWRAP+1.
C       WE SHOULD DECREMENT LPIECE BY ONE.
C
         LPIECE = LPIECE - 1
         CBUFF(LPREF+1:LPREF+LPIECE) = MESSG(NEXTC:NEXTC+LPIECE-1)
         NEXTC  = NEXTC + LPIECE + 2
      ENDIF
C
C       PRINT
C
      DO 60 I=1,NUNIT
         WRITE(IU(I), '(A)') CBUFF(1:LPREF+LPIECE)
   60 CONTINUE
C
      IF(NEXTC .LE. LENMSG) GO TO 50
      RETURN
      END
*DECK XERSVE
C
C#######################################################################
C
C                       X   E   R   S   V   E
C
C#######################################################################
C
      SUBROUTINE XERSVE (LIBRAR, SUBROU, MESSG, KFLAG, NERR, LEVEL,
     +   ICOUNT)
C***BEGIN PROLOGUE  XERSVE
C***SUBSIDIARY
C***PURPOSE  RECORD THAT AN ERROR HAS OCCURRED.
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3
C***TYPE      ALL (XERSVE-A)
C***KEYWORDS  ERROR, XERROR
C***AUTHOR  JONES, R. E., (SNLA)
C***DESCRIPTION
C
C *USAGE:
C
C        INTEGER  KFLAG, NERR, LEVEL, ICOUNT
C        CHARACTER * (LEN) LIBRAR, SUBROU, MESSG
C
C        CALL XERSVE (LIBRAR, SUBROU, MESSG, KFLAG, NERR, LEVEL, ICOUNT)
C
C *ARGUMENTS:
C
C        LIBRAR :IN    IS THE LIBRARY THAT THE MESSAGE IS FROM.
C        SUBROU :IN    IS THE SUBROUTINE THAT THE MESSAGE IS FROM.
C        MESSG  :IN    IS THE MESSAGE TO BE SAVED.
C        KFLAG  :IN    INDICATES THE ACTION TO BE PERFORMED.
C                      WHEN KFLAG > 0, THE MESSAGE IN MESSG IS SAVED.
C                      WHEN KFLAG=0 THE TABLES WILL BE DUMPED AND
C                      CLEARED.
C                      WHEN KFLAG < 0, THE TABLES WILL BE DUMPED AND
C                      NOT CLEARED.
C        NERR   :IN    IS THE ERROR NUMBER.
C        LEVEL  :IN    IS THE ERROR SEVERITY.
C        ICOUNT :OUT   THE NUMBER OF TIMES THIS MESSAGE HAS BEEN SEEN,
C                      OR ZERO IF THE TABLE HAS OVERFLOWED AND DOES NOT
C                      CONTAIN THIS MESSAGE SPECIFICALLY.  WHEN KFLAG=0,
C                      ICOUNT WILL NOT BE ALTERED.
C
C *DESCRIPTION:
C
C   RECORD THAT THIS ERROR OCCURRED AND POSSIBLY DUMP AND CLEAR THE
C   TABLES.
C
C***REFERENCES  R. E. JONES AND D. K. KAHANER, XERROR, THE SLATEC
C                 ERROR-HANDLING PACKAGE, SAND82-0800, SANDIA
C                 LABORATORIES, 1982.
C***ROUTINES CALLED  I1MACH, XGETUA
C***REVISION HISTORY  (YYMMDD)
C   800319  DATE WRITTEN
C   861211  REVISION DATE FROM VERSION 3.2
C   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
C   900413  ROUTINE MODIFIED TO REMOVE REFERENCE TO KFLAG.  (WRB)
C   900510  CHANGED TO ADD LIBRARY NAME AND SUBROUTINE TO CALLING
C           SEQUENCE, USE IF-THEN-ELSE, MAKE NUMBER OF SAVED ENTRIES
C           EASILY CHANGEABLE, CHANGED ROUTINE NAME FROM XERSAV TO
C           XERSVE.  (RWC)
C   910626  ADDED LIBTAB AND SUBTAB TO SAVE STATEMENT.  (BKS)
C   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
C***END PROLOGUE  XERSVE
      PARAMETER (LENTAB=10)
      INTEGER LUN(5)
      CHARACTER*(*) LIBRAR, SUBROU, MESSG
      CHARACTER*8  LIBTAB(LENTAB), SUBTAB(LENTAB), LIB, SUB
      CHARACTER*20 MESTAB(LENTAB), MES
      DIMENSION NERTAB(LENTAB), LEVTAB(LENTAB), KOUNT(LENTAB)
      SAVE LIBTAB, SUBTAB, MESTAB, NERTAB, LEVTAB, KOUNT, KOUNTX, NMSG
      DATA KOUNTX/0/, NMSG/0/
C***FIRST EXECUTABLE STATEMENT  XERSVE
C
      IF(KFLAG.LE.0) THEN
C
C        DUMP THE TABLE.
C
         IF(NMSG.EQ.0) RETURN
C
C        PRINT TO EACH UNIT.
C
         CALL XGETUA (LUN, NUNIT)
         DO 20 KUNIT = 1,NUNIT
            IUNIT = LUN(KUNIT)
            IF(IUNIT.EQ.0) IUNIT = I1MACH(4)
C
C           PRINT THE TABLE HEADER.
C
            WRITE(IUNIT,9000)
C
C           PRINT BODY OF TABLE.
C
            DO 10 I = 1,NMSG
               WRITE(IUNIT,9010) LIBTAB(I), SUBTAB(I), MESTAB(I),
     *            NERTAB(I),LEVTAB(I),KOUNT(I)
   10       CONTINUE
C
C           PRINT NUMBER OF OTHER ERRORS.
C
            IF(KOUNTX.NE.0) WRITE(IUNIT,9020) KOUNTX
            WRITE(IUNIT,9030)
   20    CONTINUE
C
C        CLEAR THE ERROR TABLES.
C
         IF(KFLAG.EQ.0) THEN
            NMSG = 0
            KOUNTX = 0
         ENDIF
      ELSE
C
C        PROCESS A MESSAGE...
C        SEARCH FOR THIS MESSG, OR ELSE AN EMPTY SLOT FOR THIS MESSG,
C        OR ELSE DETERMINE THAT THE ERROR TABLE IS FULL.
C
         LIB = LIBRAR
         SUB = SUBROU
         MES = MESSG
         DO 30 I = 1,NMSG
            IF(LIB.EQ.LIBTAB(I) .AND. SUB.EQ.SUBTAB(I) .AND.
     *         MES.EQ.MESTAB(I) .AND. NERR.EQ.NERTAB(I) .AND.
     *         LEVEL.EQ.LEVTAB(I)) THEN
                  KOUNT(I) = KOUNT(I) + 1
                  ICOUNT = KOUNT(I)
                  RETURN
            ENDIF
   30    CONTINUE
C
         IF(NMSG.LT.LENTAB) THEN
C
C           EMPTY SLOT FOUND FOR NEW MESSAGE.
C
            NMSG = NMSG + 1
            LIBTAB(I) = LIB
            SUBTAB(I) = SUB
            MESTAB(I) = MES
            NERTAB(I) = NERR
            LEVTAB(I) = LEVEL
            KOUNT (I) = 1
            ICOUNT    = 1
         ELSE
C
C           TABLE IS FULL.
C
            KOUNTX = KOUNTX+1
            ICOUNT = 0
         ENDIF
      ENDIF
      RETURN
C
C     FORMATS.
C
 9000 FORMAT ('0          ERROR MESSAGE SUMMARY' /
     +   ' LIBRARY    SUBROUTINE MESSAGE START             NERR',
     +   '     LEVEL     COUNT')
 9010 FORMAT (1X,A,3X,A,3X,A,3I10)
 9020 FORMAT ('0OTHER ERRORS NOT INDIVIDUALLY TABULATED = ', I10)
 9030 FORMAT (1X)
      END
C
C#######################################################################
C
C                       X   G   E   T   U   A
C
C#######################################################################
C
*DECK XGETUA
      SUBROUTINE XGETUA (IUNITA, N)
C***BEGIN PROLOGUE  XGETUA
C***PURPOSE  RETURN UNIT NUMBER(S) TO WHICH ERROR MESSAGES ARE BEING
C            SENT.
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3C
C***TYPE      ALL (XGETUA-A)
C***KEYWORDS  ERROR, XERROR
C***AUTHOR  JONES, R. E., (SNLA)
C***DESCRIPTION
C
C     ABSTRACT
C        XGETUA MAY BE CALLED TO DETERMINE THE UNIT NUMBER OR NUMBERS
C        TO WHICH ERROR MESSAGES ARE BEING SENT.
C        THESE UNIT NUMBERS MAY HAVE BEEN SET BY A CALL TO XSETUN,
C        OR A CALL TO XSETUA, OR MAY BE A DEFAULT VALUE.
C
C     DESCRIPTION OF PARAMETERS
C      --OUTPUT--
C        IUNIT - AN ARRAY OF ONE TO FIVE UNIT NUMBERS, DEPENDING
C                ON THE VALUE OF N.  A VALUE OF ZERO REFERS TO THE
C                DEFAULT UNIT, AS DEFINED BY THE I1MACH MACHINE
C                CONSTANT ROUTINE.  ONLY IUNIT(1),...,IUNIT(N) ARE
C                DEFINED BY XGETUA.  THE VALUES OF IUNIT(N+1),...,
C                IUNIT(5) ARE NOT DEFINED (FOR N .LT. 5) OR ALTERED
C                IN ANY WAY BY XGETUA.
C        N     - THE NUMBER OF UNITS TO WHICH COPIES OF THE
C                ERROR MESSAGES ARE BEING SENT.  N WILL BE IN THE
C                RANGE FROM 1 TO 5.
C
C***REFERENCES  R. E. JONES AND D. K. KAHANER, XERROR, THE SLATEC
C                 ERROR-HANDLING PACKAGE, SAND82-0800, SANDIA
C                 LABORATORIES, 1982.
C***ROUTINES CALLED  J4SAVE
C***REVISION HISTORY  (YYMMDD)
C   790801  DATE WRITTEN
C   861211  REVISION DATE FROM VERSION 3.2
C   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
C   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
C***END PROLOGUE  XGETUA
      DIMENSION IUNITA(5)
C***FIRST EXECUTABLE STATEMENT  XGETUA
      N = J4SAVE(5,0,.FALSE.)
      DO 30 I=1,N
         INDEX = I+4
         IF(I.EQ.1) INDEX = 3
         IUNITA(I) = J4SAVE(INDEX,0,.FALSE.)
   30 CONTINUE
      RETURN
      END
C
C#######################################################################
C
C                       D   1   M   A   C   H   (FUNCTION) 
C
C#######################################################################
C
*DECK D1MACH
      DOUBLE PRECISION FUNCTION D1MACH(I)
      INTEGER I
C
C  DOUBLE-PRECISION MACHINE CONSTANTS
C  D1MACH( 1) = B**(EMIN-1), THE SMALLEST POSITIVE MAGNITUDE.
C  D1MACH( 2) = B**EMAX*(1 - B**(-T)), THE LARGEST MAGNITUDE.
C  D1MACH( 3) = B**(-T), THE SMALLEST RELATIVE SPACING.
C  D1MACH( 4) = B**(1-T), THE LARGEST RELATIVE SPACING.
C  D1MACH( 5) = LOG10(B)
C
      INTEGER SMALL(2)
      INTEGER LARGE(2)
      INTEGER RIGHT(2)
      INTEGER DIVER(2)
      INTEGER LOG10(2)
      INTEGER SC, CRAY1(38), J
      COMMON /D9MACH/ CRAY1
      SAVE SMALL, LARGE, RIGHT, DIVER, LOG10, SC
      DOUBLE PRECISION DMACH(5)
      EQUIVALENCE (DMACH(1),SMALL(1))
      EQUIVALENCE (DMACH(2),LARGE(1))
      EQUIVALENCE (DMACH(3),RIGHT(1))
      EQUIVALENCE (DMACH(4),DIVER(1))
      EQUIVALENCE (DMACH(5),LOG10(1))
C  THIS VERSION ADAPTS AUTOMATICALLY TO MOST CURRENT MACHINES.
C  R1MACH CAN HANDLE AUTO-DOUBLE COMPILING, BUT THIS VERSION OF
C  D1MACH DOES NOT, BECAUSE WE DO NOT HAVE QUAD CONSTANTS FOR
C  MANY MACHINES YET.
C  TO COMPILE ON OLDER MACHINES, ADD A C IN COLUMN 1
C  ON THE NEXT LINE
      DATA SC/0/
C  AND REMOVE THE C FROM COLUMN 1 IN ONE OF THE SECTIONS BELOW.
C  CONSTANTS FOR EVEN OLDER MACHINES CAN BE OBTAINED BY
C          mail netlib@research.bell-labs.com
C          send old1mach from blas
C  PLEASE SEND CORRECTIONS TO dmg OR ehg@bell-labs.com.
C
C     MACHINE CONSTANTS FOR THE HONEYWELL DPS 8/70 SERIES.
C      DATA SMALL(1),SMALL(2) / O402400000000, O000000000000 /
C      DATA LARGE(1),LARGE(2) / O376777777777, O777777777777 /
C      DATA RIGHT(1),RIGHT(2) / O604400000000, O000000000000 /
C      DATA DIVER(1),DIVER(2) / O606400000000, O000000000000 /
C      DATA LOG10(1),LOG10(2) / O776464202324, O117571775714 /, SC/987/
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRANS SUPPORTING
C     32-BIT INTEGERS.
C      DATA SMALL(1),SMALL(2) /    8388608,           0 /
C      DATA LARGE(1),LARGE(2) / 2147483647,          -1 /
C      DATA RIGHT(1),RIGHT(2) /  612368384,           0 /
C      DATA DIVER(1),DIVER(2) /  620756992,           0 /
C      DATA LOG10(1),LOG10(2) / 1067065498, -2063872008 /, SC/987/
C
C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES.
C      DATA SMALL(1),SMALL(2) / O000040000000, O000000000000 /
C      DATA LARGE(1),LARGE(2) / O377777777777, O777777777777 /
C      DATA RIGHT(1),RIGHT(2) / O170540000000, O000000000000 /
C      DATA DIVER(1),DIVER(2) / O170640000000, O000000000000 /
C      DATA LOG10(1),LOG10(2) / O177746420232, O411757177572 /, SC/987/
C
C     ON FIRST CALL, IF NO DATA UNCOMMENTED, TEST MACHINE TYPES.
      IF (SC .NE. 987) THEN
         DMACH(1) = 1.D13
         IF (      SMALL(1) .EQ. 1117925532
     *       .AND. SMALL(2) .EQ. -448790528) THEN
*           *** IEEE BIG ENDIAN ***
            SMALL(1) = 1048576
            SMALL(2) = 0
            LARGE(1) = 2146435071
            LARGE(2) = -1
            RIGHT(1) = 1017118720
            RIGHT(2) = 0
            DIVER(1) = 1018167296
            DIVER(2) = 0
            LOG10(1) = 1070810131
            LOG10(2) = 1352628735
         ELSE IF ( SMALL(2) .EQ. 1117925532
     *       .AND. SMALL(1) .EQ. -448790528) THEN
*           *** IEEE LITTLE ENDIAN ***
            SMALL(2) = 1048576
            SMALL(1) = 0
            LARGE(2) = 2146435071
            LARGE(1) = -1
            RIGHT(2) = 1017118720
            RIGHT(1) = 0
            DIVER(2) = 1018167296
            DIVER(1) = 0
            LOG10(2) = 1070810131
            LOG10(1) = 1352628735
         ELSE IF ( SMALL(1) .EQ. -2065213935
     *       .AND. SMALL(2) .EQ. 10752) THEN
*               *** VAX WITH D_FLOATING ***
            SMALL(1) = 128
            SMALL(2) = 0
            LARGE(1) = -32769
            LARGE(2) = -1
            RIGHT(1) = 9344
            RIGHT(2) = 0
            DIVER(1) = 9472
            DIVER(2) = 0
            LOG10(1) = 546979738
            LOG10(2) = -805796613
         ELSE IF ( SMALL(1) .EQ. 1267827943
     *       .AND. SMALL(2) .EQ. 704643072) THEN
*               *** IBM MAINFRAME ***
            SMALL(1) = 1048576
            SMALL(2) = 0
            LARGE(1) = 2147483647
            LARGE(2) = -1
            RIGHT(1) = 856686592
            RIGHT(2) = 0
            DIVER(1) = 873463808
            DIVER(2) = 0
            LOG10(1) = 1091781651
            LOG10(2) = 1352628735
         ELSE IF ( SMALL(1) .EQ. 1120022684
     *       .AND. SMALL(2) .EQ. -448790528) THEN
*           *** CONVEX C-1 ***
            SMALL(1) = 1048576
            SMALL(2) = 0
            LARGE(1) = 2147483647
            LARGE(2) = -1
            RIGHT(1) = 1019215872
            RIGHT(2) = 0
            DIVER(1) = 1020264448
            DIVER(2) = 0
            LOG10(1) = 1072907283
            LOG10(2) = 1352628735
         ELSE IF ( SMALL(1) .EQ. 815547074
     *       .AND. SMALL(2) .EQ. 58688) THEN
*           *** VAX G-FLOATING ***
            SMALL(1) = 16
            SMALL(2) = 0
            LARGE(1) = -32769
            LARGE(2) = -1
            RIGHT(1) = 15552
            RIGHT(2) = 0
            DIVER(1) = 15568
            DIVER(2) = 0
            LOG10(1) = 1142112243
            LOG10(2) = 2046775455
         ELSE
            DMACH(2) = 1.D27 + 1
            DMACH(3) = 1.D27
            LARGE(2) = LARGE(2) - RIGHT(2)
            IF (LARGE(2) .EQ. 64 .AND. SMALL(2) .EQ. 0) THEN
               CRAY1(1) = 67291416
               DO 10 J = 1, 20
                  CRAY1(J+1) = CRAY1(J) + CRAY1(J)
 10               CONTINUE
               CRAY1(22) = CRAY1(21) + 321322
               DO 20 J = 22, 37
                  CRAY1(J+1) = CRAY1(J) + CRAY1(J)
 20               CONTINUE
               IF (CRAY1(38) .EQ. SMALL(1)) THEN
*                  *** CRAY ***
                  CALL I1MCRY(SMALL(1), J, 8285, 8388608, 0)
                  SMALL(2) = 0
                  CALL I1MCRY(LARGE(1), J, 24574, 16777215, 16777215)
                  CALL I1MCRY(LARGE(2), J, 0, 16777215, 16777214)
                  CALL I1MCRY(RIGHT(1), J, 16291, 8388608, 0)
                  RIGHT(2) = 0
                  CALL I1MCRY(DIVER(1), J, 16292, 8388608, 0)
                  DIVER(2) = 0
                  CALL I1MCRY(LOG10(1), J, 16383, 10100890, 8715215)
                  CALL I1MCRY(LOG10(2), J, 0, 16226447, 9001388)
               ELSE
                  WRITE(*,9000)
                  STOP 779
                  END IF
            ELSE
               WRITE(*,9000)
               STOP 779
               END IF
            END IF
         SC = 987
         END IF
*    SANITY CHECK
      IF (DMACH(4) .GE. 1.0D0) STOP 778
      IF (I .LT. 1 .OR. I .GT. 5) THEN
         WRITE(*,*) 'D1MACH(I): I =',I,' is out of bounds.'
         STOP
         END IF
      D1MACH = DMACH(I)
      RETURN
 9000 FORMAT(/' Adjust D1MACH by uncommenting data statements'/
     *' appropriate for your machine.')
* /* Standard C source for D1MACH -- remove the * in column 1 */
*#include <stdio.h>
*#include <float.h>
*#include <math.h>
*double d1mach_(long *i)
*{
*	switch(*i){
*	  case 1: return DBL_MIN;
*	  case 2: return DBL_MAX;
*	  case 3: return DBL_EPSILON/FLT_RADIX;
*	  case 4: return DBL_EPSILON;
*	  case 5: return log10((double)FLT_RADIX);
*	  }
*	fprintf(stderr, "invalid argument: d1mach(%ld)\n", *i);
*	exit(1); return 0; /* some compilers demand return values */
*}
      END
      SUBROUTINE I1MCRY(A, A1, B, C, D)
**** SPECIAL COMPUTATION FOR OLD CRAY MACHINES ****
      INTEGER A, A1, B, C, D
      A1 = 16777216*B + C
      A = 16777216*A1 + D
      END


!      DOUBLE PRECISION FUNCTION D1MACH (I)
!C***BEGIN PROLOGUE  D1MACH
!C***PURPOSE  RETURN FLOATING POINT MACHINE DEPENDENT CONSTANTS.
!C***LIBRARY   SLATEC
!C***CATEGORY  R1
!C***TYPE      DOUBLE PRECISION (R1MACH-S, D1MACH-D)
!C***KEYWORDS  MACHINE CONSTANTS
!C***AUTHOR  FOX, P. A., (BELL LABS)
!C           HALL, A. D., (BELL LABS)
!C           SCHRYER, N. L., (BELL LABS)
!C***DESCRIPTION
!C
!C   D1MACH CAN BE USED TO OBTAIN MACHINE-DEPENDENT PARAMETERS FOR THE
!C   LOCAL MACHINE ENVIRONMENT.  IT IS A FUNCTION SUBPROGRAM WITH ONE
!C   (INPUT) ARGUMENT, AND CAN BE REFERENCED AS FOLLOWS:
!C
!C        D = D1MACH(I)
!C
!C   WHERE I=1,...,5.  THE (OUTPUT) VALUE OF D ABOVE IS DETERMINED BY
!C   THE (INPUT) VALUE OF I.  THE RESULTS FOR VARIOUS VALUES OF I ARE
!C   DISCUSSED BELOW.
!C
!C   D1MACH( 1) = B**(EMIN-1), THE SMALLEST POSITIVE MAGNITUDE.
!C   D1MACH( 2) = B**EMAX*(1 - B**(-T)), THE LARGEST MAGNITUDE.
!C   D1MACH( 3) = B**(-T), THE SMALLEST RELATIVE SPACING.
!C   D1MACH( 4) = B**(1-T), THE LARGEST RELATIVE SPACING.
!C   D1MACH( 5) = LOG10(B)
!C
!C   ASSUME DOUBLE PRECISION NUMBERS ARE REPRESENTED IN THE T-DIGIT,
!C   BASE-B FORM
!C
!C              SIGN (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )
!C
!C   WHERE 0 .LE. X(I) .LT. B FOR I=1,...,T, 0 .LT. X(1), AND
!C   EMIN .LE. E .LE. EMAX.
!C
!C   THE VALUES OF B, T, EMIN AND EMAX ARE PROVIDED IN I1MACH AS
!C   FOLLOWS:
!C   I1MACH(10) = B, THE BASE.
!C   I1MACH(14) = T, THE NUMBER OF BASE-B DIGITS.
!C   I1MACH(15) = EMIN, THE SMALLEST EXPONENT E.
!C   I1MACH(16) = EMAX, THE LARGEST EXPONENT E.
!C
!C   TO ALTER THIS FUNCTION FOR A PARTICULAR ENVIRONMENT, THE DESIRED
!C   SET OF DATA STATEMENTS SHOULD BE ACTIVATED BY REMOVING THE C FROM
!C   COLUMN 1.  ALSO, THE VALUES OF D1MACH(1) - D1MACH(4) SHOULD BE
!C   CHECKED FOR CONSISTENCY WITH THE LOCAL OPERATING SYSTEM.
!C
!C***REFERENCES  P. A. FOX, A. D. HALL AND N. L. SCHRYER, FRAMEWORK FOR
!C                 A PORTABLE LIBRARY, ACM TRANSACTIONS ON MATHEMATICAL
!C                 SOFTWARE 4, 2 (JUNE 1978), PP. 177-188.
!C***ROUTINES CALLED  XERMSG
!C***REVISION HISTORY  (YYMMDD)
!C   750101  DATE WRITTEN
!C   890213  REVISION DATE FROM VERSION 3.2
!C   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
!C   900315  CALLS TO XERROR CHANGED TO CALLS TO XERMSG.  (THJ)
!C   900618  ADDED DEC RISC CONSTANTS.  (WRB)
!C   900723  ADDED IBM RS 6000 CONSTANTS.  (WRB)
!C   900911  ADDED SUN 386I CONSTANTS.  (WRB)
!C   910710  ADDED HP 730 CONSTANTS.  (SMR)
!C   911114  ADDED CONVEX IEEE CONSTANTS.  (WRB)
!C   920121  ADDED SUN -R8 COMPILER OPTION CONSTANTS.  (WRB)
!C   920229  ADDED TOUCHSTONE DELTA I860 CONSTANTS.  (WRB)
!C   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
!C   920625  ADDED CONVEX -P8 AND -PD8 COMPILER OPTION CONSTANTS.
!C           (BKS, WRB)
!C   930201  ADDED DEC ALPHA AND SGI CONSTANTS.  (RWC AND WRB)
!C***END PROLOGUE  D1MACH
!C
!      INTEGER SMALL(4)
!      INTEGER LARGE(4)
!      INTEGER RIGHT(4)
!      INTEGER DIVER(4)
!      INTEGER LOG10(4)
!C
!      DOUBLE PRECISION DMACH(5)
!      SAVE DMACH
!C
!      EQUIVALENCE (DMACH(1),SMALL(1))
!      EQUIVALENCE (DMACH(2),LARGE(1))
!      EQUIVALENCE (DMACH(3),RIGHT(1))
!      EQUIVALENCE (DMACH(4),DIVER(1))
!      EQUIVALENCE (DMACH(5),LOG10(1))
!C
!C
!C     MACHINE CONSTANTS FOR THE AMIGA
!C     ABSOFT FORTRAN COMPILER USING THE 68020/68881 COMPILER OPTION
!C
!C     DATA SMALL(1), SMALL(2) / Z'00100000', Z'00000000' /
!C     DATA LARGE(1), LARGE(2) / Z'7FEFFFFF', Z'FFFFFFFF' /
!C     DATA RIGHT(1), RIGHT(2) / Z'3CA00000', Z'00000000' /
!C     DATA DIVER(1), DIVER(2) / Z'3CB00000', Z'00000000' /
!C     DATA LOG10(1), LOG10(2) / Z'3FD34413', Z'509F79FF' /
!C
!C
!C     MACHINE CONSTANTS FOR THE AMIGA
!C     ABSOFT FORTRAN COMPILER USING SOFTWARE FLOATING POINT
!C
!C     DATA SMALL(1), SMALL(2) / Z'00100000', Z'00000000' /
!C     DATA LARGE(1), LARGE(2) / Z'7FDFFFFF', Z'FFFFFFFF' /
!C     DATA RIGHT(1), RIGHT(2) / Z'3CA00000', Z'00000000' /
!C     DATA DIVER(1), DIVER(2) / Z'3CB00000', Z'00000000' /
!C     DATA LOG10(1), LOG10(2) / Z'3FD34413', Z'509F79FF' /
!C
!C     MACHINE CONSTANTS FOR THE APOLLO
!C
!C     DATA SMALL(1), SMALL(2) / 16#00100000, 16#00000000 /
!C     DATA LARGE(1), LARGE(2) / 16#7FFFFFFF, 16#FFFFFFFF /
!C     DATA RIGHT(1), RIGHT(2) / 16#3CA00000, 16#00000000 /
!C     DATA DIVER(1), DIVER(2) / 16#3CB00000, 16#00000000 /
!C     DATA LOG10(1), LOG10(2) / 16#3FD34413, 16#509F79FF /
!C
!C     MACHINE CONSTANTS FOR THE BURROUGHS 1700 SYSTEM
!C
!C     DATA SMALL(1) / ZC00800000 /
!C     DATA SMALL(2) / Z000000000 /
!C     DATA LARGE(1) / ZDFFFFFFFF /
!C     DATA LARGE(2) / ZFFFFFFFFF /
!C     DATA RIGHT(1) / ZCC5800000 /
!C     DATA RIGHT(2) / Z000000000 /
!C     DATA DIVER(1) / ZCC6800000 /
!C     DATA DIVER(2) / Z000000000 /
!C     DATA LOG10(1) / ZD00E730E7 /
!C     DATA LOG10(2) / ZC77800DC0 /
!C
!C     MACHINE CONSTANTS FOR THE BURROUGHS 5700 SYSTEM
!C
!C     DATA SMALL(1) / O1771000000000000 /
!C     DATA SMALL(2) / O0000000000000000 /
!C     DATA LARGE(1) / O0777777777777777 /
!C     DATA LARGE(2) / O0007777777777777 /
!C     DATA RIGHT(1) / O1461000000000000 /
!C     DATA RIGHT(2) / O0000000000000000 /
!C     DATA DIVER(1) / O1451000000000000 /
!C     DATA DIVER(2) / O0000000000000000 /
!C     DATA LOG10(1) / O1157163034761674 /
!C     DATA LOG10(2) / O0006677466732724 /
!C
!C     MACHINE CONSTANTS FOR THE BURROUGHS 6700/7700 SYSTEMS
!C
!C     DATA SMALL(1) / O1771000000000000 /
!C     DATA SMALL(2) / O7770000000000000 /
!C     DATA LARGE(1) / O0777777777777777 /
!C     DATA LARGE(2) / O7777777777777777 /
!C     DATA RIGHT(1) / O1461000000000000 /
!C     DATA RIGHT(2) / O0000000000000000 /
!C     DATA DIVER(1) / O1451000000000000 /
!C     DATA DIVER(2) / O0000000000000000 /
!C     DATA LOG10(1) / O1157163034761674 /
!C     DATA LOG10(2) / O0006677466732724 /
!C
!C     MACHINE CONSTANTS FOR THE CDC 170/180 SERIES USING NOS/VE
!C
!C     DATA SMALL(1) / Z"3001800000000000" /
!C     DATA SMALL(2) / Z"3001000000000000" /
!C     DATA LARGE(1) / Z"4FFEFFFFFFFFFFFE" /
!C     DATA LARGE(2) / Z"4FFE000000000000" /
!C     DATA RIGHT(1) / Z"3FD2800000000000" /
!C     DATA RIGHT(2) / Z"3FD2000000000000" /
!C     DATA DIVER(1) / Z"3FD3800000000000" /
!C     DATA DIVER(2) / Z"3FD3000000000000" /
!C     DATA LOG10(1) / Z"3FFF9A209A84FBCF" /
!C     DATA LOG10(2) / Z"3FFFF7988F8959AC" /
!C
!C     MACHINE CONSTANTS FOR THE CDC 6000/7000 SERIES
!C
!C     DATA SMALL(1) / 00564000000000000000B /
!C     DATA SMALL(2) / 00000000000000000000B /
!C     DATA LARGE(1) / 37757777777777777777B /
!C     DATA LARGE(2) / 37157777777777777777B /
!C     DATA RIGHT(1) / 15624000000000000000B /
!C     DATA RIGHT(2) / 00000000000000000000B /
!C     DATA DIVER(1) / 15634000000000000000B /
!C     DATA DIVER(2) / 00000000000000000000B /
!C     DATA LOG10(1) / 17164642023241175717B /
!C     DATA LOG10(2) / 16367571421742254654B /
!C
!C     MACHINE CONSTANTS FOR THE CELERITY C1260
!C
!C     DATA SMALL(1), SMALL(2) / Z'00100000', Z'00000000' /
!C     DATA LARGE(1), LARGE(2) / Z'7FEFFFFF', Z'FFFFFFFF' /
!C     DATA RIGHT(1), RIGHT(2) / Z'3CA00000', Z'00000000' /
!C     DATA DIVER(1), DIVER(2) / Z'3CB00000', Z'00000000' /
!C     DATA LOG10(1), LOG10(2) / Z'3FD34413', Z'509F79FF' /
!C
!C     MACHINE CONSTANTS FOR THE CONVEX
!C     USING THE -FN OR -PD8 COMPILER OPTION
!C
!C     DATA DMACH(1) / Z'0010000000000000' /
!C     DATA DMACH(2) / Z'7FFFFFFFFFFFFFFF' /
!C     DATA DMACH(3) / Z'3CC0000000000000' /
!C     DATA DMACH(4) / Z'3CD0000000000000' /
!C     DATA DMACH(5) / Z'3FF34413509F79FF' /
!C
!C     MACHINE CONSTANTS FOR THE CONVEX
!C     USING THE -FI COMPILER OPTION
!C
!C     DATA DMACH(1) / Z'0010000000000000' /
!C     DATA DMACH(2) / Z'7FEFFFFFFFFFFFFF' /
!C     DATA DMACH(3) / Z'3CA0000000000000' /
!C     DATA DMACH(4) / Z'3CB0000000000000' /
!C     DATA DMACH(5) / Z'3FD34413509F79FF' /
!C
!C     MACHINE CONSTANTS FOR THE CONVEX
!C     USING THE -P8 COMPILER OPTION
!C
!C     DATA DMACH(1) / Z'00010000000000000000000000000000' /
!C     DATA DMACH(2) / Z'7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' /
!C     DATA DMACH(3) / Z'3F900000000000000000000000000000' /
!C     DATA DMACH(4) / Z'3F910000000000000000000000000000' /
!C     DATA DMACH(5) / Z'3FFF34413509F79FEF311F12B35816F9' /
!C
!C     MACHINE CONSTANTS FOR THE CRAY
!C
!C     DATA SMALL(1) / 201354000000000000000B /
!C     DATA SMALL(2) / 000000000000000000000B /
!C     DATA LARGE(1) / 577767777777777777777B /
!C     DATA LARGE(2) / 000007777777777777774B /
!C     DATA RIGHT(1) / 376434000000000000000B /
!C     DATA RIGHT(2) / 000000000000000000000B /
!C     DATA DIVER(1) / 376444000000000000000B /
!C     DATA DIVER(2) / 000000000000000000000B /
!C     DATA LOG10(1) / 377774642023241175717B /
!C     DATA LOG10(2) / 000007571421742254654B /
!C
!C     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200
!C     NOTE - IT MAY BE APPROPRIATE TO INCLUDE THE FOLLOWING CARD -
!C     STATIC DMACH(5)
!C
!C     DATA SMALL /    20K, 3*0 /
!C     DATA LARGE / 77777K, 3*177777K /
!C     DATA RIGHT / 31420K, 3*0 /
!C     DATA DIVER / 32020K, 3*0 /
!C     DATA LOG10 / 40423K, 42023K, 50237K, 74776K /
!C
!C     MACHINE CONSTANTS FOR THE DEC ALPHA
!C     USING G_FLOAT
!C
!C     DATA DMACH(1) / '0000000000000010'X /
!C     DATA DMACH(2) / 'FFFFFFFFFFFF7FFF'X /
!C     DATA DMACH(3) / '0000000000003CC0'X /
!C     DATA DMACH(4) / '0000000000003CD0'X /
!C     DATA DMACH(5) / '79FF509F44133FF3'X /
!C
!C     MACHINE CONSTANTS FOR THE DEC ALPHA
!C     USING IEEE_FORMAT
!C
!C     DATA DMACH(1) / '0010000000000000'X /
!C     DATA DMACH(2) / '7FEFFFFFFFFFFFFF'X /
!C     DATA DMACH(3) / '3CA0000000000000'X /
!C     DATA DMACH(4) / '3CB0000000000000'X /
!C     DATA DMACH(5) / '3FD34413509F79FF'X /
!C
!C     MACHINE CONSTANTS FOR THE DEC RISC
!C
!C     DATA SMALL(1), SMALL(2) / Z'00000000', Z'00100000'/
!C     DATA LARGE(1), LARGE(2) / Z'FFFFFFFF', Z'7FEFFFFF'/
!C     DATA RIGHT(1), RIGHT(2) / Z'00000000', Z'3CA00000'/
!C     DATA DIVER(1), DIVER(2) / Z'00000000', Z'3CB00000'/
!C     DATA LOG10(1), LOG10(2) / Z'509F79FF', Z'3FD34413'/
!C
!C     MACHINE CONSTANTS FOR THE DEC VAX
!C     USING D_FLOATING
!C     (EXPRESSED IN INTEGER AND HEXADECIMAL)
!C     THE HEX FORMAT BELOW MAY NOT BE SUITABLE FOR UNIX SYSTEMS
!C     THE INTEGER FORMAT SHOULD BE OK FOR UNIX SYSTEMS
!C
!C     DATA SMALL(1), SMALL(2) /        128,           0 /
!C     DATA LARGE(1), LARGE(2) /     -32769,          -1 /
!C     DATA RIGHT(1), RIGHT(2) /       9344,           0 /
!C     DATA DIVER(1), DIVER(2) /       9472,           0 /
!C     DATA LOG10(1), LOG10(2) /  546979738,  -805796613 /
!C
!C     DATA SMALL(1), SMALL(2) / Z00000080, Z00000000 /
!C     DATA LARGE(1), LARGE(2) / ZFFFF7FFF, ZFFFFFFFF /
!C     DATA RIGHT(1), RIGHT(2) / Z00002480, Z00000000 /
!C     DATA DIVER(1), DIVER(2) / Z00002500, Z00000000 /
!C     DATA LOG10(1), LOG10(2) / Z209A3F9A, ZCFF884FB /
!C
!C     MACHINE CONSTANTS FOR THE DEC VAX
!C     USING G_FLOATING
!C     (EXPRESSED IN INTEGER AND HEXADECIMAL)
!C     THE HEX FORMAT BELOW MAY NOT BE SUITABLE FOR UNIX SYSTEMS
!C     THE INTEGER FORMAT SHOULD BE OK FOR UNIX SYSTEMS
!C
!C     DATA SMALL(1), SMALL(2) /         16,           0 /
!C     DATA LARGE(1), LARGE(2) /     -32769,          -1 /
!C     DATA RIGHT(1), RIGHT(2) /      15552,           0 /
!C     DATA DIVER(1), DIVER(2) /      15568,           0 /
!C     DATA LOG10(1), LOG10(2) /  1142112243, 2046775455 /
!C
!C     DATA SMALL(1), SMALL(2) / Z00000010, Z00000000 /
!C     DATA LARGE(1), LARGE(2) / ZFFFF7FFF, ZFFFFFFFF /
!C     DATA RIGHT(1), RIGHT(2) / Z00003CC0, Z00000000 /
!C     DATA DIVER(1), DIVER(2) / Z00003CD0, Z00000000 /
!C     DATA LOG10(1), LOG10(2) / Z44133FF3, Z79FF509F /
!C
!C     MACHINE CONSTANTS FOR THE ELXSI 6400
!C     (ASSUMING REAL*8 IS THE DEFAULT DOUBLE PRECISION)
!C
!C     DATA SMALL(1), SMALL(2) / '00100000'X,'00000000'X /
!C     DATA LARGE(1), LARGE(2) / '7FEFFFFF'X,'FFFFFFFF'X /
!C     DATA RIGHT(1), RIGHT(2) / '3CB00000'X,'00000000'X /
!C     DATA DIVER(1), DIVER(2) / '3CC00000'X,'00000000'X /
!C     DATA LOG10(1), LOG10(2) / '3FD34413'X,'509F79FF'X /
!C
!C     MACHINE CONSTANTS FOR THE HARRIS 220
!C
!C     DATA SMALL(1), SMALL(2) / '20000000, '00000201 /
!C     DATA LARGE(1), LARGE(2) / '37777777, '37777577 /
!C     DATA RIGHT(1), RIGHT(2) / '20000000, '00000333 /
!C     DATA DIVER(1), DIVER(2) / '20000000, '00000334 /
!C     DATA LOG10(1), LOG10(2) / '23210115, '10237777 /
!C
!C     MACHINE CONSTANTS FOR THE HONEYWELL 600/6000 SERIES
!C
!C     DATA SMALL(1), SMALL(2) / O402400000000, O000000000000 /
!C     DATA LARGE(1), LARGE(2) / O376777777777, O777777777777 /
!C     DATA RIGHT(1), RIGHT(2) / O604400000000, O000000000000 /
!C     DATA DIVER(1), DIVER(2) / O606400000000, O000000000000 /
!C     DATA LOG10(1), LOG10(2) / O776464202324, O117571775714 /
!C
!C     MACHINE CONSTANTS FOR THE HP 730
!C
!C     DATA DMACH(1) / Z'0010000000000000' /
!C     DATA DMACH(2) / Z'7FEFFFFFFFFFFFFF' /
!C     DATA DMACH(3) / Z'3CA0000000000000' /
!C     DATA DMACH(4) / Z'3CB0000000000000' /
!C     DATA DMACH(5) / Z'3FD34413509F79FF' /
!C
!C     MACHINE CONSTANTS FOR THE HP 2100
!C     THREE WORD DOUBLE PRECISION OPTION WITH FTN4
!C
!C     DATA SMALL(1), SMALL(2), SMALL(3) / 40000B,       0,       1 /
!C     DATA LARGE(1), LARGE(2), LARGE(3) / 77777B, 177777B, 177776B /
!C     DATA RIGHT(1), RIGHT(2), RIGHT(3) / 40000B,       0,    265B /
!C     DATA DIVER(1), DIVER(2), DIVER(3) / 40000B,       0,    276B /
!C     DATA LOG10(1), LOG10(2), LOG10(3) / 46420B,  46502B,  77777B /
!C
!C     MACHINE CONSTANTS FOR THE HP 2100
!C     FOUR WORD DOUBLE PRECISION OPTION WITH FTN4
!C
!C     DATA SMALL(1), SMALL(2) /  40000B,       0 /
!C     DATA SMALL(3), SMALL(4) /       0,       1 /
!C     DATA LARGE(1), LARGE(2) /  77777B, 177777B /
!C     DATA LARGE(3), LARGE(4) / 177777B, 177776B /
!C     DATA RIGHT(1), RIGHT(2) /  40000B,       0 /
!C     DATA RIGHT(3), RIGHT(4) /       0,    225B /
!C     DATA DIVER(1), DIVER(2) /  40000B,       0 /
!C     DATA DIVER(3), DIVER(4) /       0,    227B /
!C     DATA LOG10(1), LOG10(2) /  46420B,  46502B /
!C     DATA LOG10(3), LOG10(4) /  76747B, 176377B /
!C
!C     MACHINE CONSTANTS FOR THE HP 9000
!C
!C     DATA SMALL(1), SMALL(2) / 00040000000B, 00000000000B /
!C     DATA LARGE(1), LARGE(2) / 17737777777B, 37777777777B /
!C     DATA RIGHT(1), RIGHT(2) / 07454000000B, 00000000000B /
!C     DATA DIVER(1), DIVER(2) / 07460000000B, 00000000000B /
!C     DATA LOG10(1), LOG10(2) / 07764642023B, 12047674777B /
!C
!C     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES,
!C     THE XEROX SIGMA 5/7/9, THE SEL SYSTEMS 85/86, AND
!C     THE PERKIN ELMER (INTERDATA) 7/32.
!C
!C     DATA SMALL(1), SMALL(2) / Z00100000, Z00000000 /
!C     DATA LARGE(1), LARGE(2) / Z7FFFFFFF, ZFFFFFFFF /
!C     DATA RIGHT(1), RIGHT(2) / Z33100000, Z00000000 /
!C     DATA DIVER(1), DIVER(2) / Z34100000, Z00000000 /
!C     DATA LOG10(1), LOG10(2) / Z41134413, Z509F79FF /
!C
!C     MACHINE CONSTANTS FOR THE IBM PC
!C     ASSUMES THAT ALL ARITHMETIC IS DONE IN DOUBLE PRECISION
!C     ON 8088, I.E., NOT IN 80 BIT FORM FOR THE 8087.
!C
!C     DATA SMALL(1) / 2.23D-308  /
!C     DATA LARGE(1) / 1.79D+308  /
!C     DATA RIGHT(1) / 1.11D-16   /
!C     DATA DIVER(1) / 2.22D-16   /
!C     DATA LOG10(1) / 0.301029995663981195D0 /
!C
!C     MACHINE CONSTANTS FOR THE IBM RS 6000
!C
!C     DATA DMACH(1) / Z'0010000000000000' /
!C     DATA DMACH(2) / Z'7FEFFFFFFFFFFFFF' /
!C     DATA DMACH(3) / Z'3CA0000000000000' /
!C     DATA DMACH(4) / Z'3CB0000000000000' /
!C     DATA DMACH(5) / Z'3FD34413509F79FF' /
!C
!C     MACHINE CONSTANTS FOR THE INTEL I860
!C
!C     DATA DMACH(1) / Z'0010000000000000' /
!C     DATA DMACH(2) / Z'7FEFFFFFFFFFFFFF' /
!C     DATA DMACH(3) / Z'3CA0000000000000' /
!C     DATA DMACH(4) / Z'3CB0000000000000' /
!C     DATA DMACH(5) / Z'3FD34413509F79FF' /
!C
!C     MACHINE CONSTANTS FOR THE PDP-10 (KA PROCESSOR)
!C
!C     DATA SMALL(1), SMALL(2) / "033400000000, "000000000000 /
!C     DATA LARGE(1), LARGE(2) / "377777777777, "344777777777 /
!C     DATA RIGHT(1), RIGHT(2) / "113400000000, "000000000000 /
!C     DATA DIVER(1), DIVER(2) / "114400000000, "000000000000 /
!C     DATA LOG10(1), LOG10(2) / "177464202324, "144117571776 /
!C
!C     MACHINE CONSTANTS FOR THE PDP-10 (KI PROCESSOR)
!C
!C     DATA SMALL(1), SMALL(2) / "000400000000, "000000000000 /
!C     DATA LARGE(1), LARGE(2) / "377777777777, "377777777777 /
!C     DATA RIGHT(1), RIGHT(2) / "103400000000, "000000000000 /
!C     DATA DIVER(1), DIVER(2) / "104400000000, "000000000000 /
!C     DATA LOG10(1), LOG10(2) / "177464202324, "476747767461 /
!C
!C     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING
!C     32-BIT INTEGERS (EXPRESSED IN INTEGER AND OCTAL).
!C
!C     DATA SMALL(1), SMALL(2) /    8388608,           0 /
!C     DATA LARGE(1), LARGE(2) / 2147483647,          -1 /
!C     DATA RIGHT(1), RIGHT(2) /  612368384,           0 /
!C     DATA DIVER(1), DIVER(2) /  620756992,           0 /
!C     DATA LOG10(1), LOG10(2) / 1067065498, -2063872008 /
!C
!C     DATA SMALL(1), SMALL(2) / O00040000000, O00000000000 /
!C     DATA LARGE(1), LARGE(2) / O17777777777, O37777777777 /
!C     DATA RIGHT(1), RIGHT(2) / O04440000000, O00000000000 /
!C     DATA DIVER(1), DIVER(2) / O04500000000, O00000000000 /
!C     DATA LOG10(1), LOG10(2) / O07746420232, O20476747770 /
!C
!C     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING
!C     16-BIT INTEGERS (EXPRESSED IN INTEGER AND OCTAL).
!C
!C     DATA SMALL(1), SMALL(2) /    128,      0 /
!C     DATA SMALL(3), SMALL(4) /      0,      0 /
!C     DATA LARGE(1), LARGE(2) /  32767,     -1 /
!C     DATA LARGE(3), LARGE(4) /     -1,     -1 /
!C     DATA RIGHT(1), RIGHT(2) /   9344,      0 /
!C     DATA RIGHT(3), RIGHT(4) /      0,      0 /
!C     DATA DIVER(1), DIVER(2) /   9472,      0 /
!C     DATA DIVER(3), DIVER(4) /      0,      0 /
!C     DATA LOG10(1), LOG10(2) /  16282,   8346 /
!C     DATA LOG10(3), LOG10(4) / -31493, -12296 /
!C
!C     DATA SMALL(1), SMALL(2) / O000200, O000000 /
!C     DATA SMALL(3), SMALL(4) / O000000, O000000 /
!C     DATA LARGE(1), LARGE(2) / O077777, O177777 /
!C     DATA LARGE(3), LARGE(4) / O177777, O177777 /
!C     DATA RIGHT(1), RIGHT(2) / O022200, O000000 /
!C     DATA RIGHT(3), RIGHT(4) / O000000, O000000 /
!C     DATA DIVER(1), DIVER(2) / O022400, O000000 /
!C     DATA DIVER(3), DIVER(4) / O000000, O000000 /
!C     DATA LOG10(1), LOG10(2) / O037632, O020232 /
!C     DATA LOG10(3), LOG10(4) / O102373, O147770 /
!C
!C_RPC
!C     MACHINE CONSTANTS FOR THE SILICON GRAPHICS & MACINTOSH PPC
!C
!      DATA SMALL(1), SMALL(2) / Z'00100000', Z'00000000' /
!      DATA LARGE(1), LARGE(2) / Z'7FEFFFFF', Z'FFFFFFFF' /
!      DATA RIGHT(1), RIGHT(2) / Z'3CA00000', Z'00000000' /
!      DATA DIVER(1), DIVER(2) / Z'3CB00000', Z'00000000' /
!      DATA LOG10(1), LOG10(2) / Z'3FD34413', Z'509F79FF' /
!C
!C     MACHINE CONSTANTS FOR THE SUN
!C
!C_RPC       DATA DMACH(1) / Z'0010000000000000' /
!C_RPC       DATA DMACH(2) / Z'7FEFFFFFFFFFFFFF' /
!C_RPC       DATA DMACH(3) / Z'3CA0000000000000' /
!C_RPC       DATA DMACH(4) / Z'3CB0000000000000' /
!C_RPC       DATA DMACH(5) / Z'3FD34413509F79FF' /
!C
!C     MACHINE CONSTANTS FOR THE SUN
!C     USING THE -R8 COMPILER OPTION
!C
!C     DATA DMACH(1) / Z'00010000000000000000000000000000' /
!C     DATA DMACH(2) / Z'7FFEFFFFFFFFFFFFFFFFFFFFFFFFFFFF' /
!C     DATA DMACH(3) / Z'3F8E0000000000000000000000000000' /
!C     DATA DMACH(4) / Z'3F8F0000000000000000000000000000' /
!C     DATA DMACH(5) / Z'3FFD34413509F79FEF311F12B35816F9' /
!C
!C     MACHINE CONSTANTS FOR THE SUN 386I
!C
!C     DATA SMALL(1), SMALL(2) / Z'FFFFFFFD', Z'000FFFFF' /
!C     DATA LARGE(1), LARGE(2) / Z'FFFFFFB0', Z'7FEFFFFF' /
!C     DATA RIGHT(1), RIGHT(2) / Z'000000B0', Z'3CA00000' /
!C     DATA DIVER(1), DIVER(2) / Z'FFFFFFCB', Z'3CAFFFFF'
!C     DATA LOG10(1), LOG10(2) / Z'509F79E9', Z'3FD34413' /
!C
!C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES FTN COMPILER
!C
!C     DATA SMALL(1), SMALL(2) / O000040000000, O000000000000 /
!C     DATA LARGE(1), LARGE(2) / O377777777777, O777777777777 /
!C     DATA RIGHT(1), RIGHT(2) / O170540000000, O000000000000 /
!C     DATA DIVER(1), DIVER(2) / O170640000000, O000000000000 /
!C     DATA LOG10(1), LOG10(2) / O177746420232, O411757177572 /
!C
!C***FIRST EXECUTABLE STATEMENT  D1MACH
!      IF(I .LT. 1 .OR. I .GT. 5) CALL XERMSG ('SLATEC', 'D1MACH',
!     +   'I OUT OF BOUNDS', 1, 2)
!C
!      D1MACH = DMACH(I)
!    
!      RETURN
!C
!      END
C
C#######################################################################
C
C                       I   1   M   A   C   H   (FUNCTION) 
C
C#######################################################################
C
*DECK I1MACH
      INTEGER FUNCTION I1MACH (I)
C***BEGIN PROLOGUE  I1MACH
C***PURPOSE  RETURN INTEGER MACHINE DEPENDENT CONSTANTS.
C***LIBRARY   SLATEC
C***CATEGORY  R1
C***TYPE      INTEGER (I1MACH-I)
C***KEYWORDS  MACHINE CONSTANTS
C***AUTHOR  FOX, P. A., (BELL LABS)
C           HALL, A. D., (BELL LABS)
C           SCHRYER, N. L., (BELL LABS)
C***DESCRIPTION
C
C   I1MACH CAN BE USED TO OBTAIN MACHINE-DEPENDENT PARAMETERS FOR THE
C   LOCAL MACHINE ENVIRONMENT.  IT IS A FUNCTION SUBPROGRAM WITH ONE
C   (INPUT) ARGUMENT AND CAN BE REFERENCED AS FOLLOWS:
C
C        K = I1MACH(I)
C
C   WHERE I=1,...,16.  THE (OUTPUT) VALUE OF K ABOVE IS DETERMINED BY
C   THE (INPUT) VALUE OF I.  THE RESULTS FOR VARIOUS VALUES OF I ARE
C   DISCUSSED BELOW.
C
C   I/O UNIT NUMBERS:
C     I1MACH( 1) = THE STANDARD INPUT UNIT.
C     I1MACH( 2) = THE STANDARD OUTPUT UNIT.
C     I1MACH( 3) = THE STANDARD PUNCH UNIT.
C     I1MACH( 4) = THE STANDARD ERROR MESSAGE UNIT.
C
C   WORDS:
C     I1MACH( 5) = THE NUMBER OF BITS PER INTEGER STORAGE UNIT.
C     I1MACH( 6) = THE NUMBER OF CHARACTERS PER INTEGER STORAGE UNIT.
C
C   INTEGERS:
C     ASSUME INTEGERS ARE REPRESENTED IN THE S-DIGIT, BASE-A FORM
C
C                SIGN ( X(S-1)*A**(S-1) + ... + X(1)*A + X(0) )
C
C                WHERE 0 .LE. X(I) .LT. A FOR I=0,...,S-1.
C     I1MACH( 7) = A, THE BASE.
C     I1MACH( 8) = S, THE NUMBER OF BASE-A DIGITS.
C     I1MACH( 9) = A**S - 1, THE LARGEST MAGNITUDE.
C
C   FLOATING-POINT NUMBERS:
C     ASSUME FLOATING-POINT NUMBERS ARE REPRESENTED IN THE T-DIGIT,
C     BASE-B FORM
C                SIGN (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )
C
C                WHERE 0 .LE. X(I) .LT. B FOR I=1,...,T,
C                0 .LT. X(1), AND EMIN .LE. E .LE. EMAX.
C     I1MACH(10) = B, THE BASE.
C
C   SINGLE-PRECISION:
C     I1MACH(11) = T, THE NUMBER OF BASE-B DIGITS.
C     I1MACH(12) = EMIN, THE SMALLEST EXPONENT E.
C     I1MACH(13) = EMAX, THE LARGEST EXPONENT E.
C
C   DOUBLE-PRECISION:
C     I1MACH(14) = T, THE NUMBER OF BASE-B DIGITS.
C     I1MACH(15) = EMIN, THE SMALLEST EXPONENT E.
C     I1MACH(16) = EMAX, THE LARGEST EXPONENT E.
C
C   TO ALTER THIS FUNCTION FOR A PARTICULAR ENVIRONMENT, THE DESIRED
C   SET OF DATA STATEMENTS SHOULD BE ACTIVATED BY REMOVING THE C FROM
C   COLUMN 1.  ALSO, THE VALUES OF I1MACH(1) - I1MACH(4) SHOULD BE
C   CHECKED FOR CONSISTENCY WITH THE LOCAL OPERATING SYSTEM.
C
C***REFERENCES  P. A. FOX, A. D. HALL AND N. L. SCHRYER, FRAMEWORK FOR
C                 A PORTABLE LIBRARY, ACM TRANSACTIONS ON MATHEMATICAL
C                 SOFTWARE 4, 2 (JUNE 1978), PP. 177-188.
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   750101  DATE WRITTEN
C   891012  ADDED VAX G-FLOATING CONSTANTS.  (WRB)
C   891012  REVISION DATE FROM VERSION 3.2
C   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
C   900618  ADDED DEC RISC CONSTANTS.  (WRB)
C   900723  ADDED IBM RS 6000 CONSTANTS.  (WRB)
C   901009  CORRECT I1MACH(7) FOR IBM MAINFRAMES. SHOULD BE 2 NOT 16.
C           (RWC)
C   910710  ADDED HP 730 CONSTANTS.  (SMR)
C   911114  ADDED CONVEX IEEE CONSTANTS.  (WRB)
C   920121  ADDED SUN -R8 COMPILER OPTION CONSTANTS.  (WRB)
C   920229  ADDED TOUCHSTONE DELTA I860 CONSTANTS.  (WRB)
C   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
C   920625  ADDED CONVEX -P8 AND -PD8 COMPILER OPTION CONSTANTS.
C           (BKS, WRB)
C   930201  ADDED DEC ALPHA AND SGI CONSTANTS.  (RWC AND WRB)
C   930618  CORRECTED I1MACH(5) FOR CONVEX -P8 AND -PD8 COMPILER
C           OPTIONS.  (DWL, RWC AND WRB).
C***END PROLOGUE  I1MACH
C
      INTEGER IMACH(16),OUTPUT
      SAVE IMACH
      EQUIVALENCE (IMACH(4),OUTPUT)
C
C     MACHINE CONSTANTS FOR THE AMIGA
C     ABSOFT COMPILER
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -126 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1022 /
C     DATA IMACH(16) /       1023 /
C
C
C     MACHINE CONSTANTS FOR THE APOLLO
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        129 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1025 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 1700 SYSTEM
C
C     DATA IMACH( 1) /          7 /
C     DATA IMACH( 2) /          2 /
C     DATA IMACH( 3) /          2 /
C     DATA IMACH( 4) /          2 /
C     DATA IMACH( 5) /         36 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         33 /
C     DATA IMACH( 9) / Z1FFFFFFFF /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -256 /
C     DATA IMACH(13) /        255 /
C     DATA IMACH(14) /         60 /
C     DATA IMACH(15) /       -256 /
C     DATA IMACH(16) /        255 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 5700 SYSTEM
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         48 /
C     DATA IMACH( 6) /          6 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         39 /
C     DATA IMACH( 9) / O0007777777777777 /
C     DATA IMACH(10) /          8 /
C     DATA IMACH(11) /         13 /
C     DATA IMACH(12) /        -50 /
C     DATA IMACH(13) /         76 /
C     DATA IMACH(14) /         26 /
C     DATA IMACH(15) /        -50 /
C     DATA IMACH(16) /         76 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 6700/7700 SYSTEMS
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         48 /
C     DATA IMACH( 6) /          6 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         39 /
C     DATA IMACH( 9) / O0007777777777777 /
C     DATA IMACH(10) /          8 /
C     DATA IMACH(11) /         13 /
C     DATA IMACH(12) /        -50 /
C     DATA IMACH(13) /         76 /
C     DATA IMACH(14) /         26 /
C     DATA IMACH(15) /     -32754 /
C     DATA IMACH(16) /      32780 /
C
C     MACHINE CONSTANTS FOR THE CDC 170/180 SERIES USING NOS/VE
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         64 /
C     DATA IMACH( 6) /          8 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         63 /
C     DATA IMACH( 9) / 9223372036854775807 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         47 /
C     DATA IMACH(12) /      -4095 /
C     DATA IMACH(13) /       4094 /
C     DATA IMACH(14) /         94 /
C     DATA IMACH(15) /      -4095 /
C     DATA IMACH(16) /       4094 /
C
C     MACHINE CONSTANTS FOR THE CDC 6000/7000 SERIES
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /    6LOUTPUT/
C     DATA IMACH( 5) /         60 /
C     DATA IMACH( 6) /         10 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         48 /
C     DATA IMACH( 9) / 00007777777777777777B /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         47 /
C     DATA IMACH(12) /       -929 /
C     DATA IMACH(13) /       1070 /
C     DATA IMACH(14) /         94 /
C     DATA IMACH(15) /       -929 /
C     DATA IMACH(16) /       1069 /
C
C     MACHINE CONSTANTS FOR THE CELERITY C1260
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          0 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / Z'7FFFFFFF' /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -126 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1022 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE CONVEX
C     USING THE -FN COMPILER OPTION
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1023 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE CONVEX
C     USING THE -FI COMPILER OPTION
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE CONVEX
C     USING THE -P8 COMPILER OPTION
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         64 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         63 /
C     DATA IMACH( 9) / 9223372036854775807 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         53 /
C     DATA IMACH(12) /      -1023 /
C     DATA IMACH(13) /       1023 /
C     DATA IMACH(14) /        113 /
C     DATA IMACH(15) /     -16383 /
C     DATA IMACH(16) /      16383 /
C
C     MACHINE CONSTANTS FOR THE CONVEX
C     USING THE -PD8 COMPILER OPTION
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         64 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         63 /
C     DATA IMACH( 9) / 9223372036854775807 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         53 /
C     DATA IMACH(12) /      -1023 /
C     DATA IMACH(13) /       1023 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1023 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE CRAY
C     USING THE 46 BIT INTEGER COMPILER OPTION
C
C     DATA IMACH( 1) /        100 /
C     DATA IMACH( 2) /        101 /
C     DATA IMACH( 3) /        102 /
C     DATA IMACH( 4) /        101 /
C     DATA IMACH( 5) /         64 /
C     DATA IMACH( 6) /          8 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         46 /
C     DATA IMACH( 9) / 1777777777777777B /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         47 /
C     DATA IMACH(12) /      -8189 /
C     DATA IMACH(13) /       8190 /
C     DATA IMACH(14) /         94 /
C     DATA IMACH(15) /      -8099 /
C     DATA IMACH(16) /       8190 /
C
C     MACHINE CONSTANTS FOR THE CRAY
C     USING THE 64 BIT INTEGER COMPILER OPTION
C
C     DATA IMACH( 1) /        100 /
C     DATA IMACH( 2) /        101 /
C     DATA IMACH( 3) /        102 /
C     DATA IMACH( 4) /        101 /
C     DATA IMACH( 5) /         64 /
C     DATA IMACH( 6) /          8 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         63 /
C     DATA IMACH( 9) / 777777777777777777777B /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         47 /
C     DATA IMACH(12) /      -8189 /
C     DATA IMACH(13) /       8190 /
C     DATA IMACH(14) /         94 /
C     DATA IMACH(15) /      -8099 /
C     DATA IMACH(16) /       8190 /
C
C     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200
C
C     DATA IMACH( 1) /         11 /
C     DATA IMACH( 2) /         12 /
C     DATA IMACH( 3) /          8 /
C     DATA IMACH( 4) /         10 /
C     DATA IMACH( 5) /         16 /
C     DATA IMACH( 6) /          2 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         15 /
C     DATA IMACH( 9) /      32767 /
C     DATA IMACH(10) /         16 /
C     DATA IMACH(11) /          6 /
C     DATA IMACH(12) /        -64 /
C     DATA IMACH(13) /         63 /
C     DATA IMACH(14) /         14 /
C     DATA IMACH(15) /        -64 /
C     DATA IMACH(16) /         63 /
C
C     MACHINE CONSTANTS FOR THE DEC ALPHA
C     USING G_FLOAT
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1023 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE DEC ALPHA
C     USING IEEE_FLOAT
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE DEC RISC
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE DEC VAX
C     USING D_FLOATING
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         56 /
C     DATA IMACH(15) /       -127 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR THE DEC VAX
C     USING G_FLOATING
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1023 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE ELXSI 6400
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         32 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -126 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1022 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE HARRIS 220
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          0 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         24 /
C     DATA IMACH( 6) /          3 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         23 /
C     DATA IMACH( 9) /    8388607 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         23 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         38 /
C     DATA IMACH(15) /       -127 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR THE HONEYWELL 600/6000 SERIES
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /         43 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         36 /
C     DATA IMACH( 6) /          6 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         35 /
C     DATA IMACH( 9) / O377777777777 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         27 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         63 /
C     DATA IMACH(15) /       -127 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR THE HP 730
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE HP 2100
C     3 WORD DOUBLE PRECISION OPTION WITH FTN4
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          4 /
C     DATA IMACH( 4) /          1 /
C     DATA IMACH( 5) /         16 /
C     DATA IMACH( 6) /          2 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         15 /
C     DATA IMACH( 9) /      32767 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         23 /
C     DATA IMACH(12) /       -128 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         39 /
C     DATA IMACH(15) /       -128 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR THE HP 2100
C     4 WORD DOUBLE PRECISION OPTION WITH FTN4
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          4 /
C     DATA IMACH( 4) /          1 /
C     DATA IMACH( 5) /         16 /
C     DATA IMACH( 6) /          2 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         15 /
C     DATA IMACH( 9) /      32767 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         23 /
C     DATA IMACH(12) /       -128 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         55 /
C     DATA IMACH(15) /       -128 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR THE HP 9000
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          7 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         32 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -126 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1015 /
C     DATA IMACH(16) /       1017 /
C
C     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES,
C     THE XEROX SIGMA 5/7/9, THE SEL SYSTEMS 85/86, AND
C     THE PERKIN ELMER (INTERDATA) 7/32.
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          7 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) /  Z7FFFFFFF /
C     DATA IMACH(10) /         16 /
C     DATA IMACH(11) /          6 /
C     DATA IMACH(12) /        -64 /
C     DATA IMACH(13) /         63 /
C     DATA IMACH(14) /         14 /
C     DATA IMACH(15) /        -64 /
C     DATA IMACH(16) /         63 /
C
C     MACHINE CONSTANTS FOR THE IBM PC
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          0 /
C     DATA IMACH( 4) /          0 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE IBM RS 6000
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          0 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE INTEL I860
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -125 /
C     DATA IMACH(13) /        128 /
C     DATA IMACH(14) /         53 /
C     DATA IMACH(15) /      -1021 /
C     DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KA PROCESSOR)
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         36 /
C     DATA IMACH( 6) /          5 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         35 /
C     DATA IMACH( 9) / "377777777777 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         27 /
C     DATA IMACH(12) /       -128 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         54 /
C     DATA IMACH(15) /       -101 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KI PROCESSOR)
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         36 /
C     DATA IMACH( 6) /          5 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         35 /
C     DATA IMACH( 9) / "377777777777 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         27 /
C     DATA IMACH(12) /       -128 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         62 /
C     DATA IMACH(15) /       -128 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING
C     32-BIT INTEGER ARITHMETIC.
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         56 /
C     DATA IMACH(15) /       -127 /
C     DATA IMACH(16) /        127 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING
C     16-BIT INTEGER ARITHMETIC.
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          5 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         16 /
C     DATA IMACH( 6) /          2 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         15 /
C     DATA IMACH( 9) /      32767 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         56 /
C     DATA IMACH(15) /       -127 /
C     DATA IMACH(16) /        127 /
C
C_RPC
C     MACHINE CONSTANTS FOR THE SILICON GRAPHICS & MACINTOSH PPC & SUN
C
      DATA IMACH( 1) /          5 /
      DATA IMACH( 2) /          6 /
      DATA IMACH( 3) /          6 /
      DATA IMACH( 4) /          6 /
      DATA IMACH( 5) /         32 /
      DATA IMACH( 6) /          4 /
      DATA IMACH( 7) /          2 /
      DATA IMACH( 8) /         31 /
      DATA IMACH( 9) / 2147483647 /
      DATA IMACH(10) /          2 /
      DATA IMACH(11) /         24 /
      DATA IMACH(12) /       -125 /
      DATA IMACH(13) /        128 /
      DATA IMACH(14) /         53 /
      DATA IMACH(15) /      -1021 /
      DATA IMACH(16) /       1024 /
C
C     MACHINE CONSTANTS FOR THE SUN
C     USING THE -R8 COMPILER OPTION
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          6 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         32 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         53 /
C     DATA IMACH(12) /      -1021 /
C     DATA IMACH(13) /       1024 /
C     DATA IMACH(14) /        113 /
C     DATA IMACH(15) /     -16381 /
C     DATA IMACH(16) /      16384 /
C
C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES FTN COMPILER
C
C     DATA IMACH( 1) /          5 /
C     DATA IMACH( 2) /          6 /
C     DATA IMACH( 3) /          1 /
C     DATA IMACH( 4) /          6 /
C     DATA IMACH( 5) /         36 /
C     DATA IMACH( 6) /          4 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         35 /
C     DATA IMACH( 9) / O377777777777 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         27 /
C     DATA IMACH(12) /       -128 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         60 /
C     DATA IMACH(15) /      -1024 /
C     DATA IMACH(16) /       1023 /
C
C     MACHINE CONSTANTS FOR THE Z80 MICROPROCESSOR
C
C     DATA IMACH( 1) /          1 /
C     DATA IMACH( 2) /          1 /
C     DATA IMACH( 3) /          0 /
C     DATA IMACH( 4) /          1 /
C     DATA IMACH( 5) /         16 /
C     DATA IMACH( 6) /          2 /
C     DATA IMACH( 7) /          2 /
C     DATA IMACH( 8) /         15 /
C     DATA IMACH( 9) /      32767 /
C     DATA IMACH(10) /          2 /
C     DATA IMACH(11) /         24 /
C     DATA IMACH(12) /       -127 /
C     DATA IMACH(13) /        127 /
C     DATA IMACH(14) /         56 /
C     DATA IMACH(15) /       -127 /
C     DATA IMACH(16) /        127 /
C
C***FIRST EXECUTABLE STATEMENT  I1MACH
      IF(I .LT. 1  .OR.  I .GT. 16) GO TO 10
C
      I1MACH = IMACH(I)
      RETURN
C
   10 CONTINUE
      WRITE(UNIT = OUTPUT, FMT = 9000)
 9000 FORMAT ('1ERROR    1 IN I1MACH - I OUT OF BOUNDS')
C
C     CALL FDUMP
C
      STOP
      END
C
C#######################################################################
C
C                       D   D   A   I   N   I
C
C#######################################################################
C
*DECK DDAINI
      SUBROUTINE DDAINI (X, Y, YPRIME, NEQ, RES, JAC, H, WT, IDID, RPAR,
     *   IPAR, PHI, DELTA, E, WM, IWM, HMIN, UROUND, NONNEG, NTEMP)
C***BEGIN PROLOGUE  DDAINI
C***SUBSIDIARY
C***PURPOSE  INITIALIZATION ROUTINE FOR DDASSL.
C***LIBRARY   SLATEC (DASSL)
C***TYPE      DOUBLE PRECISION (SDAINI-S, DDAINI-D)
C***AUTHOR  PETZOLD, LINDA R., (LLNL)
C***DESCRIPTION
C-----------------------------------------------------------------
C     DDAINI TAKES ONE STEP OF SIZE H OR SMALLER
C     WITH THE BACKWARD EULER METHOD, TO
C     FIND YPRIME.  X AND Y ARE UPDATED TO BE CONSISTENT WITH THE
C     NEW STEP.  A MODIFIED DAMPED NEWTON ITERATION IS USED TO
C     SOLVE THE CORRECTOR ITERATION.
C
C     THE INITIAL GUESS FOR YPRIME IS USED IN THE
C     PREDICTION, AND IN FORMING THE ITERATION
C     MATRIX, BUT IS NOT INVOLVED IN THE
C     ERROR TEST. THIS MAY HAVE TROUBLE
C     CONVERGING IF THE INITIAL GUESS IS NO
C     GOOD, OR IF G(X,Y,YPRIME) DEPENDS
C     NONLINEARLY ON YPRIME.
C
C     THE PARAMETERS REPRESENT:
C     X --         INDEPENDENT VARIABLE
C     Y --         SOLUTION VECTOR AT X
C     YPRIME --    DERIVATIVE OF SOLUTION VECTOR
C     NEQ --       NUMBER OF EQUATIONS
C     H --         STEPSIZE. IMDER MAY USE A STEPSIZE
C                  SMALLER THAN H.
C     WT --        VECTOR OF WEIGHTS FOR ERROR
C                  CRITERION
C     IDID --      COMPLETION CODE WITH THE FOLLOWING MEANINGS
C                  IDID= 1 -- YPRIME WAS FOUND SUCCESSFULLY
C                  IDID=-12 -- DDAINI FAILED TO FIND YPRIME
C     RPAR,IPAR -- REAL AND INTEGER PARAMETER ARRAYS
C                  THAT ARE NOT ALTERED BY DDAINI
C     PHI --       WORK SPACE FOR DDAINI
C     DELTA,E --   WORK SPACE FOR DDAINI
C     WM,IWM --    REAL AND INTEGER ARRAYS STORING
C                  MATRIX INFORMATION
C
C-----------------------------------------------------------------
C***ROUTINES CALLED  DDAJAC, DDANRM, DDASLV
C***REVISION HISTORY  (YYMMDD)
C   830315  DATE WRITTEN
C   901009  FINISHED CONVERSION TO SLATEC 4.0 FORMAT (F.N.FRITSCH)
C   901019  MERGED CHANGES MADE BY C. ULRICH WITH SLATEC 4.0 FORMAT.
C   901026  ADDED EXPLICIT DECLARATIONS FOR ALL VARIABLES AND MINOR
C           COSMETIC CHANGES TO PROLOGUE.  (FNF)
C   901030  MINOR CORRECTIONS TO DECLARATIONS.  (FNF)
C***END PROLOGUE  DDAINI
C
      INTEGER  NEQ, IDID, IPAR(*), IWM(*), NONNEG, NTEMP
      DOUBLE PRECISION
     *   X, Y(*), YPRIME(*), H, WT(*), RPAR(*), PHI(NEQ,*), DELTA(*),
     *   E(*), WM(*), HMIN, UROUND
      EXTERNAL  RES, JAC
C
      EXTERNAL  DDAJAC, DDANRM, DDASLV
      DOUBLE PRECISION  DDANRM
C
      INTEGER  I, IER, IRES, JCALC, LNJE, LNRE, M, MAXIT, MJAC, NCF,
     *   NEF, NSF
      DOUBLE PRECISION
     *   CJ, DAMP, DELNRM, ERR, OLDNRM, R, RATE, S, XOLD, YNORM
      LOGICAL  CONVGD
C
      PARAMETER (LNRE=12)
      PARAMETER (LNJE=13)
C
      DATA MAXIT/10/,MJAC/5/
      DATA DAMP/0.75D0/
C
C
C---------------------------------------------------
C     BLOCK 1.
C     INITIALIZATIONS.
C---------------------------------------------------
C
C***FIRST EXECUTABLE STATEMENT  DDAINI
      IDID=1
      NEF=0
      NCF=0
      NSF=0
      XOLD=X
      YNORM=DDANRM(NEQ,Y,WT,RPAR,IPAR)
C
C     SAVE Y AND YPRIME IN PHI
      DO 100 I=1,NEQ
         PHI(I,1)=Y(I)
100      PHI(I,2)=YPRIME(I)
C
C
C----------------------------------------------------
C     BLOCK 2.
C     DO ONE BACKWARD EULER STEP.
C----------------------------------------------------
C
C     SET UP FOR START OF CORRECTOR ITERATION
200   CJ=1.0D0/H
      X=X+H
C
C     PREDICT SOLUTION AND DERIVATIVE
      DO 250 I=1,NEQ
250     Y(I)=Y(I)+H*YPRIME(I)
C
      JCALC=-1
      M=0
      CONVGD=.TRUE.
C
C
C     CORRECTOR LOOP.
300   IWM(LNRE)=IWM(LNRE)+1
      IRES=0
C
      CALL RES(X,Y,YPRIME,DELTA,IRES,RPAR,IPAR)
      IF(IRES.LT.0) GO TO 430
C
C
C     EVALUATE THE ITERATION MATRIX
      IF(JCALC.NE.-1) GO TO 310
      IWM(LNJE)=IWM(LNJE)+1
      JCALC=0
      CALL DDAJAC(NEQ,X,Y,YPRIME,DELTA,CJ,H,
     *   IER,WT,E,WM,IWM,RES,IRES,
     *   UROUND,JAC,RPAR,IPAR,NTEMP)
C
      S=1000000.D0
      IF(IRES.LT.0) GO TO 430
      IF(IER.NE.0) GO TO 430
      NSF=0
C
C
C
C     MULTIPLY RESIDUAL BY DAMPING FACTOR
310   CONTINUE
      DO 320 I=1,NEQ
320      DELTA(I)=DELTA(I)*DAMP
C
C     COMPUTE A NEW ITERATE (BACK SUBSTITUTION)
C     STORE THE CORRECTION IN DELTA
C
      CALL DDASLV(NEQ,DELTA,WM,IWM)
C
C     UPDATE Y AND YPRIME
      DO 330 I=1,NEQ
         Y(I)=Y(I)-DELTA(I)
330      YPRIME(I)=YPRIME(I)-CJ*DELTA(I)
C
C     TEST FOR CONVERGENCE OF THE ITERATION.
C
      DELNRM=DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      IF(DELNRM.LE.100.D0*UROUND*YNORM)
     *   GO TO 400
C
      IF(M.GT.0) GO TO 340
         OLDNRM=DELNRM
         GO TO 350
C
340   RATE=(DELNRM/OLDNRM)**(1.0D0/M)
      IF(RATE.GT.0.90D0) GO TO 430
      S=RATE/(1.0D0-RATE)
C
350   IF(S*DELNRM .LE. 0.33D0) GO TO 400
C
C
C     THE CORRECTOR HAS NOT YET CONVERGED. UPDATE
C     M AND AND TEST WHETHER THE MAXIMUM
C     NUMBER OF ITERATIONS HAVE BEEN TRIED.
C     EVERY MJAC ITERATIONS, GET A NEW
C     ITERATION MATRIX.
C
      M=M+1
      IF(M.GE.MAXIT) GO TO 430
C
      IF((M/MJAC)*MJAC.EQ.M) JCALC=-1
      GO TO 300
C
C
C     THE ITERATION HAS CONVERGED.
C     CHECK NONNEGATIVITY CONSTRAINTS
400   IF(NONNEG.EQ.0) GO TO 450
      DO 410 I=1,NEQ
410      DELTA(I)=MIN(Y(I),0.0D0)
C
      DELNRM=DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      IF(DELNRM.GT.0.33D0) GO TO 430
C
      DO 420 I=1,NEQ
         Y(I)=Y(I)-DELTA(I)
420      YPRIME(I)=YPRIME(I)-CJ*DELTA(I)
      GO TO 450
C
C
C     EXITS FROM CORRECTOR LOOP.
430   CONVGD=.FALSE.
450   IF(.NOT.CONVGD) GO TO 600
C
C
C
C-----------------------------------------------------
C     BLOCK 3.
C     THE CORRECTOR ITERATION CONVERGED.
C     DO ERROR TEST.
C-----------------------------------------------------
C
      DO 510 I=1,NEQ
510      E(I)=Y(I)-PHI(I,1)
      ERR=DDANRM(NEQ,E,WT,RPAR,IPAR)
C
      IF(ERR.LE.1.0D0) RETURN
C
C
C
C--------------------------------------------------------
C     BLOCK 4.
C     THE BACKWARD EULER STEP FAILED. RESTORE X, Y
C     AND YPRIME TO THEIR ORIGINAL VALUES.
C     REDUCE STEPSIZE AND TRY AGAIN, IF
C     POSSIBLE.
C---------------------------------------------------------
C
600   CONTINUE
      X = XOLD
      DO 610 I=1,NEQ
         Y(I)=PHI(I,1)
610      YPRIME(I)=PHI(I,2)
C
      IF(CONVGD) GO TO 640
      IF(IER.EQ.0) GO TO 620
         NSF=NSF+1
         H=H*0.25D0
         IF(NSF.LT.3.AND.ABS(H).GE.HMIN) GO TO 690
         IDID=-12
         RETURN
620   IF(IRES.GT.-2) GO TO 630
         IDID=-12
         RETURN
630   NCF=NCF+1
      H=H*0.25D0
      IF(NCF.LT.10.AND.ABS(H).GE.HMIN) GO TO 690
         IDID=-12
         RETURN
C
640   NEF=NEF+1
      R=0.90D0/(2.0D0*ERR+0.0001D0)
      R=MAX(0.1D0,MIN(0.5D0,R))
      H=H*R
      IF(ABS(H).GE.HMIN.AND.NEF.LT.10) GO TO 690
         IDID=-12
         RETURN
690      GO TO 200
C
C-------------END OF SUBROUTINE DDAINI----------------------
      END
C
C#######################################################################
C
C                       D   D   A   J   A   C
C
C#######################################################################
C
*DECK DDAJAC
      SUBROUTINE DDAJAC (NEQ, X, Y, YPRIME, DELTA, CJ, H, IER, WT, E,
     *   WM, IWM, RES, IRES, UROUND, JAC, RPAR, IPAR, NTEMP)
C***BEGIN PROLOGUE  DDAJAC
C***SUBSIDIARY
C***PURPOSE  COMPUTE THE ITERATION MATRIX FOR DDASSL AND FORM THE
C            LU-DECOMPOSITION.
C***LIBRARY   SLATEC (DASSL)
C***TYPE      DOUBLE PRECISION (SDAJAC-S, DDAJAC-D)
C***AUTHOR  PETZOLD, LINDA R., (LLNL)
C***DESCRIPTION
C-----------------------------------------------------------------------
C     THIS ROUTINE COMPUTES THE ITERATION MATRIX
C     PD=DG/DY+CJ*DG/DYPRIME (WHERE G(X,Y,YPRIME)=0).
C     HERE PD IS COMPUTED BY THE USER-SUPPLIED
C     ROUTINE JAC IF IWM(MTYPE) IS 1 OR 4, AND
C     IT IS COMPUTED BY NUMERICAL FINITE DIFFERENCING
C     IF IWM(MTYPE)IS 2 OR 5
C     THE PARAMETERS HAVE THE FOLLOWING MEANINGS.
C     Y        = ARRAY CONTAINING PREDICTED VALUES
C     YPRIME   = ARRAY CONTAINING PREDICTED DERIVATIVES
C     DELTA    = RESIDUAL EVALUATED AT (X,Y,YPRIME)
C                (USED ONLY IF IWM(MTYPE)=2 OR 5)
C     CJ       = SCALAR PARAMETER DEFINING ITERATION MATRIX
C     H        = CURRENT STEPSIZE IN INTEGRATION
C     IER      = VARIABLE WHICH IS .NE. 0
C                IF ITERATION MATRIX IS SINGULAR,
C                AND 0 OTHERWISE.
C     WT       = VECTOR OF WEIGHTS FOR COMPUTING NORMS
C     E        = WORK SPACE (TEMPORARY) OF LENGTH NEQ
C     WM       = REAL WORK SPACE FOR MATRICES. ON
C                OUTPUT IT CONTAINS THE LU DECOMPOSITION
C                OF THE ITERATION MATRIX.
C     IWM      = INTEGER WORK SPACE CONTAINING
C                MATRIX INFORMATION
C     RES      = NAME OF THE EXTERNAL USER-SUPPLIED ROUTINE
C                TO EVALUATE THE RESIDUAL FUNCTION G(X,Y,YPRIME)
C     IRES     = FLAG WHICH IS EQUAL TO ZERO IF NO ILLEGAL VALUES
C                IN RES, AND LESS THAN ZERO OTHERWISE.  (IF IRES
C                IS LESS THAN ZERO, THE MATRIX WAS NOT COMPLETED)
C                IN THIS CASE (IF IRES .LT. 0), THEN IER = 0.
C     UROUND   = THE UNIT ROUNDOFF ERROR OF THE MACHINE BEING USED.
C     JAC      = NAME OF THE EXTERNAL USER-SUPPLIED ROUTINE
C                TO EVALUATE THE ITERATION MATRIX (THIS ROUTINE
C                IS ONLY USED IF IWM(MTYPE) IS 1 OR 4)
C-----------------------------------------------------------------------
C***ROUTINES CALLED  DGBFA, DGEFA
C***REVISION HISTORY  (YYMMDD)
C   830315  DATE WRITTEN
C   901009  FINISHED CONVERSION TO SLATEC 4.0 FORMAT (F.N.FRITSCH)
C   901010  MODIFIED THREE MAX CALLS TO BE ALL ON ONE LINE.  (FNF)
C   901019  MERGED CHANGES MADE BY C. ULRICH WITH SLATEC 4.0 FORMAT.
C   901026  ADDED EXPLICIT DECLARATIONS FOR ALL VARIABLES AND MINOR
C           COSMETIC CHANGES TO PROLOGUE.  (FNF)
C   901101  CORRECTED PURPOSE.  (FNF)
C***END PROLOGUE  DDAJAC
C
      INTEGER  NEQ, IER, IWM(*), IRES, IPAR(*), NTEMP
      DOUBLE PRECISION
     *   X, Y(*), YPRIME(*), DELTA(*), CJ, H, WT(*), E(*), WM(*),
     *   UROUND, RPAR(*)
      EXTERNAL  RES, JAC
C
      EXTERNAL  DGBFA, DGEFA
C
      INTEGER  I, I1, I2, II, IPSAVE, ISAVE, J, K, L, LENPD, LIPVT,
     *   LML, LMTYPE, LMU, MBA, MBAND, MEB1, MEBAND, MSAVE, MTYPE, N,
     *   NPD, NPDM1, NROW
      DOUBLE PRECISION  DEL, DELINV, SQUR, YPSAVE, YSAVE
C
      PARAMETER (NPD=1)
      PARAMETER (LML=1)
      PARAMETER (LMU=2)
      PARAMETER (LMTYPE=4)
      PARAMETER (LIPVT=21)
C
C***FIRST EXECUTABLE STATEMENT  DDAJAC
      IER = 0
      NPDM1=NPD-1
      MTYPE=IWM(LMTYPE)
      GO TO (100,200,300,400,500),MTYPE
C
C
C     DENSE USER-SUPPLIED MATRIX
100   LENPD=NEQ*NEQ
      DO 110 I=1,LENPD
110      WM(NPDM1+I)=0.0D0
      CALL JAC(X,Y,YPRIME,WM(NPD),CJ,RPAR,IPAR)
      GO TO 230
C
C
C     DENSE FINITE-DIFFERENCE-GENERATED MATRIX
200   IRES=0
      NROW=NPDM1
      SQUR = SQRT(UROUND)
      DO 210 I=1,NEQ
         DEL=SQUR*MAX(ABS(Y(I)),ABS(H*YPRIME(I)),ABS(WT(I)))
         DEL=SIGN(DEL,H*YPRIME(I))
         DEL=(Y(I)+DEL)-Y(I)
         YSAVE=Y(I)
         YPSAVE=YPRIME(I)
         Y(I)=Y(I)+DEL
         YPRIME(I)=YPRIME(I)+CJ*DEL
         CALL RES(X,Y,YPRIME,E,IRES,RPAR,IPAR)
         IF(IRES .LT. 0) RETURN
         DELINV=1.0D0/DEL
         DO 220 L=1,NEQ
220      WM(NROW+L)=(E(L)-DELTA(L))*DELINV
      NROW=NROW+NEQ
      Y(I)=YSAVE
      YPRIME(I)=YPSAVE
210   CONTINUE
C
C
C     DO DENSE-MATRIX LU DECOMPOSITION ON PD
230      CALL DGEFA(WM(NPD),NEQ,NEQ,IWM(LIPVT),IER)
      RETURN
C
C
C     DUMMY SECTION FOR IWM(MTYPE)=3
300   RETURN
C
C
C     BANDED USER-SUPPLIED MATRIX
400   LENPD=(2*IWM(LML)+IWM(LMU)+1)*NEQ
      DO 410 I=1,LENPD
410      WM(NPDM1+I)=0.0D0
      CALL JAC(X,Y,YPRIME,WM(NPD),CJ,RPAR,IPAR)
      MEBAND=2*IWM(LML)+IWM(LMU)+1
      GO TO 550
C
C
C     BANDED FINITE-DIFFERENCE-GENERATED MATRIX
500   MBAND=IWM(LML)+IWM(LMU)+1
      MBA=MIN(MBAND,NEQ)
      MEBAND=MBAND+IWM(LML)
      MEB1=MEBAND-1
      MSAVE=(NEQ/MBAND)+1
      ISAVE=NTEMP-1
      IPSAVE=ISAVE+MSAVE
      IRES=0
      SQUR=SQRT(UROUND)
      DO 540 J=1,MBA
         DO 510 N=J,NEQ,MBAND
          K= (N-J)/MBAND + 1
          WM(ISAVE+K)=Y(N)
          WM(IPSAVE+K)=YPRIME(N)
          DEL=SQUR*MAX(ABS(Y(N)),ABS(H*YPRIME(N)),ABS(WT(N)))
          DEL=SIGN(DEL,H*YPRIME(N))
          DEL=(Y(N)+DEL)-Y(N)
          Y(N)=Y(N)+DEL
510       YPRIME(N)=YPRIME(N)+CJ*DEL
      CALL RES(X,Y,YPRIME,E,IRES,RPAR,IPAR)
      IF(IRES .LT. 0) RETURN
      DO 530 N=J,NEQ,MBAND
          K= (N-J)/MBAND + 1
          Y(N)=WM(ISAVE+K)
          YPRIME(N)=WM(IPSAVE+K)
          DEL=SQUR*MAX(ABS(Y(N)),ABS(H*YPRIME(N)),ABS(WT(N)))
          DEL=SIGN(DEL,H*YPRIME(N))
          DEL=(Y(N)+DEL)-Y(N)
          DELINV=1.0D0/DEL
          I1=MAX(1,(N-IWM(LMU)))
          I2=MIN(NEQ,(N+IWM(LML)))
          II=N*MEB1-IWM(LML)+NPDM1
          DO 520 I=I1,I2
520         WM(II+I)=(E(I)-DELTA(I))*DELINV
530      CONTINUE
540   CONTINUE
C
C
C     DO LU DECOMPOSITION OF BANDED PD
550   CALL DGBFA(WM(NPD),MEBAND,NEQ,
     *    IWM(LML),IWM(LMU),IWM(LIPVT),IER)
      RETURN
C------END OF SUBROUTINE DDAJAC------
      END
C
C#######################################################################
C
C                       D   D   A   N   R   M   (FUNCTION)
C
C#######################################################################
C
*DECK DDANRM
      DOUBLE PRECISION FUNCTION DDANRM (NEQ, V, WT, RPAR, IPAR)
C***BEGIN PROLOGUE  DDANRM
C***SUBSIDIARY
C***PURPOSE  COMPUTE VECTOR NORM FOR DDASSL.
C***LIBRARY   SLATEC (DASSL)
C***TYPE      DOUBLE PRECISION (SDANRM-S, DDANRM-D)
C***AUTHOR  PETZOLD, LINDA R., (LLNL)
C***DESCRIPTION
C-----------------------------------------------------------------------
C     THIS FUNCTION ROUTINE COMPUTES THE WEIGHTED
C     ROOT-MEAN-SQUARE NORM OF THE VECTOR OF LENGTH
C     NEQ CONTAINED IN THE ARRAY V,WITH WEIGHTS
C     CONTAINED IN THE ARRAY WT OF LENGTH NEQ.
C        DDANRM=SQRT((1/NEQ)*SUM(V(I)/WT(I))**2)
C-----------------------------------------------------------------------
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   830315  DATE WRITTEN
C   901009  FINISHED CONVERSION TO SLATEC 4.0 FORMAT (F.N.FRITSCH)
C   901019  MERGED CHANGES MADE BY C. ULRICH WITH SLATEC 4.0 FORMAT.
C   901026  ADDED EXPLICIT DECLARATIONS FOR ALL VARIABLES AND MINOR
C           COSMETIC CHANGES TO PROLOGUE.  (FNF)
C***END PROLOGUE  DDANRM
C
      INTEGER  NEQ, IPAR(*)
      DOUBLE PRECISION  V(NEQ), WT(NEQ), RPAR(*)
C
      INTEGER  I
      DOUBLE PRECISION  SUM, VMAX
C
C***FIRST EXECUTABLE STATEMENT  DDANRM
      DDANRM = 0.0D0
      VMAX = 0.0D0
      DO 10 I = 1,NEQ
        IF(ABS(V(I)/WT(I)) .GT. VMAX) VMAX = ABS(V(I)/WT(I))
10      CONTINUE
      IF(VMAX .LE. 0.0D0) GO TO 30
      SUM = 0.0D0
      DO 20 I = 1,NEQ
20      SUM = SUM + ((V(I)/WT(I))/VMAX)**2
      DDANRM = VMAX*SQRT(SUM/NEQ)
30    CONTINUE
      RETURN
C------END OF FUNCTION DDANRM------
      END
C
C#######################################################################
C
C                       D   D   A   S   L   V
C
C#######################################################################
C
*DECK DDASLV
      SUBROUTINE DDASLV (NEQ, DELTA, WM, IWM)
C***BEGIN PROLOGUE  DDASLV
C***SUBSIDIARY
C***PURPOSE  LINEAR SYSTEM SOLVER FOR DDASSL.
C***LIBRARY   SLATEC (DASSL)
C***TYPE      DOUBLE PRECISION (SDASLV-S, DDASLV-D)
C***AUTHOR  PETZOLD, LINDA R., (LLNL)
C***DESCRIPTION
C-----------------------------------------------------------------------
C     THIS ROUTINE MANAGES THE SOLUTION OF THE LINEAR
C     SYSTEM ARISING IN THE NEWTON ITERATION.
C     MATRICES AND REAL TEMPORARY STORAGE AND
C     REAL INFORMATION ARE STORED IN THE ARRAY WM.
C     INTEGER MATRIX INFORMATION IS STORED IN
C     THE ARRAY IWM.
C     FOR A DENSE MATRIX, THE LINPACK ROUTINE
C     DGESL IS CALLED.
C     FOR A BANDED MATRIX,THE LINPACK ROUTINE
C     DGBSL IS CALLED.
C-----------------------------------------------------------------------
C***ROUTINES CALLED  DGBSL, DGESL
C***REVISION HISTORY  (YYMMDD)
C   830315  DATE WRITTEN
C   901009  FINISHED CONVERSION TO SLATEC 4.0 FORMAT (F.N.FRITSCH)
C   901019  MERGED CHANGES MADE BY C. ULRICH WITH SLATEC 4.0 FORMAT.
C   901026  ADDED EXPLICIT DECLARATIONS FOR ALL VARIABLES AND MINOR
C           COSMETIC CHANGES TO PROLOGUE.  (FNF)
C***END PROLOGUE  DDASLV
C
      INTEGER  NEQ, IWM(*)
      DOUBLE PRECISION  DELTA(*), WM(*)
C
      EXTERNAL  DGBSL, DGESL
C
      INTEGER  LIPVT, LML, LMU, LMTYPE, MEBAND, MTYPE, NPD
      PARAMETER (NPD=1)
      PARAMETER (LML=1)
      PARAMETER (LMU=2)
      PARAMETER (LMTYPE=4)
      PARAMETER (LIPVT=21)
C
C***FIRST EXECUTABLE STATEMENT  DDASLV
      MTYPE=IWM(LMTYPE)
      GO TO(100,100,300,400,400),MTYPE
C
C     DENSE MATRIX
100   CALL DGESL(WM(NPD),NEQ,NEQ,IWM(LIPVT),DELTA,0)
      RETURN
C
C     DUMMY SECTION FOR MTYPE=3
300   CONTINUE
      RETURN
C
C     BANDED MATRIX
400   MEBAND=2*IWM(LML)+IWM(LMU)+1
      CALL DGBSL(WM(NPD),MEBAND,NEQ,IWM(LML),
     *  IWM(LMU),IWM(LIPVT),DELTA,0)
      RETURN
C------END OF SUBROUTINE DDASLV------
      END
C*DECK DGBFA
CC
CC#######################################################################
CC
CC                       D   G   B   F   A 
CC
CC#######################################################################
CC
C      SUBROUTINE DGBFA (ABD, LDA, N, ML, MU, IPVT, INFO)
CC***BEGIN PROLOGUE  DGBFA
CC***PURPOSE  FACTOR A BAND MATRIX USING GAUSSIAN ELIMINATION.
CC***LIBRARY   SLATEC (LINPACK)
CC***CATEGORY  D2A2
CC***TYPE      DOUBLE PRECISION (SGBFA-S, DGBFA-D, CGBFA-C)
CC***KEYWORDS  BANDED, LINEAR ALGEBRA, LINPACK, MATRIX FACTORIZATION
CC***AUTHOR  MOLER, C. B., (U. OF NEW MEXICO)
CC***DESCRIPTION
CC
CC     DGBFA FACTORS A DOUBLE PRECISION BAND MATRIX BY ELIMINATION.
CC
CC     DGBFA IS USUALLY CALLED BY DGBCO, BUT IT CAN BE CALLED
CC     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED.
CC
CC     ON ENTRY
CC
CC        ABD     DOUBLE PRECISION(LDA, N)
CC                CONTAINS THE MATRIX IN BAND STORAGE.  THE COLUMNS
CC                OF THE MATRIX ARE STORED IN THE COLUMNS OF  ABD  AND
CC                THE DIAGONALS OF THE MATRIX ARE STORED IN ROWS
CC                ML+1 THROUGH 2*ML+MU+1 OF  ABD .
CC                SEE THE COMMENTS BELOW FOR DETAILS.
CC
CC        LDA     INTEGER
CC                THE LEADING DIMENSION OF THE ARRAY  ABD .
CC                LDA MUST BE .GE. 2*ML + MU + 1 .
CC
CC        N       INTEGER
CC                THE ORDER OF THE ORIGINAL MATRIX.
CC
CC        ML      INTEGER
CC                NUMBER OF DIAGONALS BELOW THE MAIN DIAGONAL.
CC                0 .LE. ML .LT.  N .
CC
CC        MU      INTEGER
CC                NUMBER OF DIAGONALS ABOVE THE MAIN DIAGONAL.
CC                0 .LE. MU .LT.  N .
CC                MORE EFFICIENT IF  ML .LE. MU .
CC     ON RETURN
CC
CC        ABD     AN UPPER TRIANGULAR MATRIX IN BAND STORAGE AND
CC                THE MULTIPLIERS WHICH WERE USED TO OBTAIN IT.
CC                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
CC                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
CC                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
CC
CC        IPVT    INTEGER(N)
CC                AN INTEGER VECTOR OF PIVOT INDICES.
CC
CC        INFO    INTEGER
CC                = 0  NORMAL VALUE.
CC                = K  IF  U(K,K) .EQ. 0.0 .  THIS IS NOT AN ERROR
CC                     CONDITION FOR THIS SUBROUTINE, BUT IT DOES
CC                     INDICATE THAT DGBSL WILL DIVIDE BY ZERO IF
CC                     CALLED.  USE  RCOND  IN DGBCO FOR A RELIABLE
CC                     INDICATION OF SINGULARITY.
CC
CC     BAND STORAGE
CC
CC           IF  A  IS A BAND MATRIX, THE FOLLOWING PROGRAM SEGMENT
CC           WILL SET UP THE INPUT.
CC
CC                   ML = (BAND WIDTH BELOW THE DIAGONAL)
CC                   MU = (BAND WIDTH ABOVE THE DIAGONAL)
CC                   M = ML + MU + 1
CC                   DO 20 J = 1, N
CC                      I1 = MAX(1, J-MU)
CC                      I2 = MIN(N, J+ML)
CC                      DO 10 I = I1, I2
CC                         K = I - J + M
CC                         ABD(K,J) = A(I,J)
CC                10    CONTINUE
CC                20 CONTINUE
CC
CC           THIS USES ROWS  ML+1  THROUGH  2*ML+MU+1  OF  ABD .
CC           IN ADDITION, THE FIRST  ML  ROWS IN  ABD  ARE USED FOR
CC           ELEMENTS GENERATED DURING THE TRIANGULARIZATION.
CC           THE TOTAL NUMBER OF ROWS NEEDED IN  ABD  IS  2*ML+MU+1 .
CC           THE  ML+MU BY ML+MU  UPPER LEFT TRIANGLE AND THE
CC           ML BY ML  LOWER RIGHT TRIANGLE ARE NOT REFERENCED.
CC
CC***REFERENCES  J. J. DONGARRA, J. R. BUNCH, C. B. MOLER, AND G. W.
CC                 STEWART, LINPACK USERS' GUIDE, SIAM, 1979.
CC***ROUTINES CALLED  DAXPY, DSCAL, IDAMAX
CC***REVISION HISTORY  (YYMMDD)
CC   780814  DATE WRITTEN
CC   890531  CHANGED ALL SPECIFIC INTRINSICS TO GENERIC.  (WRB)
CC   890831  MODIFIED ARRAY DECLARATIONS.  (WRB)
CC   890831  REVISION DATE FROM VERSION 3.2
CC   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
CC   900326  REMOVED DUPLICATE INFORMATION FROM DESCRIPTION SECTION.
CC           (WRB)
CC   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
CC***END PROLOGUE  DGBFA
C      INTEGER LDA,N,ML,MU,IPVT(*),INFO
C      DOUBLE PRECISION ABD(LDA,*)
CC
C      DOUBLE PRECISION T
C      INTEGER I,IDAMAX,I0,J,JU,JZ,J0,J1,K,KP1,L,LM,M,MM,NM1
CC
CC***FIRST EXECUTABLE STATEMENT  DGBFA
C      M = ML + MU + 1
C      INFO = 0
CC
CC     ZERO INITIAL FILL-IN COLUMNS
CC
C      J0 = MU + 2
C      J1 = MIN(N,M) - 1
C      IF(J1 .LT. J0) GO TO 30
C      DO 20 JZ = J0, J1
C         I0 = M + 1 - JZ
C         DO 10 I = I0, ML
C            ABD(I,JZ) = 0.0D0
C   10    CONTINUE
C   20 CONTINUE
C   30 CONTINUE
C      JZ = J1
C      JU = 0
CC
CC     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING
CC
C      NM1 = N - 1
C      IF(NM1 .LT. 1) GO TO 130
C      DO 120 K = 1, NM1
C         KP1 = K + 1
CC
CC        ZERO NEXT FILL-IN COLUMN
CC
C         JZ = JZ + 1
C         IF(JZ .GT. N) GO TO 50
C         IF(ML .LT. 1) GO TO 50
C            DO 40 I = 1, ML
C               ABD(I,JZ) = 0.0D0
C   40       CONTINUE
C   50    CONTINUE
CC
CC        FIND L = PIVOT INDEX
CC
C         LM = MIN(ML,N-K)
C         L = IDAMAX(LM+1,ABD(M,K),1) + M - 1
C         IPVT(K) = L + K - M
CC
CC        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED
CC
C         IF(ABD(L,K) .EQ. 0.0D0) GO TO 100
CC
CC           INTERCHANGE IF NECESSARY
CC
C            IF(L .EQ. M) GO TO 60
C               T = ABD(L,K)
C               ABD(L,K) = ABD(M,K)
C               ABD(M,K) = T
C   60       CONTINUE
CC
CC           COMPUTE MULTIPLIERS
CC
C            T = -1.0D0/ABD(M,K)
C            CALL DSCAL(LM,T,ABD(M+1,K),1)
CC
CC           ROW ELIMINATION WITH COLUMN INDEXING
CC
C            JU = MIN(MAX(JU,MU+IPVT(K)),N)
C            MM = M
C            IF(JU .LT. KP1) GO TO 90
C            DO 80 J = KP1, JU
C               L = L - 1
C               MM = MM - 1
C               T = ABD(L,J)
C               IF(L .EQ. MM) GO TO 70
C                  ABD(L,J) = ABD(MM,J)
C                  ABD(MM,J) = T
C   70          CONTINUE
C               CALL DAXPY(LM,T,ABD(M+1,K),1,ABD(MM+1,J),1)
C   80       CONTINUE
C   90       CONTINUE
C         GO TO 110
C  100    CONTINUE
C            INFO = K
C  110    CONTINUE
C  120 CONTINUE
C  130 CONTINUE
C      IPVT(N) = N
C      IF(ABD(M,N) .EQ. 0.0D0) INFO = N
C      RETURN
C      END
CC
CC#######################################################################
CC
CC                       D   G   B   S   L
CC
CC#######################################################################
CC
C*DECK DGBSL
C      SUBROUTINE DGBSL (ABD, LDA, N, ML, MU, IPVT, B, JOB)
CC***BEGIN PROLOGUE  DGBSL
CC***PURPOSE  SOLVE THE REAL BAND SYSTEM A*X=B OR TRANS(A)*X=B USING
CC            THE FACTORS COMPUTED BY DGBCO OR DGBFA.
CC***LIBRARY   SLATEC (LINPACK)
CC***CATEGORY  D2A2
CC***TYPE      DOUBLE PRECISION (SGBSL-S, DGBSL-D, CGBSL-C)
CC***KEYWORDS  BANDED, LINEAR ALGEBRA, LINPACK, MATRIX, SOLVE
CC***AUTHOR  MOLER, C. B., (U. OF NEW MEXICO)
CC***DESCRIPTION
CC
CC     DGBSL SOLVES THE DOUBLE PRECISION BAND SYSTEM
CC     A * X = B  OR  TRANS(A) * X = B
CC     USING THE FACTORS COMPUTED BY DGBCO OR DGBFA.
CC
CC     ON ENTRY
CC
CC        ABD     DOUBLE PRECISION(LDA, N)
CC                THE OUTPUT FROM DGBCO OR DGBFA.
CC
CC        LDA     INTEGER
CC                THE LEADING DIMENSION OF THE ARRAY  ABD .
CC
CC        N       INTEGER
CC                THE ORDER OF THE ORIGINAL MATRIX.
CC
CC        ML      INTEGER
CC                NUMBER OF DIAGONALS BELOW THE MAIN DIAGONAL.
CC
CC        MU      INTEGER
CC                NUMBER OF DIAGONALS ABOVE THE MAIN DIAGONAL.
CC
CC        IPVT    INTEGER(N)
CC                THE PIVOT VECTOR FROM DGBCO OR DGBFA.
CC
CC        B       DOUBLE PRECISION(N)
CC                THE RIGHT HAND SIDE VECTOR.
CC
CC        JOB     INTEGER
CC                = 0         TO SOLVE  A*X = B ,
CC                = NONZERO   TO SOLVE  TRANS(A)*X = B , WHERE
CC                            TRANS(A)  IS THE TRANSPOSE.
CC
CC     ON RETURN
CC
CC        B       THE SOLUTION VECTOR  X .
CC
CC     ERROR CONDITION
CC
CC        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A
CC        ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES SINGULARITY
CC        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER
CC        SETTING OF LDA .  IT WILL NOT OCCUR IF THE SUBROUTINES ARE
CC        CALLED CORRECTLY AND IF DGBCO HAS SET RCOND .GT. 0.0
CC        OR DGBFA HAS SET INFO .EQ. 0 .
CC
CC     TO COMPUTE  INVERSE(A) * C  WHERE  C  IS A MATRIX
CC     WITH  P  COLUMNS
CC           CALL DGBCO(ABD,LDA,N,ML,MU,IPVT,RCOND,Z)
CC           IF(RCOND IS TOO SMALL) GO TO ...
CC           DO 10 J = 1, P
CC              CALL DGBSL(ABD,LDA,N,ML,MU,IPVT,C(1,J),0)
CC        10 CONTINUE
CC
CC***REFERENCES  J. J. DONGARRA, J. R. BUNCH, C. B. MOLER, AND G. W.
CC                 STEWART, LINPACK USERS' GUIDE, SIAM, 1979.
CC***ROUTINES CALLED  DAXPY, DDOT
CC***REVISION HISTORY  (YYMMDD)
CC   780814  DATE WRITTEN
CC   890531  CHANGED ALL SPECIFIC INTRINSICS TO GENERIC.  (WRB)
CC   890831  MODIFIED ARRAY DECLARATIONS.  (WRB)
CC   890831  REVISION DATE FROM VERSION 3.2
CC   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
CC   900326  REMOVED DUPLICATE INFORMATION FROM DESCRIPTION SECTION.
CC           (WRB)
CC   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
CC***END PROLOGUE  DGBSL
C      INTEGER LDA,N,ML,MU,IPVT(*),JOB
C      DOUBLE PRECISION ABD(LDA,*),B(*)
CC
C      DOUBLE PRECISION DDOT,T
C      INTEGER K,KB,L,LA,LB,LM,M,NM1
CC***FIRST EXECUTABLE STATEMENT  DGBSL
C      M = MU + ML + 1
C      NM1 = N - 1
C      IF(JOB .NE. 0) GO TO 50
CC
CC        JOB = 0 , SOLVE  A * X = B
CC        FIRST SOLVE L*Y = B
CC
C         IF(ML .EQ. 0) GO TO 30
C         IF(NM1 .LT. 1) GO TO 30
C            DO 20 K = 1, NM1
C               LM = MIN(ML,N-K)
C               L = IPVT(K)
C               T = B(L)
C               IF(L .EQ. K) GO TO 10
C                  B(L) = B(K)
C                  B(K) = T
C   10          CONTINUE
C               CALL DAXPY(LM,T,ABD(M+1,K),1,B(K+1),1)
C   20       CONTINUE
C   30    CONTINUE
CC
CC        NOW SOLVE  U*X = Y
CC
C         DO 40 KB = 1, N
C            K = N + 1 - KB
C            B(K) = B(K)/ABD(M,K)
C            LM = MIN(K,M) - 1
C            LA = M - LM
C            LB = K - LM
C            T = -B(K)
C            CALL DAXPY(LM,T,ABD(LA,K),1,B(LB),1)
C   40    CONTINUE
C      GO TO 100
C   50 CONTINUE
CC
CC        JOB = NONZERO, SOLVE  TRANS(A) * X = B
CC        FIRST SOLVE  TRANS(U)*Y = B
CC
C         DO 60 K = 1, N
C            LM = MIN(K,M) - 1
C            LA = M - LM
C            LB = K - LM
C            T = DDOT(LM,ABD(LA,K),1,B(LB),1)
C            B(K) = (B(K) - T)/ABD(M,K)
C   60    CONTINUE
CC
CC        NOW SOLVE TRANS(L)*X = Y
CC
C         IF(ML .EQ. 0) GO TO 90
C         IF(NM1 .LT. 1) GO TO 90
C            DO 80 KB = 1, NM1
C               K = N - KB
C               LM = MIN(ML,N-K)
C               B(K) = B(K) + DDOT(LM,ABD(M+1,K),1,B(K+1),1)
C               L = IPVT(K)
C               IF(L .EQ. K) GO TO 70
C                  T = B(L)
C                  B(L) = B(K)
C                  B(K) = T
C   70          CONTINUE
C   80       CONTINUE
C   90    CONTINUE
C  100 CONTINUE
C      RETURN
C      END
CC
CC#######################################################################
CC
CC                       D   G   E   F   A 
CC
CC#######################################################################
CC
C*DECK DGEFA
C      SUBROUTINE DGEFA (A, LDA, N, IPVT, INFO)
CC***BEGIN PROLOGUE  DGEFA
CC***PURPOSE  FACTOR A MATRIX USING GAUSSIAN ELIMINATION.
CC***LIBRARY   SLATEC (LINPACK)
CC***CATEGORY  D2A1
CC***TYPE      DOUBLE PRECISION (SGEFA-S, DGEFA-D, CGEFA-C)
CC***KEYWORDS  GENERAL MATRIX, LINEAR ALGEBRA, LINPACK,
CC             MATRIX FACTORIZATION
CC***AUTHOR  MOLER, C. B., (U. OF NEW MEXICO)
CC***DESCRIPTION
CC
CC     DGEFA FACTORS A DOUBLE PRECISION MATRIX BY GAUSSIAN ELIMINATION.
CC
CC     DGEFA IS USUALLY CALLED BY DGECO, BUT IT CAN BE CALLED
CC     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED.
CC     (TIME FOR DGECO) = (1 + 9/N)*(TIME FOR DGEFA) .
CC
CC     ON ENTRY
CC
CC        A       DOUBLE PRECISION(LDA, N)
CC                THE MATRIX TO BE FACTORED.
CC
CC        LDA     INTEGER
CC                THE LEADING DIMENSION OF THE ARRAY  A .
CC
CC        N       INTEGER
CC                THE ORDER OF THE MATRIX  A .
CC
CC     ON RETURN
CC
CC        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS
CC                WHICH WERE USED TO OBTAIN IT.
CC                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
CC                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
CC                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
CC
CC        IPVT    INTEGER(N)
CC                AN INTEGER VECTOR OF PIVOT INDICES.
CC
CC        INFO    INTEGER
CC                = 0  NORMAL VALUE.
CC                = K  IF  U(K,K) .EQ. 0.0 .  THIS IS NOT AN ERROR
CC                     CONDITION FOR THIS SUBROUTINE, BUT IT DOES
CC                     INDICATE THAT DGESL OR DGEDI WILL DIVIDE BY ZERO
CC                     IF CALLED.  USE  RCOND  IN DGECO FOR A RELIABLE
CC                     INDICATION OF SINGULARITY.
CC
CC***REFERENCES  J. J. DONGARRA, J. R. BUNCH, C. B. MOLER, AND G. W.
CC                 STEWART, LINPACK USERS' GUIDE, SIAM, 1979.
CC***ROUTINES CALLED  DAXPY, DSCAL, IDAMAX
CC***REVISION HISTORY  (YYMMDD)
CC   780814  DATE WRITTEN
CC   890831  MODIFIED ARRAY DECLARATIONS.  (WRB)
CC   890831  REVISION DATE FROM VERSION 3.2
CC   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
CC   900326  REMOVED DUPLICATE INFORMATION FROM DESCRIPTION SECTION.
CC           (WRB)
CC   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
CC***END PROLOGUE  DGEFA
C      INTEGER LDA,N,IPVT(*),INFO
C      DOUBLE PRECISION A(LDA,*)
CC
C      DOUBLE PRECISION T
C      INTEGER IDAMAX,J,K,KP1,L,NM1
CC
CC     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING
CC
CC***FIRST EXECUTABLE STATEMENT  DGEFA
C      INFO = 0
C      NM1 = N - 1
C      IF(NM1 .LT. 1) GO TO 70
C      DO 60 K = 1, NM1
C         KP1 = K + 1
CC
CC        FIND L = PIVOT INDEX
CC
C         L = IDAMAX(N-K+1,A(K,K),1) + K - 1
C         IPVT(K) = L
CC
CC        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED
CC
C         IF(A(L,K) .EQ. 0.0D0) GO TO 40
CC
CC           INTERCHANGE IF NECESSARY
CC
C            IF(L .EQ. K) GO TO 10
C               T = A(L,K)
C               A(L,K) = A(K,K)
C               A(K,K) = T
C   10       CONTINUE
CC
CC           COMPUTE MULTIPLIERS
CC
C            T = -1.0D0/A(K,K)
C            CALL DSCAL(N-K,T,A(K+1,K),1)
CC
CC           ROW ELIMINATION WITH COLUMN INDEXING
CC
C            DO 30 J = KP1, N
C               T = A(L,J)
C               IF(L .EQ. K) GO TO 20
C                  A(L,J) = A(K,J)
C                  A(K,J) = T
C   20          CONTINUE
C               CALL DAXPY(N-K,T,A(K+1,K),1,A(K+1,J),1)
C   30       CONTINUE
C         GO TO 50
C   40    CONTINUE
C            INFO = K
C   50    CONTINUE
C   60 CONTINUE
C   70 CONTINUE
C      IPVT(N) = N
C      IF(A(N,N) .EQ. 0.0D0) INFO = N
C      RETURN
C      END
CC
CC#######################################################################
CC
CC                       D   G   E   S   L 
CC
CC#######################################################################
CC
C*DECK DGESL
C      SUBROUTINE DGESL (A, LDA, N, IPVT, B, JOB)
CC***BEGIN PROLOGUE  DGESL
CC***PURPOSE  SOLVE THE REAL SYSTEM A*X=B OR TRANS(A)*X=B USING THE
CC            FACTORS COMPUTED BY DGECO OR DGEFA.
CC***LIBRARY   SLATEC (LINPACK)
CC***CATEGORY  D2A1
CC***TYPE      DOUBLE PRECISION (SGESL-S, DGESL-D, CGESL-C)
CC***KEYWORDS  LINEAR ALGEBRA, LINPACK, MATRIX, SOLVE
CC***AUTHOR  MOLER, C. B., (U. OF NEW MEXICO)
CC***DESCRIPTION
CC
CC     DGESL SOLVES THE DOUBLE PRECISION SYSTEM
CC     A * X = B  OR  TRANS(A) * X = B
CC     USING THE FACTORS COMPUTED BY DGECO OR DGEFA.
CC
CC     ON ENTRY
CC
CC        A       DOUBLE PRECISION(LDA, N)
CC                THE OUTPUT FROM DGECO OR DGEFA.
CC
CC        LDA     INTEGER
CC                THE LEADING DIMENSION OF THE ARRAY  A .
CC
CC        N       INTEGER
CC                THE ORDER OF THE MATRIX  A .
CC
CC        IPVT    INTEGER(N)
CC                THE PIVOT VECTOR FROM DGECO OR DGEFA.
CC
CC        B       DOUBLE PRECISION(N)
CC                THE RIGHT HAND SIDE VECTOR.
CC
CC        JOB     INTEGER
CC                = 0         TO SOLVE  A*X = B ,
CC                = NONZERO   TO SOLVE  TRANS(A)*X = B  WHERE
CC                            TRANS(A)  IS THE TRANSPOSE.
CC
CC     ON RETURN
CC
CC        B       THE SOLUTION VECTOR  X .
CC
CC     ERROR CONDITION
CC
CC        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A
CC        ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES SINGULARITY
CC        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER
CC        SETTING OF LDA .  IT WILL NOT OCCUR IF THE SUBROUTINES ARE
CC        CALLED CORRECTLY AND IF DGECO HAS SET RCOND .GT. 0.0
CC        OR DGEFA HAS SET INFO .EQ. 0 .
CC
CC     TO COMPUTE  INVERSE(A) * C  WHERE  C  IS A MATRIX
CC     WITH  P  COLUMNS
CC           CALL DGECO(A,LDA,N,IPVT,RCOND,Z)
CC           IF(RCOND IS TOO SMALL) GO TO ...
CC           DO 10 J = 1, P
CC              CALL DGESL(A,LDA,N,IPVT,C(1,J),0)
CC        10 CONTINUE
CC
CC***REFERENCES  J. J. DONGARRA, J. R. BUNCH, C. B. MOLER, AND G. W.
CC                 STEWART, LINPACK USERS' GUIDE, SIAM, 1979.
CC***ROUTINES CALLED  DAXPY, DDOT
CC***REVISION HISTORY  (YYMMDD)
CC   780814  DATE WRITTEN
CC   890831  MODIFIED ARRAY DECLARATIONS.  (WRB)
CC   890831  REVISION DATE FROM VERSION 3.2
CC   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
CC   900326  REMOVED DUPLICATE INFORMATION FROM DESCRIPTION SECTION.
CC           (WRB)
CC   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
CC***END PROLOGUE  DGESL
C      INTEGER LDA,N,IPVT(*),JOB
C      DOUBLE PRECISION A(LDA,*),B(*)
CC
C      DOUBLE PRECISION DDOT,T
C      INTEGER K,KB,L,NM1
CC***FIRST EXECUTABLE STATEMENT  DGESL
C      NM1 = N - 1
C      IF(JOB .NE. 0) GO TO 50
CC
CC        JOB = 0 , SOLVE  A * X = B
CC        FIRST SOLVE  L*Y = B
CC
C         IF(NM1 .LT. 1) GO TO 30
C         DO 20 K = 1, NM1
C            L = IPVT(K)
C            T = B(L)
C            IF(L .EQ. K) GO TO 10
C               B(L) = B(K)
C               B(K) = T
C   10       CONTINUE
C            CALL DAXPY(N-K,T,A(K+1,K),1,B(K+1),1)
C   20    CONTINUE
C   30    CONTINUE
CC
CC        NOW SOLVE  U*X = Y
CC
C         DO 40 KB = 1, N
C            K = N + 1 - KB
C            B(K) = B(K)/A(K,K)
C            T = -B(K)
C            CALL DAXPY(K-1,T,A(1,K),1,B(1),1)
C   40    CONTINUE
C      GO TO 100
C   50 CONTINUE
CC
CC        JOB = NONZERO, SOLVE  TRANS(A) * X = B
CC        FIRST SOLVE  TRANS(U)*Y = B
CC
C         DO 60 K = 1, N
C            T = DDOT(K-1,A(1,K),1,B(1),1)
C            B(K) = (B(K) - T)/A(K,K)
C   60    CONTINUE
CC
CC        NOW SOLVE TRANS(L)*X = Y
CC
C         IF(NM1 .LT. 1) GO TO 90
C         DO 80 KB = 1, NM1
C            K = N - KB
C            B(K) = B(K) + DDOT(N-K,A(K+1,K),1,B(K+1),1)
C            L = IPVT(K)
C            IF(L .EQ. K) GO TO 70
C               T = B(L)
C               B(L) = B(K)
C               B(K) = T
C   70       CONTINUE
C   80    CONTINUE
C   90    CONTINUE
C  100 CONTINUE
C      RETURN
C      END
C
C#######################################################################
C
C                       D   S   C   A   L 
C
C#######################################################################
C
*DECK DSCAL
CC      SUBROUTINE DSCAL (N, DA, DX, INCX)
C***BEGIN PROLOGUE  DSCAL
C***PURPOSE  MULTIPLY A VECTOR BY A CONSTANT.
C***LIBRARY   SLATEC (BLAS)
C***CATEGORY  D1A6
C***TYPE      DOUBLE PRECISION (SSCAL-S, DSCAL-D, CSCAL-C)
C***KEYWORDS  BLAS, LINEAR ALGEBRA, SCALE, VECTOR
C***AUTHOR  LAWSON, C. L., (JPL)
C           HANSON, R. J., (SNLA)
C           KINCAID, D. R., (U. OF TEXAS)
C           KROGH, F. T., (JPL)
C***DESCRIPTION
C
C                B L A S  SUBPROGRAM
C    DESCRIPTION OF PARAMETERS
C
C     --INPUT--
C        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S)
C       DA  DOUBLE PRECISION SCALE FACTOR
C       DX  DOUBLE PRECISION VECTOR WITH N ELEMENTS
C     INCX  STORAGE SPACING BETWEEN ELEMENTS OF DX
C
C     --OUTPUT--
C       DX  DOUBLE PRECISION RESULT (UNCHANGED IF N.LE.0)
C
C     REPLACE DOUBLE PRECISION DX BY DOUBLE PRECISION DA*DX.
C     FOR I = 0 TO N-1, REPLACE DX(IX+I*INCX) WITH  DA * DX(IX+I*INCX),
C     WHERE IX = 1 IF INCX .GE. 0, ELSE IX = 1+(1-N)*INCX.
C
C***REFERENCES  C. L. LAWSON, R. J. HANSON, D. R. KINCAID AND F. T.
C                 KROGH, BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN
C                 USAGE, ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL
C                 SOFTWARE 5, 3 (SEPTEMBER 1979), PP. 308-323.
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   791001  DATE WRITTEN
C   890831  MODIFIED ARRAY DECLARATIONS.  (WRB)
C   890831  REVISION DATE FROM VERSION 3.2
C   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
C   900821  MODIFIED TO CORRECT PROBLEM WITH A NEGATIVE INCREMENT.
C           (WRB)
C   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
C***END PROLOGUE  DSCAL
CC      DOUBLE PRECISION DA, DX(*)
CC      INTEGER I, INCX, IX, M, MP1, N
C***FIRST EXECUTABLE STATEMENT  DSCAL
CC      IF(N .LE. 0) RETURN
CC      IF(INCX .EQ. 1) GOTO 20
C
C     CODE FOR INCREMENT NOT EQUAL TO 1.
C
CC      IX = 1
CC      IF(INCX .LT. 0) IX = (-N+1)*INCX + 1
CC      DO 10 I = 1,N
CC        DX(IX) = DA*DX(IX)
CC        IX = IX + INCX
CC   10 CONTINUE
CC      RETURN
C
C     CODE FOR INCREMENT EQUAL TO 1.
C
C     CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 5.
C
CC   20 M = MOD(N,5)
CC      IF(M .EQ. 0) GOTO 40
CC      DO 30 I = 1,M
CC        DX(I) = DA*DX(I)
CC   30 CONTINUE
CC      IF(N .LT. 5) RETURN
CC   40 MP1 = M + 1
CC      DO 50 I = MP1,N,5
CC        DX(I) = DA*DX(I)
CC        DX(I+1) = DA*DX(I+1)
CC        DX(I+2) = DA*DX(I+2)
CC        DX(I+3) = DA*DX(I+3)
CC        DX(I+4) = DA*DX(I+4)
CC   50 CONTINUE
CC      RETURN
CC      END
C
C#######################################################################
C
C                       F   D   U   M   P 
C
C#######################################################################
C
*DECK FDUMP
      SUBROUTINE FDUMP
C***BEGIN PROLOGUE  FDUMP
C***PURPOSE  SYMBOLIC DUMP (SHOULD BE LOCALLY WRITTEN).
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3
C***TYPE      ALL (FDUMP-A)
C***KEYWORDS  ERROR, XERMSG
C***AUTHOR  JONES, R. E., (SNLA)
C***DESCRIPTION
C
C        ***NOTE*** MACHINE DEPENDENT ROUTINE
C        FDUMP IS INTENDED TO BE REPLACED BY A LOCALLY WRITTEN
C        VERSION WHICH PRODUCES A SYMBOLIC DUMP.  FAILING THIS,
C        IT SHOULD BE REPLACED BY A VERSION WHICH PRINTS THE
C        SUBPROGRAM NESTING LIST.  NOTE THAT THIS DUMP MUST BE
C        PRINTED ON EACH OF UP TO FIVE FILES, AS INDICATED BY THE
C        XGETUA ROUTINE.  SEE XSETUA AND XGETUA FOR DETAILS.
C
C     WRITTEN BY RON JONES, WITH SLATEC COMMON MATH LIBRARY SUBCOMMITTEE
C
C***REFERENCES  (NONE)
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   790801  DATE WRITTEN
C   861211  REVISION DATE FROM VERSION 3.2
C   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
C***END PROLOGUE  FDUMP
C***FIRST EXECUTABLE STATEMENT  FDUMP
      RETURN
      END
C
C#######################################################################
C
C                       I   D   A   M   A   X   (FUNCTION) 
C
C#######################################################################
C
*DECK IDAMAX
CC      INTEGER FUNCTION IDAMAX (N, DX, INCX)
C***BEGIN PROLOGUE  IDAMAX
C***PURPOSE  FIND THE SMALLEST INDEX OF THAT COMPONENT OF A VECTOR
C            HAVING THE MAXIMUM MAGNITUDE.
C***LIBRARY   SLATEC (BLAS)
C***CATEGORY  D1A2
C***TYPE      DOUBLE PRECISION (ISAMAX-S, IDAMAX-D, ICAMAX-C)
C***KEYWORDS  BLAS, LINEAR ALGEBRA, MAXIMUM COMPONENT, VECTOR
C***AUTHOR  LAWSON, C. L., (JPL)
C           HANSON, R. J., (SNLA)
C           KINCAID, D. R., (U. OF TEXAS)
C           KROGH, F. T., (JPL)
C***DESCRIPTION
C
C                B L A S  SUBPROGRAM
C    DESCRIPTION OF PARAMETERS
C
C     --INPUT--
C        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S)
C       DX  DOUBLE PRECISION VECTOR WITH N ELEMENTS
C     INCX  STORAGE SPACING BETWEEN ELEMENTS OF DX
C
C     --OUTPUT--
C   IDAMAX  SMALLEST INDEX (ZERO IF N .LE. 0)
C
C     FIND SMALLEST INDEX OF MAXIMUM MAGNITUDE OF DOUBLE PRECISION DX.
C     IDAMAX = FIRST I, I = 1 TO N, TO MAXIMIZE ABS(DX(IX+(I-1)*INCX)),
C     WHERE IX = 1 IF INCX .GE. 0, ELSE IX = 1+(1-N)*INCX.
C
C***REFERENCES  C. L. LAWSON, R. J. HANSON, D. R. KINCAID AND F. T.
C                 KROGH, BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN
C                 USAGE, ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL
C                 SOFTWARE 5, 3 (SEPTEMBER 1979), PP. 308-323.
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   791001  DATE WRITTEN
C   890531  CHANGED ALL SPECIFIC INTRINSICS TO GENERIC.  (WRB)
C   890531  REVISION DATE FROM VERSION 3.2
C   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
C   900821  MODIFIED TO CORRECT PROBLEM WITH A NEGATIVE INCREMENT.
C           (WRB)
C   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
C***END PROLOGUE  IDAMAX
CC      DOUBLE PRECISION DX(*), DMAX, XMAG
CC      INTEGER I, INCX, IX, N
C***FIRST EXECUTABLE STATEMENT  IDAMAX
CC      IDAMAX = 0
CC      IF(N .LE. 0) RETURN
CC      IDAMAX = 1
CC      IF(N .EQ. 1) RETURN
C
CC      IF(INCX .EQ. 1) GOTO 20
C
C     CODE FOR INCREMENTS NOT EQUAL TO 1.
C
CC      IX = 1
CC      IF(INCX .LT. 0) IX = (-N+1)*INCX + 1
CC      DMAX = ABS(DX(IX))
CC      IX = IX + INCX
CC      DO 10 I = 2,N
CC        XMAG = ABS(DX(IX))
CC        IF(XMAG .GT. DMAX) THEN
CC          IDAMAX = I
CC          DMAX = XMAG
CC        ENDIF
CC        IX = IX + INCX
CC   10 CONTINUE
CC      RETURN
C
C     CODE FOR INCREMENTS EQUAL TO 1.
C
CC   20 DMAX = ABS(DX(1))
CC      DO 30 I = 2,N
CC        XMAG = ABS(DX(I))
CC        IF(XMAG .GT. DMAX) THEN
CC          IDAMAX = I
CC          DMAX = XMAG
CC        ENDIF
CC   30 CONTINUE
CC      RETURN
CC      END
C
C#######################################################################
C
C                       J   4   S   A   V   E   (FUNCTION) 
C
C#######################################################################
C
*DECK J4SAVE
      FUNCTION J4SAVE (IWHICH, IVALUE, ISET)
C***BEGIN PROLOGUE  J4SAVE
C***SUBSIDIARY
C***PURPOSE  SAVE OR RECALL GLOBAL VARIABLES NEEDED BY ERROR
C            HANDLING ROUTINES.
C***LIBRARY   SLATEC (XERROR)
C***TYPE      INTEGER (J4SAVE-I)
C***KEYWORDS  ERROR MESSAGES, ERROR NUMBER, RECALL, SAVE, XERROR
C***AUTHOR  JONES, R. E., (SNLA)
C***DESCRIPTION
C
C     ABSTRACT
C        J4SAVE SAVES AND RECALLS SEVERAL GLOBAL VARIABLES NEEDED
C        BY THE LIBRARY ERROR HANDLING ROUTINES.
C
C     DESCRIPTION OF PARAMETERS
C      --INPUT--
C        IWHICH - INDEX OF ITEM DESIRED.
C                = 1 REFERS TO CURRENT ERROR NUMBER.
C                = 2 REFERS TO CURRENT ERROR CONTROL FLAG.
C                = 3 REFERS TO CURRENT UNIT NUMBER TO WHICH ERROR
C                    MESSAGES ARE TO BE SENT.  (0 MEANS USE STANDARD.)
C                = 4 REFERS TO THE MAXIMUM NUMBER OF TIMES ANY
C                     MESSAGE IS TO BE PRINTED (AS SET BY XERMAX).
C                = 5 REFERS TO THE TOTAL NUMBER OF UNITS TO WHICH
C                     EACH ERROR MESSAGE IS TO BE WRITTEN.
C                = 6 REFERS TO THE 2ND UNIT FOR ERROR MESSAGES
C                = 7 REFERS TO THE 3RD UNIT FOR ERROR MESSAGES
C                = 8 REFERS TO THE 4TH UNIT FOR ERROR MESSAGES
C                = 9 REFERS TO THE 5TH UNIT FOR ERROR MESSAGES
C        IVALUE - THE VALUE TO BE SET FOR THE IWHICH-TH PARAMETER,
C                 IF ISET IS .TRUE. .
C        ISET   - IF ISET=.TRUE., THE IWHICH-TH PARAMETER WILL BE
C                 GIVEN THE VALUE, IVALUE.  IF ISET=.FALSE., THE
C                 IWHICH-TH PARAMETER WILL BE UNCHANGED, AND IVALUE
C                 IS A DUMMY PARAMETER.
C      --OUTPUT--
C        THE (OLD) VALUE OF THE IWHICH-TH PARAMETER WILL BE RETURNED
C        IN THE FUNCTION VALUE, J4SAVE.
C
C***SEE ALSO  XERMSG
C***REFERENCES  R. E. JONES AND D. K. KAHANER, XERROR, THE SLATEC
C                 ERROR-HANDLING PACKAGE, SAND82-0800, SANDIA
C                 LABORATORIES, 1982.
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   790801  DATE WRITTEN
C   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
C   900205  MINOR MODIFICATIONS TO PROLOGUE.  (WRB)
C   900402  ADDED TYPE SECTION.  (WRB)
C   910411  ADDED KEYWORDS SECTION.  (WRB)
C   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
C***END PROLOGUE  J4SAVE
      LOGICAL ISET
      INTEGER IPARAM(9)
      SAVE IPARAM
      DATA IPARAM(1),IPARAM(2),IPARAM(3),IPARAM(4)/0,2,0,10/
      DATA IPARAM(5)/1/
      DATA IPARAM(6),IPARAM(7),IPARAM(8),IPARAM(9)/0,0,0,0/
C***FIRST EXECUTABLE STATEMENT  J4SAVE
      J4SAVE = IPARAM(IWHICH)
      IF(ISET) IPARAM(IWHICH) = IVALUE
      RETURN
      END
C
C#######################################################################
C
C                       X   E   R   C   N   T 
C
C#######################################################################
C
*DECK XERCNT
      SUBROUTINE XERCNT (LIBRAR, SUBROU, MESSG, NERR, LEVEL, KONTRL)
C***BEGIN PROLOGUE  XERCNT
C***SUBSIDIARY
C***PURPOSE  ALLOW USER CONTROL OVER HANDLING OF ERRORS.
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3C
C***TYPE      ALL (XERCNT-A)
C***KEYWORDS  ERROR, XERROR
C***AUTHOR  JONES, R. E., (SNLA)
C***DESCRIPTION
C
C     ABSTRACT
C        ALLOWS USER CONTROL OVER HANDLING OF INDIVIDUAL ERRORS.
C        JUST AFTER EACH MESSAGE IS RECORDED, BUT BEFORE IT IS
C        PROCESSED ANY FURTHER (I.E., BEFORE IT IS PRINTED OR
C        A DECISION TO ABORT IS MADE), A CALL IS MADE TO XERCNT.
C        IF THE USER HAS PROVIDED HIS OWN VERSION OF XERCNT, HE
C        CAN THEN OVERRIDE THE VALUE OF KONTROL USED IN PROCESSING
C        THIS MESSAGE BY REDEFINING ITS VALUE.
C        KONTRL MAY BE SET TO ANY VALUE FROM -2 TO 2.
C        THE MEANINGS FOR KONTRL ARE THE SAME AS IN XSETF, EXCEPT
C        THAT THE VALUE OF KONTRL CHANGES ONLY FOR THIS MESSAGE.
C        IF KONTRL IS SET TO A VALUE OUTSIDE THE RANGE FROM -2 TO 2,
C        IT WILL BE MOVED BACK INTO THAT RANGE.
C
C     DESCRIPTION OF PARAMETERS
C
C      --INPUT--
C        LIBRAR - THE LIBRARY THAT THE ROUTINE IS IN.
C        SUBROU - THE SUBROUTINE THAT XERMSG IS BEING CALLED FROM
C        MESSG  - THE FIRST 20 CHARACTERS OF THE ERROR MESSAGE.
C        NERR   - SAME AS IN THE CALL TO XERMSG.
C        LEVEL  - SAME AS IN THE CALL TO XERMSG.
C        KONTRL - THE CURRENT VALUE OF THE CONTROL FLAG AS SET
C                 BY A CALL TO XSETF.
C
C      --OUTPUT--
C        KONTRL - THE NEW VALUE OF KONTRL.  IF KONTRL IS NOT
C                 DEFINED, IT WILL REMAIN AT ITS ORIGINAL VALUE.
C                 THIS CHANGED VALUE OF CONTROL AFFECTS ONLY
C                 THE CURRENT OCCURRENCE OF THE CURRENT MESSAGE.
C
C***REFERENCES  R. E. JONES AND D. K. KAHANER, XERROR, THE SLATEC
C                 ERROR-HANDLING PACKAGE, SAND82-0800, SANDIA
C                 LABORATORIES, 1982.
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   790801  DATE WRITTEN
C   861211  REVISION DATE FROM VERSION 3.2
C   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
C   900206  ROUTINE CHANGED FROM USER-CALLABLE TO SUBSIDIARY.  (WRB)
C   900510  CHANGED CALLING SEQUENCE TO INCLUDE LIBRARY AND SUBROUTINE
C           NAMES, CHANGED ROUTINE NAME FROM XERCTL TO XERCNT.  (RWC)
C   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
C***END PROLOGUE  XERCNT
      CHARACTER*(*) LIBRAR, SUBROU, MESSG
C***FIRST EXECUTABLE STATEMENT  XERCNT
      RETURN
      END
C
C#######################################################################
C
C                       X   E   R   H   L   T 
C
C#######################################################################
C
*DECK XERHLT
      SUBROUTINE XERHLT (MESSG)
C***BEGIN PROLOGUE  XERHLT
C***SUBSIDIARY
C***PURPOSE  ABORT PROGRAM EXECUTION AND PRINT ERROR MESSAGE.
C***LIBRARY   SLATEC (XERROR)
C***CATEGORY  R3C
C***TYPE      ALL (XERHLT-A)
C***KEYWORDS  ABORT PROGRAM EXECUTION, ERROR, XERROR
C***AUTHOR  JONES, R. E., (SNLA)
C***DESCRIPTION
C
C     ABSTRACT
C        ***NOTE*** MACHINE DEPENDENT ROUTINE
C        XERHLT ABORTS THE EXECUTION OF THE PROGRAM.
C        THE ERROR MESSAGE CAUSING THE ABORT IS GIVEN IN THE CALLING
C        SEQUENCE, IN CASE ONE NEEDS IT FOR PRINTING ON A DAYFILE,
C        FOR EXAMPLE.
C
C     DESCRIPTION OF PARAMETERS
C        MESSG IS AS IN XERMSG.
C
C***REFERENCES  R. E. JONES AND D. K. KAHANER, XERROR, THE SLATEC
C                 ERROR-HANDLING PACKAGE, SAND82-0800, SANDIA
C                 LABORATORIES, 1982.
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   790801  DATE WRITTEN
C   861211  REVISION DATE FROM VERSION 3.2
C   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
C   900206  ROUTINE CHANGED FROM USER-CALLABLE TO SUBSIDIARY.  (WRB)
C   900510  CHANGED CALLING SEQUENCE TO DELETE LENGTH OF CHARACTER
C           AND CHANGED ROUTINE NAME FROM XERABT TO XERHLT.  (RWC)
C   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
C***END PROLOGUE  XERHLT
      CHARACTER*(*) MESSG
C***FIRST EXECUTABLE STATEMENT  XERHLT
      STOP
      END
C
C#######################################################################
C
C                       D   A   X   P   Y 
C
C#######################################################################
C
C*DECK DAXPY
C      SUBROUTINE DAXPY (N, DA, DX, INCX, DY, INCY)
CC***BEGIN PROLOGUE  DAXPY
CC***PURPOSE  COMPUTE A CONSTANT TIMES A VECTOR PLUS A VECTOR.
CC***LIBRARY   SLATEC (BLAS)
CC***CATEGORY  D1A7
CC***TYPE      DOUBLE PRECISION (SAXPY-S, DAXPY-D, CAXPY-C)
CC***KEYWORDS  BLAS, LINEAR ALGEBRA, TRIAD, VECTOR
CC***AUTHOR  LAWSON, C. L., (JPL)
CC           HANSON, R. J., (SNLA)
CC           KINCAID, D. R., (U. OF TEXAS)
CC           KROGH, F. T., (JPL)
CC***DESCRIPTION
CC
CC                B L A S  SUBPROGRAM
CC    DESCRIPTION OF PARAMETERS
CC
CC     --INPUT--
CC        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S)
CC       DA  DOUBLE PRECISION SCALAR MULTIPLIER
CC       DX  DOUBLE PRECISION VECTOR WITH N ELEMENTS
CC     INCX  STORAGE SPACING BETWEEN ELEMENTS OF DX
CC       DY  DOUBLE PRECISION VECTOR WITH N ELEMENTS
CC     INCY  STORAGE SPACING BETWEEN ELEMENTS OF DY
CC
CC     --OUTPUT--
CC       DY  DOUBLE PRECISION RESULT (UNCHANGED IF N .LE. 0)
CC
CC     OVERWRITE DOUBLE PRECISION DY WITH DOUBLE PRECISION DA*DX + DY.
CC     FOR I = 0 TO N-1, REPLACE  DY(LY+I*INCY) WITH DA*DX(LX+I*INCX) +
CC       DY(LY+I*INCY),
CC     WHERE LX = 1 IF INCX .GE. 0, ELSE LX = 1+(1-N)*INCX, AND LY IS
CC     DEFINED IN A SIMILAR WAY USING INCY.
CC
CC***REFERENCES  C. L. LAWSON, R. J. HANSON, D. R. KINCAID AND F. T.
CC                 KROGH, BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN
CC                 USAGE, ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL
CC                 SOFTWARE 5, 3 (SEPTEMBER 1979), PP. 308-323.
CC***ROUTINES CALLED  (NONE)
CC***REVISION HISTORY  (YYMMDD)
CC   791001  DATE WRITTEN
CC   890831  MODIFIED ARRAY DECLARATIONS.  (WRB)
CC   890831  REVISION DATE FROM VERSION 3.2
CC   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
CC   920310  CORRECTED DEFINITION OF LX IN DESCRIPTION.  (WRB)
CC   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
CC***END PROLOGUE  DAXPY
C      DOUBLE PRECISION DX(*), DY(*), DA
CC***FIRST EXECUTABLE STATEMENT  DAXPY
C      IF(N.LE.0 .OR. DA.EQ.0.0D0) RETURN
C      IF(INCX .EQ. INCY) IF(INCX-1) 5,20,60
CC
CC     CODE FOR UNEQUAL OR NONPOSITIVE INCREMENTS.
CC
C    5 IX = 1
C      IY = 1
C      IF(INCX .LT. 0) IX = (-N+1)*INCX + 1
C      IF(INCY .LT. 0) IY = (-N+1)*INCY + 1
C      DO 10 I = 1,N
C        DY(IY) = DY(IY) + DA*DX(IX)
C        IX = IX + INCX
C        IY = IY + INCY
C   10 CONTINUE
C      RETURN
CC
CC     CODE FOR BOTH INCREMENTS EQUAL TO 1.
CC
CC     CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 4.
CC
C   20 M = MOD(N,4)
C      IF(M .EQ. 0) GO TO 40
C      DO 30 I = 1,M
C        DY(I) = DY(I) + DA*DX(I)
C   30 CONTINUE
C      IF(N .LT. 4) RETURN
C   40 MP1 = M + 1
C      DO 50 I = MP1,N,4
C        DY(I) = DY(I) + DA*DX(I)
C        DY(I+1) = DY(I+1) + DA*DX(I+1)
C        DY(I+2) = DY(I+2) + DA*DX(I+2)
C        DY(I+3) = DY(I+3) + DA*DX(I+3)
C   50 CONTINUE
C      RETURN
CC
CC     CODE FOR EQUAL, POSITIVE, NON-UNIT INCREMENTS.
CC
C   60 NS = N*INCX
C      DO 70 I = 1,NS,INCX
C        DY(I) = DA*DX(I) + DY(I)
C   70 CONTINUE
C      RETURN
C      END
C
C#######################################################################
C
C                       D   D   O   T    (FUNCTION) 
C
C#######################################################################
C
C*DECK DDOT
C      DOUBLE PRECISION FUNCTION DDOT (N, DX, INCX, DY, INCY)
CC***BEGIN PROLOGUE  DDOT
CC***PURPOSE  COMPUTE THE INNER PRODUCT OF TWO VECTORS.
CC***LIBRARY   SLATEC (BLAS)
CC***CATEGORY  D1A4
CC***TYPE      DOUBLE PRECISION (SDOT-S, DDOT-D, CDOTU-C)
CC***KEYWORDS  BLAS, INNER PRODUCT, LINEAR ALGEBRA, VECTOR
CC***AUTHOR  LAWSON, C. L., (JPL)
CC           HANSON, R. J., (SNLA)
CC           KINCAID, D. R., (U. OF TEXAS)
CC           KROGH, F. T., (JPL)
CC***DESCRIPTION
CC
CC                B L A S  SUBPROGRAM
CC    DESCRIPTION OF PARAMETERS
CC
CC     --INPUT--
CC        N  NUMBER OF ELEMENTS IN INPUT VECTOR(S)
CC       DX  DOUBLE PRECISION VECTOR WITH N ELEMENTS
CC     INCX  STORAGE SPACING BETWEEN ELEMENTS OF DX
CC       DY  DOUBLE PRECISION VECTOR WITH N ELEMENTS
CC     INCY  STORAGE SPACING BETWEEN ELEMENTS OF DY
CC
CC     --OUTPUT--
CC     DDOT  DOUBLE PRECISION DOT PRODUCT (ZERO IF N .LE. 0)
CC
CC     RETURNS THE DOT PRODUCT OF DOUBLE PRECISION DX AND DY.
CC     DDOT = SUM FOR I = 0 TO N-1 OF  DX(LX+I*INCX) * DY(LY+I*INCY),
CC     WHERE LX = 1 IF INCX .GE. 0, ELSE LX = 1+(1-N)*INCX, AND LY IS
CC     DEFINED IN A SIMILAR WAY USING INCY.
CC
CC***REFERENCES  C. L. LAWSON, R. J. HANSON, D. R. KINCAID AND F. T.
CC                 KROGH, BASIC LINEAR ALGEBRA SUBPROGRAMS FOR FORTRAN
CC                 USAGE, ALGORITHM NO. 539, TRANSACTIONS ON MATHEMATICAL
CC                 SOFTWARE 5, 3 (SEPTEMBER 1979), PP. 308-323.
CC***ROUTINES CALLED  (NONE)
CC***REVISION HISTORY  (YYMMDD)
CC   791001  DATE WRITTEN
CC   890831  MODIFIED ARRAY DECLARATIONS.  (WRB)
CC   890831  REVISION DATE FROM VERSION 3.2
CC   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
CC   920310  CORRECTED DEFINITION OF LX IN DESCRIPTION.  (WRB)
CC   920501  REFORMATTED THE REFERENCES SECTION.  (WRB)
CC***END PROLOGUE  DDOT
C      DOUBLE PRECISION DX(*), DY(*)
CC***FIRST EXECUTABLE STATEMENT  DDOT
C      DDOT = 0.0D0
C      IF(N .LE. 0) RETURN
C      IF(INCX .EQ. INCY) IF(INCX-1) 5,20,60
CC
CC     CODE FOR UNEQUAL OR NONPOSITIVE INCREMENTS.
CC
C    5 IX = 1
C      IY = 1
C      IF(INCX .LT. 0) IX = (-N+1)*INCX + 1
C      IF(INCY .LT. 0) IY = (-N+1)*INCY + 1
C      DO 10 I = 1,N
C        DDOT = DDOT + DX(IX)*DY(IY)
C        IX = IX + INCX
C        IY = IY + INCY
C   10 CONTINUE
C      RETURN
CC
CC     CODE FOR BOTH INCREMENTS EQUAL TO 1.
CC
CC     CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 5.
CC
C   20 M = MOD(N,5)
C      IF(M .EQ. 0) GO TO 40
C      DO 30 I = 1,M
C         DDOT = DDOT + DX(I)*DY(I)
C   30 CONTINUE
C      IF(N .LT. 5) RETURN
C   40 MP1 = M + 1
C      DO 50 I = MP1,N,5
C      DDOT = DDOT + DX(I)*DY(I) + DX(I+1)*DY(I+1) + DX(I+2)*DY(I+2) +
C     1              DX(I+3)*DY(I+3) + DX(I+4)*DY(I+4)
C   50 CONTINUE
C      RETURN
CC
CC     CODE FOR EQUAL, POSITIVE, NON-UNIT INCREMENTS.
CC
C   60 NS = N*INCX
C      DO 70 I = 1,NS,INCX
C        DDOT = DDOT + DX(I)*DY(I)
C   70 CONTINUE
C      RETURN
C      END
